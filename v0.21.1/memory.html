<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Memory management - PyO3 user guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="rust-from-python.html"><strong aria-hidden="true">2.</strong> Using Rust from Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="module.html"><strong aria-hidden="true">2.1.</strong> Python modules</a></li><li class="chapter-item expanded "><a href="function.html"><strong aria-hidden="true">2.2.</strong> Python functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="function/signature.html"><strong aria-hidden="true">2.2.1.</strong> Function signatures</a></li><li class="chapter-item expanded "><a href="function/error-handling.html"><strong aria-hidden="true">2.2.2.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="class.html"><strong aria-hidden="true">2.3.</strong> Python classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/protocols.html"><strong aria-hidden="true">2.3.1.</strong> Class customizations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/object.html"><strong aria-hidden="true">2.3.1.1.</strong> Basic object customization</a></li><li class="chapter-item expanded "><a href="class/numeric.html"><strong aria-hidden="true">2.3.1.2.</strong> Emulating numeric types</a></li><li class="chapter-item expanded "><a href="class/call.html"><strong aria-hidden="true">2.3.1.3.</strong> Emulating callable objects</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="python-from-rust.html"><strong aria-hidden="true">3.</strong> Calling Python from Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.1.</strong> Python object types</a></li><li class="chapter-item expanded "><a href="exception.html"><strong aria-hidden="true">3.2.</strong> Python exceptions</a></li><li class="chapter-item expanded "><a href="python-from-rust/function-calls.html"><strong aria-hidden="true">3.3.</strong> Calling Python functions</a></li><li class="chapter-item expanded "><a href="python-from-rust/calling-existing-code.html"><strong aria-hidden="true">3.4.</strong> Executing existing Python code</a></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> Type conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversions/tables.html"><strong aria-hidden="true">4.1.</strong> Mapping of Rust types to Python types</a></li><li class="chapter-item expanded "><a href="conversions/traits.html"><strong aria-hidden="true">4.2.</strong> Conversion traits</a></li></ol></li><li class="chapter-item expanded "><a href="async-await.html"><strong aria-hidden="true">5.</strong> Using async and await</a></li><li class="chapter-item expanded "><a href="parallelism.html"><strong aria-hidden="true">6.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">7.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">8.</strong> Features reference</a></li><li class="chapter-item expanded "><a href="memory.html" class="active"><strong aria-hidden="true">9.</strong> Memory management</a></li><li class="chapter-item expanded "><a href="performance.html"><strong aria-hidden="true">10.</strong> Performance</a></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">11.</strong> Advanced topics</a></li><li class="chapter-item expanded "><a href="building-and-distribution.html"><strong aria-hidden="true">12.</strong> Building and distribution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building-and-distribution/multiple-python-versions.html"><strong aria-hidden="true">12.1.</strong> Supporting multiple Python versions</a></li></ol></li><li class="chapter-item expanded "><a href="ecosystem.html"><strong aria-hidden="true">13.</strong> Useful crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecosystem/logging.html"><strong aria-hidden="true">13.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="ecosystem/async-await.html"><strong aria-hidden="true">13.2.</strong> Using async and await</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">14.</strong> FAQ and troubleshooting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="migration.html">Appendix A: Migration guide</a></li><li class="chapter-item expanded affix "><a href="trait-bounds.html">Appendix B: Trait bounds</a></li><li class="chapter-item expanded affix "><a href="python-typing-hints.html">Appendix C: Python typing hints</a></li><li class="chapter-item expanded affix "><a href="changelog.html">CHANGELOG</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributing.html">Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/PyO3/pyo3/tree/main/guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/PyO3/pyo3/edit/main/guide/src/memory.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="memory-management"><a class="header" href="#memory-management">Memory management</a></h1>
<div class="warning">
<p>⚠️ Warning: API update in progress 🛠️</p>
<p>PyO3 0.21 has introduced a significant new API, termed the "Bound" API after the new smart pointer <code>Bound&lt;T&gt;</code>.</p>
<p>This section on memory management is heavily weighted towards the now-deprecated "GIL Refs" API, which suffered from the drawbacks detailed here as well as CPU overheads.</p>
<p>See <a href="./types.html#pyo3s-smart-pointers">the smart pointer types</a> for description on the new, simplified, memory model of the Bound API, which is built as a thin wrapper on Python reference counting.</p>
</div>
<p>Rust and Python have very different notions of memory management.  Rust has
a strict memory model with concepts of ownership, borrowing, and lifetimes,
where memory is freed at predictable points in program execution.  Python has
a looser memory model in which variables are reference-counted with shared,
mutable state by default. A global interpreter lock (GIL) is needed to prevent
race conditions, and a garbage collector is needed to break reference cycles.
Memory in Python is freed eventually by the garbage collector, but not usually
in a predictable way.</p>
<p>PyO3 bridges the Rust and Python memory models with two different strategies for
accessing memory allocated on Python's heap from inside Rust. These are
GIL Refs such as <code>&amp;'py PyAny</code>, and GIL-independent <code>Py&lt;Any&gt;</code> smart pointers.</p>
<h2 id="gil-bound-memory"><a class="header" href="#gil-bound-memory">GIL-bound memory</a></h2>
<p>PyO3's GIL Refs such as <code>&amp;'py PyAny</code> make PyO3 more ergonomic to
use by ensuring that their lifetime can never be longer than the duration the
Python GIL is held.  This means that most of PyO3's API can assume the GIL is
held. (If PyO3 could not assume this, every PyO3 API would need to take a
<code>Python</code> GIL token to prove that the GIL is held.)  This allows us to write
very simple and easy-to-understand programs like this:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    #[allow(deprecated)] // py.eval() is part of the GIL Refs API
    let hello = py
        .eval("\"Hello World!\"", None, None)?
        .downcast::&lt;PyString&gt;()?;
    println!("Python says: {}", hello);
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Internally, calling <code>Python::with_gil()</code> creates a <code>GILPool</code> which owns the
memory pointed to by the reference.  In the example above, the lifetime of the
reference <code>hello</code> is bound to the <code>GILPool</code>.  When the <code>with_gil()</code> closure ends
the <code>GILPool</code> is also dropped and the Python reference counts of the variables
it owns are decreased, releasing them to the Python garbage collector.  Most
of the time we don't have to think about this, but consider the following:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    for _ in 0..10 {
        #[allow(deprecated)] // py.eval() is part of the GIL Refs API
        let hello = py
            .eval("\"Hello World!\"", None, None)?
            .downcast::&lt;PyString&gt;()?;
        println!("Python says: {}", hello);
    }
    // There are 10 copies of `hello` on Python's heap here.
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>We might assume that the <code>hello</code> variable's memory is freed at the end of each
loop iteration, but in fact we create 10 copies of <code>hello</code> on Python's heap.
This may seem surprising at first, but it is completely consistent with Rust's
memory model.  The <code>hello</code> variable is dropped at the end of each loop, but it
is only a reference to the memory owned by the <code>GILPool</code>, and its lifetime is
bound to the <code>GILPool</code>, not the for loop.  The <code>GILPool</code> isn't dropped until
the end of the <code>with_gil()</code> closure, at which point the 10 copies of <code>hello</code>
are finally released to the Python garbage collector.</p>
<div class="warning">
<p>⚠️ Warning: <code>GILPool</code> is no longer the preferred way to manage memory with PyO3 🛠️</p>
<p>PyO3 0.21 has introduced a new API known as the Bound API, which doesn't have the same surprising results. Instead, each <code>Bound&lt;T&gt;</code> smart pointer releases the Python reference immediately on drop. See <a href="./types.html#pyo3s-smart-pointers">the smart pointer types</a> for more details.</p>
</div>
<p>In general we don't want unbounded memory growth during loops!  One workaround
is to acquire and release the GIL with each iteration of the loop.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>for _ in 0..10 {
    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
        #[allow(deprecated)] // py.eval() is part of the GIL Refs API
        let hello = py
            .eval("\"Hello World!\"", None, None)?
            .downcast::&lt;PyString&gt;()?;
        println!("Python says: {}", hello);
        Ok(())
    })?; // only one copy of `hello` at a time
}
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>It might not be practical or performant to acquire and release the GIL so many
times.  Another workaround is to work with the <code>GILPool</code> object directly, but
this is unsafe.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    for _ in 0..10 {
        #[allow(deprecated)] // `new_pool` is not needed in code not using the GIL Refs API
        let pool = unsafe { py.new_pool() };
        let py = pool.python();
        #[allow(deprecated)] // py.eval() is part of the GIL Refs API
        let hello = py
            .eval("\"Hello World!\"", None, None)?
            .downcast::&lt;PyString&gt;()?;
        println!("Python says: {}", hello);
    }
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>The unsafe method <code>Python::new_pool</code> allows you to create a nested <code>GILPool</code>
from which you can retrieve a new <code>py: Python</code> GIL token.  Variables created
with this new GIL token are bound to the nested <code>GILPool</code> and will be released
when the nested <code>GILPool</code> is dropped.  Here, the nested <code>GILPool</code> is dropped
at the end of each loop iteration, before the <code>with_gil()</code> closure ends.</p>
<p>When doing this, you must be very careful to ensure that once the <code>GILPool</code> is
dropped you do not retain access to any owned references created after the
<code>GILPool</code> was created.  Read the
<a href="https://docs.rs/pyo3/0.21.1/pyo3/marker/struct.Python.html#method.new_pool">documentation for <code>Python::new_pool()</code></a>
for more information on safety.</p>
<p>This memory management can also be applicable when writing extension modules.
<code>#[pyfunction]</code> and <code>#[pymethods]</code> will create a <code>GILPool</code> which lasts the entire
function call, releasing objects when the function returns. Most functions only create
a few objects, meaning this doesn't have a significant impact. Occasionally functions
with long complex loops may need to use <code>Python::new_pool</code> as shown above.</p>
<div class="warning">
<p>⚠️ Warning: <code>GILPool</code> is no longer the preferred way to manage memory with PyO3 🛠️</p>
<p>PyO3 0.21 has introduced a new API known as the Bound API, which doesn't have the same surprising results. Instead, each <code>Bound&lt;T&gt;</code> smart pointer releases the Python reference immediately on drop. See <a href="./types.html#pyo3s-smart-pointers">the smart pointer types</a> for more details.</p>
</div>
<h2 id="gil-independent-memory"><a class="header" href="#gil-independent-memory">GIL-independent memory</a></h2>
<p>Sometimes we need a reference to memory on Python's heap that can outlive the
GIL.  Python's <code>Py&lt;PyAny&gt;</code> is analogous to <code>Arc&lt;T&gt;</code>, but for variables whose
memory is allocated on Python's heap.  Cloning a <code>Py&lt;PyAny&gt;</code> increases its
internal reference count just like cloning <code>Arc&lt;T&gt;</code>.  The smart pointer can
outlive the "GIL is held" period in which it was created.  It isn't magic,
though.  We need to reacquire the GIL to access the memory pointed to by the
<code>Py&lt;PyAny&gt;</code>.</p>
<p>What happens to the memory when the last <code>Py&lt;PyAny&gt;</code> is dropped and its
reference count reaches zero?  It depends whether or not we are holding the GIL.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    #[allow(deprecated)] // py.eval() is part of the GIL Refs API
    let hello: Py&lt;PyString&gt; = py.eval("\"Hello World!\"", None, None)?.extract()?;
    #[allow(deprecated)] // as_ref is part of the GIL Refs API
    {
        println!("Python says: {}", hello.as_ref(py));
    }
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>At the end of the <code>Python::with_gil()</code> closure <code>hello</code> is dropped, and then the
GIL is dropped.  Since <code>hello</code> is dropped while the GIL is still held by the
current thread, its memory is released to the Python garbage collector
immediately.</p>
<p>This example wasn't very interesting.  We could have just used a GIL-bound
<code>&amp;PyString</code> reference.  What happens when the last <code>Py&lt;Any&gt;</code> is dropped while
we are <em>not</em> holding the GIL?</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>let hello: Py&lt;PyString&gt; = Python::with_gil(|py| {
    #[allow(deprecated)] // py.eval() is part of the GIL Refs API
    py.eval("\"Hello World!\"", None, None)?.extract()
})?;
// Do some stuff...
// Now sometime later in the program we want to access `hello`.
Python::with_gil(|py| {
    #[allow(deprecated)]  // as_ref is part of the deprecated "GIL Refs" API.
    let hello = hello.as_ref(py);
    println!("Python says: {}", hello);
});
// Now we're done with `hello`.
drop(hello); // Memory *not* released here.
// Sometime later we need the GIL again for something...
Python::with_gil(|py|
    // Memory for `hello` is released here.
<span class="boring">()
</span>);
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>When <code>hello</code> is dropped <em>nothing</em> happens to the pointed-to memory on Python's
heap because nothing <em>can</em> happen if we're not holding the GIL.  Fortunately,
the memory isn't leaked.  PyO3 keeps track of the memory internally and will
release it the next time we acquire the GIL.</p>
<p>We can avoid the delay in releasing memory if we are careful to drop the
<code>Py&lt;Any&gt;</code> while the GIL is held.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // py.eval() is part of the GIL Refs API
let hello: Py&lt;PyString&gt; =
    Python::with_gil(|py| py.eval("\"Hello World!\"", None, None)?.extract())?;
// Do some stuff...
// Now sometime later in the program:
Python::with_gil(|py| {
    #[allow(deprecated)] // as_ref is part of the GIL Refs API
    {
        println!("Python says: {}", hello.as_ref(py));
    }
    drop(hello); // Memory released here.
});
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>We could also have used <code>Py::into_ref()</code>, which consumes <code>self</code>, instead of
<code>Py::as_ref()</code>.  But note that in addition to being slower than <code>as_ref()</code>,
<code>into_ref()</code> binds the memory to the lifetime of the <code>GILPool</code>, which means
that rather than being released immediately, the memory will not be released
until the GIL is dropped.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // py.eval() is part of the GIL Refs API
let hello: Py&lt;PyString&gt; =
    Python::with_gil(|py| py.eval("\"Hello World!\"", None, None)?.extract())?;
// Do some stuff...
// Now sometime later in the program:
Python::with_gil(|py| {
    #[allow(deprecated)] // into_ref is part of the GIL Refs API
    {
        println!("Python says: {}", hello.into_ref(py));
    }
    // Memory not released yet.
    // Do more stuff...
    // Memory released here at end of `with_gil()` closure.
});
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="performance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="performance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
