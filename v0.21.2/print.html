<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PyO3 user guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="rust-from-python.html"><strong aria-hidden="true">2.</strong> Using Rust from Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="module.html"><strong aria-hidden="true">2.1.</strong> Python modules</a></li><li class="chapter-item expanded "><a href="function.html"><strong aria-hidden="true">2.2.</strong> Python functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="function/signature.html"><strong aria-hidden="true">2.2.1.</strong> Function signatures</a></li><li class="chapter-item expanded "><a href="function/error-handling.html"><strong aria-hidden="true">2.2.2.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="class.html"><strong aria-hidden="true">2.3.</strong> Python classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/protocols.html"><strong aria-hidden="true">2.3.1.</strong> Class customizations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="class/object.html"><strong aria-hidden="true">2.3.1.1.</strong> Basic object customization</a></li><li class="chapter-item expanded "><a href="class/numeric.html"><strong aria-hidden="true">2.3.1.2.</strong> Emulating numeric types</a></li><li class="chapter-item expanded "><a href="class/call.html"><strong aria-hidden="true">2.3.1.3.</strong> Emulating callable objects</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="python-from-rust.html"><strong aria-hidden="true">3.</strong> Calling Python from Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.1.</strong> Python object types</a></li><li class="chapter-item expanded "><a href="exception.html"><strong aria-hidden="true">3.2.</strong> Python exceptions</a></li><li class="chapter-item expanded "><a href="python-from-rust/function-calls.html"><strong aria-hidden="true">3.3.</strong> Calling Python functions</a></li><li class="chapter-item expanded "><a href="python-from-rust/calling-existing-code.html"><strong aria-hidden="true">3.4.</strong> Executing existing Python code</a></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> Type conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversions/tables.html"><strong aria-hidden="true">4.1.</strong> Mapping of Rust types to Python types</a></li><li class="chapter-item expanded "><a href="conversions/traits.html"><strong aria-hidden="true">4.2.</strong> Conversion traits</a></li></ol></li><li class="chapter-item expanded "><a href="async-await.html"><strong aria-hidden="true">5.</strong> Using async and await</a></li><li class="chapter-item expanded "><a href="parallelism.html"><strong aria-hidden="true">6.</strong> Parallelism</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">7.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">8.</strong> Features reference</a></li><li class="chapter-item expanded "><a href="memory.html"><strong aria-hidden="true">9.</strong> Memory management</a></li><li class="chapter-item expanded "><a href="performance.html"><strong aria-hidden="true">10.</strong> Performance</a></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">11.</strong> Advanced topics</a></li><li class="chapter-item expanded "><a href="building-and-distribution.html"><strong aria-hidden="true">12.</strong> Building and distribution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building-and-distribution/multiple-python-versions.html"><strong aria-hidden="true">12.1.</strong> Supporting multiple Python versions</a></li></ol></li><li class="chapter-item expanded "><a href="ecosystem.html"><strong aria-hidden="true">13.</strong> Useful crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecosystem/logging.html"><strong aria-hidden="true">13.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="ecosystem/async-await.html"><strong aria-hidden="true">13.2.</strong> Using async and await</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">14.</strong> FAQ and troubleshooting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="migration.html">Appendix A: Migration guide</a></li><li class="chapter-item expanded affix "><a href="trait-bounds.html">Appendix B: Trait bounds</a></li><li class="chapter-item expanded affix "><a href="python-typing-hints.html">Appendix C: Python typing hints</a></li><li class="chapter-item expanded affix "><a href="changelog.html">CHANGELOG</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributing.html">Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/PyO3/pyo3/tree/main/guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-pyo3-user-guide"><a class="header" href="#the-pyo3-user-guide">The PyO3 user guide</a></h1>
<p>Welcome to the PyO3 user guide! This book is a companion to <a href="https://docs.rs/pyo3">PyO3's API docs</a>. It contains examples and documentation to explain all of PyO3's use cases in detail.</p>
<p>The rough order of material in this user guide is as follows:</p>
<ol>
<li>Getting started</li>
<li>Wrapping Rust code for use from Python</li>
<li>How to use Python code from Rust</li>
<li>Remaining topics which go into advanced concepts in detail</li>
</ol>
<p>Please choose from the chapters on the left to jump to individual topics, or continue below to start with PyO3's README.</p>
<div class="warning">
<p>⚠️ Warning: API update in progress 🛠️</p>
<p>PyO3 0.21 has introduced a significant new API, termed the "Bound" API after the new smart pointer <code>Bound&lt;T&gt;</code>.</p>
<p>While most of this guide has been updated to the new API, it is possible some stray references to the older "GIL Refs" API such as <code>&amp;PyAny</code> remain.</p>
</div>
<hr style="opacity:0.2">
<h1 id="pyo3"><a class="header" href="#pyo3">PyO3</a></h1>
<p><a href="https://github.com/PyO3/pyo3/actions"><img src="https://img.shields.io/github/actions/workflow/status/PyO3/pyo3/ci.yml?branch=main&amp;logo=github&amp;style=" alt="actions status" /></a>
<a href="https://pyo3.rs/dev/bench/"><img src="https://img.shields.io/badge/benchmark-%E2%9C%93-Green?logo=github" alt="benchmark" /></a>
<a href="https://codecov.io/gh/PyO3/pyo3"><img src="https://img.shields.io/codecov/c/gh/PyO3/pyo3?logo=codecov" alt="codecov" /></a>
<a href="https://crates.io/crates/pyo3"><img src="https://img.shields.io/crates/v/pyo3?logo=rust" alt="crates.io" /></a>
<a href="https://rust-lang.github.io/rfcs/2495-min-rust-version.html"><img src="https://img.shields.io/badge/rustc-1.56+-blue?logo=rust" alt="minimum rustc 1.56" /></a>
<a href="https://discord.gg/33kcChzH7f"><img src="https://img.shields.io/discord/1209263839632424990?logo=discord" alt="discord server" /></a>
<a href="https://github.com/PyO3/pyo3/blob/main/Contributing.md"><img src="https://img.shields.io/badge/contribute-on%20github-Green?logo=github" alt="contributing notes" /></a></p>
<p><a href="https://www.rust-lang.org/">Rust</a> bindings for <a href="https://www.python.org/">Python</a>, including tools for creating native Python extension modules. Running and interacting with Python code from a Rust binary is also supported.</p>
<ul>
<li>
<p>User Guide: <a href="https://pyo3.rs">stable</a> | <a href="https://pyo3.rs/main">main</a></p>
</li>
<li>
<p>API Documentation: <a href="https://docs.rs/pyo3/">stable</a> | <a href="https://pyo3.rs/main/doc">main</a></p>
</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>PyO3 supports the following software versions:</p>
<ul>
<li>Python 3.7 and up (CPython, PyPy, and GraalPy)</li>
<li>Rust 1.56 and up</li>
</ul>
<p>You can use PyO3 to write a native Python module in Rust, or to embed Python in a Rust binary. The following sections explain each of these in turn.</p>
<h3 id="using-rust-from-python"><a class="header" href="#using-rust-from-python">Using Rust from Python</a></h3>
<p>PyO3 can be used to generate a native Python module. The easiest way to try this out for the first time is to use <a href="https://github.com/PyO3/maturin"><code>maturin</code></a>. <code>maturin</code> is a tool for building and publishing Rust-based Python packages with minimal configuration. The following steps install <code>maturin</code>, use it to generate and build a new Python package, and then launch Python to import and execute a function from the package.</p>
<p>First, follow the commands below to create a new directory containing a new Python <code>virtualenv</code>, and install <code>maturin</code> into the virtualenv using Python's package manager, <code>pip</code>:</p>
<pre><code class="language-bash"># (replace string_sum with the desired package name)
$ mkdir string_sum
$ cd string_sum
$ python -m venv .env
$ source .env/bin/activate
$ pip install maturin
</code></pre>
<p>Still inside this <code>string_sum</code> directory, now run <code>maturin init</code>. This will generate the new package source. When given the choice of bindings to use, select pyo3 bindings:</p>
<pre><code class="language-bash">$ maturin init
✔ 🤷 What kind of bindings to use? · pyo3
  ✨ Done! New project created string_sum
</code></pre>
<p>The most important files generated by this command are <code>Cargo.toml</code> and <code>lib.rs</code>, which will look roughly like the following:</p>
<p><strong><code>Cargo.toml</code></strong></p>
<pre><code class="language-toml">[package]
name = "string_sum"
version = "0.1.0"
edition = "2021"

[lib]
# The name of the native library. This is the name which will be used in Python to import the
# library (i.e. `import string_sum`). If you change this, you must also change the name of the
# `#[pymodule]` in `src/lib.rs`.
name = "string_sum"
# "cdylib" is necessary to produce a shared library for Python to import from.
#
# Downstream Rust code (including code in `bin/`, `examples/`, and `tests/`) will not be able
# to `use string_sum;` unless the "rlib" or "lib" crate type is also included, e.g.:
# crate-type = ["cdylib", "rlib"]
crate-type = ["cdylib"]

[dependencies]
pyo3 = { version = "0.21.2", features = ["extension-module"] }
</code></pre>
<p><strong><code>src/lib.rs</code></strong></p>
<pre><code class="language-rust">use pyo3::prelude::*;

/// Formats the sum of two numbers as string.
#[pyfunction]
fn sum_as_string(a: usize, b: usize) -&gt; PyResult&lt;String&gt; {
    Ok((a + b).to_string())
}

/// A Python module implemented in Rust. The name of this function must match
/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to
/// import the module.
#[pymodule]
fn string_sum(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;
    Ok(())
}</code></pre>
<p>Finally, run <code>maturin develop</code>. This will build the package and install it into the Python virtualenv previously created and activated. The package is then ready to be used from <code>python</code>:</p>
<pre><code class="language-bash">$ maturin develop
# lots of progress output as maturin runs the compilation...
$ python
&gt;&gt;&gt; import string_sum
&gt;&gt;&gt; string_sum.sum_as_string(5, 20)
'25'
</code></pre>
<p>To make changes to the package, just edit the Rust source code and then re-run <code>maturin develop</code> to recompile.</p>
<p>To run this all as a single copy-and-paste, use the bash script below (replace <code>string_sum</code> in the first command with the desired package name):</p>
<pre><code class="language-bash">mkdir string_sum &amp;&amp; cd "$_"
python -m venv .env
source .env/bin/activate
pip install maturin
maturin init --bindings pyo3
maturin develop
</code></pre>
<p>If you want to be able to run <code>cargo test</code> or use this project in a Cargo workspace and are running into linker issues, there are some workarounds in <a href="https://pyo3.rs/latest/faq.html#i-cant-run-cargo-test-or-i-cant-build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror">the FAQ</a>.</p>
<p>As well as with <code>maturin</code>, it is possible to build using <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> or <a href="https://pyo3.rs/latest/building-and-distribution.html#manual-builds">manually</a>. Both offer more flexibility than <code>maturin</code> but require more configuration to get started.</p>
<h3 id="using-python-from-rust"><a class="header" href="#using-python-from-rust">Using Python from Rust</a></h3>
<p>To embed Python into a Rust binary, you need to ensure that your Python installation contains a shared library. The following steps demonstrate how to ensure this (for Ubuntu), and then give some example code which runs an embedded Python interpreter.</p>
<p>To install the Python shared library on Ubuntu:</p>
<pre><code class="language-bash">sudo apt install python3-dev
</code></pre>
<p>To install the Python shared library on RPM based distributions (e.g. Fedora, Red Hat, SuSE), install the <code>python3-devel</code> package.</p>
<p>Start a new project with <code>cargo new</code> and add  <code>pyo3</code> to the <code>Cargo.toml</code> like this:</p>
<pre><code class="language-toml">[dependencies.pyo3]
version = "0.21.2"
features = ["auto-initialize"]
</code></pre>
<p>Example program displaying the value of <code>sys.version</code> and the current user name:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::IntoPyDict;

fn main() -&gt; PyResult&lt;()&gt; {
    Python::with_gil(|py| {
        let sys = py.import_bound("sys")?;
        let version: String = sys.getattr("version")?.extract()?;

        let locals = [("os", py.import_bound("os")?)].into_py_dict_bound(py);
        let code = "os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'";
        let user: String = py.eval_bound(code, None, Some(&amp;locals))?.extract()?;

        println!("Hello {}, I'm Python {}", user, version);
        Ok(())
    })
}</code></pre>
<p>The guide has <a href="https://pyo3.rs/latest/python-from-rust.html">a section</a> with lots of examples
about this topic.</p>
<h2 id="tools-and-libraries"><a class="header" href="#tools-and-libraries">Tools and libraries</a></h2>
<ul>
<li><a href="https://github.com/PyO3/maturin">maturin</a> <em>Build and publish crates with pyo3, rust-cpython or cffi bindings as well as rust binaries as python packages</em></li>
<li><a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a> <em>Setuptools plugin for Rust support</em>.</li>
<li><a href="https://github.com/PyO3/pyo3-built">pyo3-built</a> <em>Simple macro to expose metadata obtained with the <a href="https://crates.io/crates/built"><code>built</code></a> crate as a <a href="https://docs.rs/pyo3/*/pyo3/types/struct.PyDict.html"><code>PyDict</code></a></em></li>
<li><a href="https://github.com/PyO3/rust-numpy">rust-numpy</a> <em>Rust binding of NumPy C-API</em></li>
<li><a href="https://github.com/gperinazzo/dict-derive">dict-derive</a> <em>Derive FromPyObject to automatically transform Python dicts into Rust structs</em></li>
<li><a href="https://github.com/vorner/pyo3-log">pyo3-log</a> <em>Bridge from Rust to Python logging</em></li>
<li><a href="https://github.com/davidhewitt/pythonize">pythonize</a> <em>Serde serializer for converting Rust objects to JSON-compatible Python objects</em></li>
<li><a href="https://github.com/awestlake87/pyo3-asyncio">pyo3-asyncio</a> <em>Utilities for working with Python's Asyncio library and async functions</em></li>
<li><a href="https://github.com/mityax/rustimport">rustimport</a> <em>Directly import Rust files or crates from Python, without manual compilation step. Provides pyo3 integration by default and generates pyo3 binding code automatically.</em></li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<ul>
<li><a href="https://github.com/autopilot-rs/autopy">autopy</a> <em>A simple, cross-platform GUI automation library for Python and Rust.</em>
<ul>
<li>Contains an example of building wheels on TravisCI and appveyor using <a href="https://github.com/pypa/cibuildwheel">cibuildwheel</a></li>
</ul>
</li>
<li><a href="https://github.com/apache/arrow-ballista-python">ballista-python</a> <em>A Python library that binds to Apache Arrow distributed query engine Ballista.</em></li>
<li><a href="https://github.com/fastlmm/bed-reader">bed-reader</a> <em>Read and write the PLINK BED format, simply and efficiently.</em>
<ul>
<li>Shows Rayon/ndarray::parallel (including capturing errors, controlling thread num), Python types to Rust generics, Github Actions</li>
</ul>
</li>
<li><a href="https://github.com/pyca/cryptography/tree/main/src/rust">cryptography</a> <em>Python cryptography library with some functionality in Rust.</em></li>
<li><a href="https://github.com/Stranger6667/css-inline/tree/master/bindings/python">css-inline</a> <em>CSS inlining for Python implemented in Rust.</em></li>
<li><a href="https://github.com/apache/arrow-datafusion-python">datafusion-python</a> <em>A Python library that binds to Apache Arrow in-memory query engine DataFusion.</em></li>
<li><a href="https://github.com/delta-io/delta-rs/tree/main/python">deltalake-python</a> <em>Native Delta Lake Python binding based on delta-rs with Pandas integration.</em></li>
<li><a href="https://github.com/yankun1992/fastbloom">fastbloom</a> <em>A fast <a href="https://github.com/yankun1992/fastbloom#BloomFilter">bloom filter</a> | <a href="https://github.com/yankun1992/fastbloom#countingbloomfilter">counting bloom filter</a> implemented by Rust for Rust and Python!</em></li>
<li><a href="https://github.com/thedrow/fastuuid/">fastuuid</a> <em>Python bindings to Rust's UUID library.</em></li>
<li><a href="https://github.com/feos-org/feos">feos</a> <em>Lightning fast thermodynamic modeling in Rust with fully developed Python interface.</em></li>
<li><a href="https://github.com/jinlow/forust">forust</a> <em>A lightweight gradient boosted decision tree library written in Rust.</em></li>
<li><a href="https://github.com/GreptimeTeam/greptimedb/tree/main/src/script">greptimedb</a> <em>Support <a href="https://docs.greptime.com/user-guide/python-scripts/overview">Python scripting</a> in the database</em></li>
<li><a href="https://github.com/BooleanCat/haem">haem</a> <em>A Python library for working on Bioinformatics problems.</em></li>
<li><a href="https://github.com/PyO3/setuptools-rust/tree/main/examples/html-py-ever">html-py-ever</a> <em>Using <a href="https://github.com/servo/html5ever">html5ever</a> through <a href="https://github.com/kuchiki-rs/kuchiki">kuchiki</a> to speed up html parsing and css-selecting.</em></li>
<li><a href="https://github.com/mre/hyperjson">hyperjson</a> <em>A hyper-fast Python module for reading/writing JSON data using Rust's serde-json.</em></li>
<li><a href="https://github.com/fusion-engineering/inline-python">inline-python</a> <em>Inline Python code directly in your Rust code.</em></li>
<li><a href="https://github.com/kushaldas/johnnycanencrypt">johnnycanencrypt</a> OpenPGP library with Yubikey support.</li>
<li><a href="https://github.com/Stranger6667/jsonschema-rs/tree/master/bindings/python">jsonschema-rs</a> <em>Fast JSON Schema validation library.</em></li>
<li><a href="https://github.com/cds-astro/mocpy">mocpy</a> <em>Astronomical Python library offering data structures for describing any arbitrary coverage regions on the unit sphere.</em></li>
<li><a href="https://github.com/apache/opendal/tree/main/bindings/python">opendal</a> <em>A data access layer that allows users to easily and efficiently retrieve data from various storage services in a unified way.</em></li>
<li><a href="https://github.com/ijl/orjson">orjson</a> <em>Fast Python JSON library.</em></li>
<li><a href="https://github.com/aviramha/ormsgpack">ormsgpack</a> <em>Fast Python msgpack library.</em></li>
<li><a href="https://github.com/ManifoldFR/point-process-rust/tree/master/pylib">point-process</a> <em>High level API for pointprocesses as a Python library.</em></li>
<li><a href="https://github.com/daggy1234/polaroid">polaroid</a> <em>Hyper Fast and safe image manipulation library for Python written in Rust.</em></li>
<li><a href="https://github.com/pola-rs/polars">polars</a> <em>Fast multi-threaded DataFrame library in Rust | Python | Node.js.</em></li>
<li><a href="https://github.com/pydantic/pydantic-core">pydantic-core</a> <em>Core validation logic for pydantic written in Rust.</em></li>
<li><a href="https://github.com/kevinheavey/pyheck">pyheck</a> <em>Fast case conversion library, built by wrapping <a href="https://github.com/withoutboats/heck">heck</a>.</em>
<ul>
<li>Quite easy to follow as there's not much code.</li>
</ul>
</li>
<li><a href="https://github.com/Project-Dream-Weaver/pyre-http">pyre</a> <em>Fast Python HTTP server written in Rust.</em></li>
<li><a href="https://github.com/Cryptex-github/ril-py">ril-py</a> <em>A performant and high-level image processing library for Python written in Rust.</em></li>
<li><a href="https://github.com/online-ml/river">river</a> <em>Online machine learning in python, the computationally heavy statistics algorithms are implemented in Rust.</em></li>
<li><a href="https://github.com/cjermain/rust-python-coverage">rust-python-coverage</a> <em>Example PyO3 project with automated test coverage for Rust and Python.</em></li>
<li><a href="https://github.com/openai/tiktoken">tiktoken</a> <em>A fast BPE tokeniser for use with OpenAI's models.</em></li>
<li><a href="https://github.com/huggingface/tokenizers/tree/main/bindings/python">tokenizers</a> <em>Python bindings to the Hugging Face tokenizers (NLP) written in Rust.</em></li>
<li><a href="http://github.com/ringsaturn/tzfpy">tzfpy</a> <em>A fast package to convert longitude/latitude to timezone name.</em></li>
<li><a href="https://github.com/jessekrubin/utiles">utiles</a> <em>Fast Python web-map tile utilities</em></li>
<li><a href="https://github.com/wasmerio/wasmer-python">wasmer-python</a> <em>Python library to run WebAssembly binaries.</em></li>
</ul>
<h2 id="articles-and-other-media"><a class="header" href="#articles-and-other-media">Articles and other media</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=T45ZEmSR1-s">(Video) Extending Python with Rust using PyO3</a> - Dec 16, 2023</li>
<li><a href="https://terencezl.github.io/blog/2023/06/06/a-week-of-pyo3-rust-numpy/">A Week of PyO3 + rust-numpy (How to Speed Up Your Data Pipeline X Times)</a> - Jun 6, 2023</li>
<li><a href="https://rustacean-station.org/episode/david-hewitt/">(Podcast) PyO3 with David Hewitt</a> - May 19, 2023</li>
<li><a href="https://ohadravid.github.io/posts/2023-03-rusty-python/">Making Python 100x faster with less than 100 lines of Rust</a> - Mar 28, 2023</li>
<li><a href="https://fosdem.org/2023/schedule/event/rust_how_pydantic_v2_leverages_rusts_superpowers/">How Pydantic V2 leverages Rust's Superpowers</a> - Feb 4, 2023</li>
<li><a href="https://boring-guy.sh/posts/river-rust/">How we extended the River stats module with Rust using PyO3</a> - Dec 23, 2022</li>
<li><a href="https://towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29?sk=f8d808d5f414154fdb811e4137011437">Nine Rules for Writing Python Extensions in Rust</a> - Dec 31, 2021</li>
<li><a href="https://saidvandeklundert.net/learn/2021-11-18-calling-rust-from-python-using-pyo3/">Calling Rust from Python using PyO3</a> - Nov 18, 2021</li>
<li><a href="https://www.youtube.com/watch?v=-XyWG_klSAw&amp;t=320s">davidhewitt's 2021 talk at Rust Manchester meetup</a> - Aug 19, 2021</li>
<li><a href="https://blog.waleedkhan.name/port-python-to-rust/">Incrementally porting a small Python project to Rust</a> - Apr 29, 2021</li>
<li><a href="https://www.vortexa.com/insight/integrating-rust-into-python">Vortexa - Integrating Rust into Python</a> - Apr 12, 2021</li>
<li><a href="https://blog.yossarian.net/2020/08/02/Writing-and-publishing-a-python-module-in-rust">Writing and publishing a Python module in Rust</a> - Aug 2, 2020</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Everyone is welcomed to contribute to PyO3! There are many ways to support the project, such as:</p>
<ul>
<li>help PyO3 users with issues on GitHub and <a href="https://discord.gg/33kcChzH7f">Discord</a></li>
<li>improve documentation</li>
<li>write features and bugfixes</li>
<li>publish blogs and examples of how to use PyO3</li>
</ul>
<p>Our <a href="https://github.com/PyO3/pyo3/blob/main/Contributing.md">contributing notes</a> and <a href="https://github.com/PyO3/pyo3/blob/main/Architecture.md">architecture guide</a> have more resources if you wish to volunteer time for PyO3 and are searching where to start.</p>
<p>If you don't have time to contribute yourself but still wish to support the project's future success, some of our maintainers have GitHub sponsorship pages:</p>
<ul>
<li><a href="https://github.com/sponsors/davidhewitt">davidhewitt</a></li>
<li><a href="https://github.com/sponsors/messense">messense</a></li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>PyO3 is licensed under the <a href="LICENSE-APACHE">Apache-2.0 license</a> or the <a href="LICENSE-MIT">MIT license</a>, at your option.</p>
<p>Python is licensed under the <a href="https://docs.python.org/3/license.html">Python License</a>.</p>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in PyO3 by you, as defined in the Apache License, shall be dual-licensed as above, without any additional terms or conditions.</p>
<p><a href="https://www.netlify.com"> <img src="https://www.netlify.com/v3/img/components/netlify-color-accent.svg" alt="Deploys by Netlify" /> </a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>To get started using PyO3 you will need three things: a Rust toolchain, a Python environment, and a way to build. We'll cover each of these below.</p>
<blockquote>
<p>If you'd like to chat to the PyO3 maintainers and other PyO3 users, consider joining the <a href="https://discord.gg/33kcChzH7f">PyO3 Discord server</a>. We're keen to hear about your experience getting started, so we can make PyO3 as accessible as possible for everyone!</p>
</blockquote>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>First, make sure you have Rust installed on your system. If you haven't already done so, try following the instructions <a href="https://www.rust-lang.org/tools/install">here</a>. PyO3 runs on both the <code>stable</code> and <code>nightly</code> versions so you can choose whichever one fits you best. The minimum required Rust version is 1.56.</p>
<p>If you can run <code>rustc --version</code> and the version is new enough you're good to go!</p>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<p>To use PyO3, you need at least Python 3.7. While you can simply use the default Python interpreter on your system, it is recommended to use a virtual environment.</p>
<h2 id="virtualenvs"><a class="header" href="#virtualenvs">Virtualenvs</a></h2>
<p>While you can use any virtualenv manager you like, we recommend the use of <code>pyenv</code> in particular if you want to develop or test for multiple different Python versions, so that is what the examples in this book will use. The installation instructions for <code>pyenv</code> can be found <a href="https://github.com/pyenv/pyenv#getting-pyenv">here</a>. (Note: To get the <code>pyenv activate</code> and <code>pyenv virtualenv</code> commands, you will also need to install the <a href="https://github.com/pyenv/pyenv-virtualenv"><code>pyenv-virtualenv</code></a> plugin. The <a href="https://github.com/pyenv/pyenv-installer#installation--update--uninstallation">pyenv installer</a> will install both together.)</p>
<p>If you intend to run Python from Rust (for example in unit tests) you should set the following environment variable when installing a new Python version using <code>pyenv</code>:</p>
<pre><code class="language-bash">PYTHON_CONFIGURE_OPTS="--enable-shared"
</code></pre>
<p>For example:</p>
<pre><code class="language-bash">env PYTHON_CONFIGURE_OPTS="--enable-shared" pyenv install 3.12
</code></pre>
<p>You can read more about <code>pyenv</code>'s configuration options <a href="https://github.com/pyenv/pyenv/blob/master/plugins/python-build/README.md#building-with---enable-shared">here</a>.</p>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<p>There are a number of build and Python package management systems such as <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> or <a href="./building-and-distribution.html#manual-builds">manually</a>. We recommend the use of <code>maturin</code>, which you can install <a href="https://maturin.rs/installation.html">here</a>. It is developed to work with PyO3 and provides the most "batteries included" experience, especially if you are aiming to publish to PyPI. <code>maturin</code> is just a Python package, so you can add it in the same way you already install Python packages.</p>
<p>System Python:</p>
<pre><code class="language-bash">pip install maturin --user
</code></pre>
<p>pipx:</p>
<pre><code class="language-bash">pipx install maturin
</code></pre>
<p>pyenv:</p>
<pre><code class="language-bash">pyenv activate pyo3
pip install maturin
</code></pre>
<p>poetry:</p>
<pre><code class="language-bash">poetry add -G dev maturin
</code></pre>
<p>After installation, you can run <code>maturin --version</code> to check that you have correctly installed it.</p>
<h1 id="starting-a-new-project"><a class="header" href="#starting-a-new-project">Starting a new project</a></h1>
<p>First you should create the folder and virtual environment that are going to contain your new project. Here we will use the recommended <code>pyenv</code>:</p>
<pre><code class="language-bash">mkdir pyo3-example
cd pyo3-example
pyenv virtualenv pyo3
pyenv local pyo3
</code></pre>
<p>After this, you should install your build manager. In this example, we will use <code>maturin</code>. After you've activated your virtualenv, add <code>maturin</code> to it:</p>
<pre><code class="language-bash">pip install maturin
</code></pre>
<p>Now you can initialize the new project:</p>
<pre><code class="language-bash">maturin init
</code></pre>
<p>If <code>maturin</code> is already installed, you can create a new project using that directly as well:</p>
<pre><code class="language-bash">maturin new -b pyo3 pyo3-example
cd pyo3-example
pyenv virtualenv pyo3
pyenv local pyo3
</code></pre>
<h1 id="adding-to-an-existing-project"><a class="header" href="#adding-to-an-existing-project">Adding to an existing project</a></h1>
<p>Sadly, <code>maturin</code> cannot currently be run in existing projects, so if you want to use Python in an existing project you basically have two options:</p>
<ol>
<li>Create a new project as above and move your existing code into that project</li>
<li>Manually edit your project configuration as necessary</li>
</ol>
<p>If you opt for the second option, here are the things you need to pay attention to:</p>
<h2 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h2>
<p>Make sure that the Rust crate you want to be able to access from Python is compiled into a library. You can have a binary output as well, but the code you want to access from Python has to be in the library part. Also, make sure that the crate type is <code>cdylib</code> and add PyO3 as a dependency as so:</p>
<pre><code class="language-toml"># If you already have [package] information in `Cargo.toml`, you can ignore
# this section!
[package]
# `name` here is name of the package.
name = "pyo3_start"
# these are good defaults:
version = "0.1.0"
edition = "2021"

[lib]
# The name of the native library. This is the name which will be used in Python to import the
# library (i.e. `import string_sum`). If you change this, you must also change the name of the
# `#[pymodule]` in `src/lib.rs`.
name = "pyo3_example"

# "cdylib" is necessary to produce a shared library for Python to import from.
crate-type = ["cdylib"]

[dependencies]
pyo3 = { version = "0.21.2", features = ["extension-module"] }
</code></pre>
<h2 id="pyprojecttoml"><a class="header" href="#pyprojecttoml">pyproject.toml</a></h2>
<p>You should also create a <code>pyproject.toml</code> with the following contents:</p>
<pre><code class="language-toml">[build-system]
requires = ["maturin&gt;=1,&lt;2"]
build-backend = "maturin"

[project]
name = "pyo3_example"
requires-python = "&gt;=3.7"
classifiers = [
    "Programming Language :: Rust",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]
</code></pre>
<h2 id="running-code"><a class="header" href="#running-code">Running code</a></h2>
<p>After this you can setup Rust code to be available in Python as below; for example, you can place this code in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

/// Formats the sum of two numbers as string.
#[pyfunction]
fn sum_as_string(a: usize, b: usize) -&gt; PyResult&lt;String&gt; {
    Ok((a + b).to_string())
}

/// A Python module implemented in Rust. The name of this function must match
/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to
/// import the module.
#[pymodule]
fn pyo3_example(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;
    Ok(())
}</code></pre>
<p>Now you can run <code>maturin develop</code> to prepare the Python package, after which you can use it like so:</p>
<pre><code class="language-bash">$ maturin develop
# lots of progress output as maturin runs the compilation...
$ python
&gt;&gt;&gt; import pyo3_example
&gt;&gt;&gt; pyo3_example.sum_as_string(5, 20)
'25'
</code></pre>
<p>For more instructions on how to use Python code from Rust, see the <a href="python-from-rust.html">Python from Rust</a> page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-rust-from-python-1"><a class="header" href="#using-rust-from-python-1">Using Rust from Python</a></h1>
<p>This chapter of the guide is dedicated to explaining how to wrap Rust code into Python objects.</p>
<p>PyO3 uses Rust's "procedural macros" to provide a powerful yet simple API to denote what Rust code should map into Python objects.</p>
<p>The three types of Python objects which PyO3 can produce are:</p>
<ul>
<li>Python modules, via the <code>#[pymodule]</code> macro</li>
<li>Python functions, via the <code>#[pyfunction]</code> macro</li>
<li>Python classes, via the <code>#[pyclass]</code> macro (plus <code>#[pymethods]</code> to define methods for those clases)</li>
</ul>
<p>The following subchapters go through each of these in turn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-modules"><a class="header" href="#python-modules">Python modules</a></h1>
<p>You can create a module using <code>#[pymodule]</code>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

/// This module is implemented in Rust.
#[pymodule]
fn my_extension(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}</code></pre>
<p>The <code>#[pymodule]</code> procedural macro takes care of exporting the initialization function of your
module to Python.</p>
<p>The module's name defaults to the name of the Rust function. You can override the module name by
using <code>#[pyo3(name = "custom_name")]</code>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

#[pymodule]
#[pyo3(name = "custom_name")]
fn my_extension(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}</code></pre>
<p>The name of the module must match the name of the <code>.so</code> or <code>.pyd</code>
file. Otherwise, you will get an import error in Python with the following message:
<code>ImportError: dynamic module does not define module export function (PyInit_name_of_your_module)</code></p>
<p>To import the module, either:</p>
<ul>
<li>copy the shared library as described in <a href="building-and-distribution.html#manual-builds">Manual builds</a>, or</li>
<li>use a tool, e.g. <code>maturin develop</code> with <a href="https://github.com/PyO3/maturin">maturin</a> or
<code>python setup.py develop</code> with <a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a>.</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The <a href="https://doc.rust-lang.org/stable/book/ch03-04-comments.html">Rust doc comments</a> of the module
initialization function will be applied automatically as the Python docstring of your module.</p>
<p>For example, building off of the above code, this will print <code>This module is implemented in Rust.</code>:</p>
<pre><code class="language-python">import my_extension

print(my_extension.__doc__)
</code></pre>
<h2 id="python-submodules"><a class="header" href="#python-submodules">Python submodules</a></h2>
<p>You can create a module hierarchy within a single extension module by using
<a href="https://docs.rs/pyo3/0.21.2/pyo3/prelude/trait.PyModuleMethods.html#tymethod.add_submodule"><code>Bound&lt;'_, PyModule&gt;::add_submodule()</code></a>.
For example, you could define the modules <code>parent_module</code> and <code>parent_module.child_module</code>.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pymodule]
fn parent_module(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    register_child_module(m)?;
    Ok(())
}

fn register_child_module(parent_module: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    let child_module = PyModule::new_bound(parent_module.py(), "child_module")?;
    child_module.add_function(wrap_pyfunction!(func, &amp;child_module)?)?;
    parent_module.add_submodule(&amp;child_module)?;
    Ok(())
}

#[pyfunction]
fn func() -&gt; String {
    "func".to_string()
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">   use pyo3::wrap_pymodule;
</span><span class="boring">   use pyo3::types::IntoPyDict;
</span><span class="boring">   let parent_module = wrap_pymodule!(parent_module)(py);
</span><span class="boring">   let ctx = [("parent_module", parent_module)].into_py_dict_bound(py);
</span><span class="boring">
</span><span class="boring">   py.run_bound("assert parent_module.child_module.func() == 'func'", None, Some(&amp;ctx)).unwrap();
</span><span class="boring">})</span></code></pre>
<p>Note that this does not define a package, so this won’t allow Python code to directly import
submodules by using <code>from parent_module import child_module</code>. For more information, see
<a href="https://github.com/PyO3/pyo3/issues/759">#759</a> and
<a href="https://github.com/PyO3/pyo3/issues/1517#issuecomment-808664021">#1517</a>.</p>
<p>It is not necessary to add <code>#[pymodule]</code> on nested modules, which is only required on the top-level module.</p>
<h2 id="declarative-modules-experimental"><a class="header" href="#declarative-modules-experimental">Declarative modules (experimental)</a></h2>
<p>Another syntax based on Rust inline modules is also available to declare modules.
The <code>experimental-declarative-modules</code> feature must be enabled to use it.</p>
<p>For example:</p>
<pre><code class="language-rust"><span class="boring">#[cfg(feature = "experimental-declarative-modules")]
</span><span class="boring">mod declarative_module_test {
</span>use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

#[pymodule]
mod my_extension {
    use super::*;

    #[pymodule_export]
    use super::double; // Exports the double function as part of the module

    #[pyfunction] // This will be part of the module
    fn triple(x: usize) -&gt; usize {
        x * 3
    }

    #[pyclass] // This will be part of the module
    struct Unit;

    #[pymodule]
    mod submodule {
        // This is a submodule
    }

    #[pymodule_init]
    fn init(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
        // Arbitrary code to run at the module initialization
        m.add("double2", m.getattr("double")?)?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p>Some changes are planned to this feature before stabilization, like automatically
filling submodules into <code>sys.modules</code> to allow easier imports (see <a href="https://github.com/PyO3/pyo3/issues/759">issue #759</a>)
and filling the <code>module</code> argument of inlined <code>#[pyclass]</code> automatically with the proper module name.
Macro names might also change.
See <a href="https://github.com/PyO3/pyo3/issues/3900">issue #3900</a> to track this feature progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-functions"><a class="header" href="#python-functions">Python functions</a></h1>
<p>The <code>#[pyfunction]</code> attribute is used to define a Python function from a Rust function. Once defined, the function needs to be added to a <a href="./module.html">module</a> using the <code>wrap_pyfunction!</code> macro.</p>
<p>The following example defines a function called <code>double</code> in a Python module called <code>my_extension</code>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyfunction]
fn double(x: usize) -&gt; usize {
    x * 2
}

#[pymodule]
fn my_extension(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}</code></pre>
<p>This chapter of the guide explains full usage of the <code>#[pyfunction]</code> attribute. In this first section, the following topics are covered:</p>
<ul>
<li><a href="function.html#function-options">Function options</a>
<ul>
<li><a href="function.html#name"><code>#[pyo3(name = "...")]</code></a></li>
<li><a href="function.html#signature"><code>#[pyo3(signature = (...))]</code></a></li>
<li><a href="function.html#text_signature"><code>#[pyo3(text_signature = "...")]</code></a></li>
<li><a href="function.html#pass_module"><code>#[pyo3(pass_module)]</code></a></li>
</ul>
</li>
<li><a href="function.html#per-argument-options">Per-argument options</a></li>
<li><a href="function.html#advanced-function-patterns">Advanced function patterns</a></li>
<li><a href="function.html#pyfn-shorthand"><code>#[pyfn]</code> shorthand</a></li>
</ul>
<p>There are also additional sections on the following topics:</p>
<ul>
<li><a href="./function/signature.html">Function Signatures</a></li>
</ul>
<h2 id="function-options"><a class="header" href="#function-options">Function options</a></h2>
<p>The <code>#[pyo3]</code> attribute can be used to modify properties of the generated Python function. It can take any combination of the following options:</p>
<ul>
<li>
<p><a id="name"></a> <code>#[pyo3(name = "...")]</code></p>
<p>Overrides the name exposed to Python.</p>
<p>In the following example, the Rust function <code>no_args_py</code> will be added to the Python module
<code>module_with_functions</code> as the Python function <code>no_args</code>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyfunction]
#[pyo3(name = "no_args")]
fn no_args_py() -&gt; usize {
    42
}

#[pymodule]
fn module_with_functions(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(no_args_py, m)?)?;
    Ok(())
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let m = pyo3::wrap_pymodule!(module_with_functions)(py);
</span><span class="boring">    assert!(m.getattr(py, "no_args").is_ok());
</span><span class="boring">    assert!(m.getattr(py, "no_args_py").is_err());
</span><span class="boring">});</span></code></pre>
</li>
<li>
<p><a id="signature"></a> <code>#[pyo3(signature = (...))]</code></p>
<p>Defines the function signature in Python. See <a href="./function/signature.html">Function Signatures</a>.</p>
</li>
<li>
<p><a id="text_signature"></a> <code>#[pyo3(text_signature = "...")]</code></p>
<p>Overrides the PyO3-generated function signature visible in Python tooling (such as via <a href="https://docs.python.org/3/library/inspect.html#inspect.signature"><code>inspect.signature</code></a>). See the <a href="./function/signature.html#making-the-function-signature-available-to-python">corresponding topic in the Function Signatures subchapter</a>.</p>
</li>
<li>
<p><a id="pass_module" ></a> <code>#[pyo3(pass_module)]</code></p>
<p>Set this option to make PyO3 pass the containing module as the first argument to the function. It is then possible to use the module in the function body. The first argument <strong>must</strong> be of type <code>&amp;Bound&lt;'_, PyModule&gt;</code>, <code>Bound&lt;'_, PyModule&gt;</code>, or <code>Py&lt;PyModule&gt;</code>.</p>
<p>The following example creates a function <code>pyfunction_with_module</code> which returns the containing module's name (i.e. <code>module_with_fn</code>):</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyString;

#[pyfunction]
#[pyo3(pass_module)]
fn pyfunction_with_module&lt;'py&gt;(
    module: &amp;Bound&lt;'py, PyModule&gt;,
) -&gt; PyResult&lt;Bound&lt;'py, PyString&gt;&gt; {
    module.name()
}

#[pymodule]
fn module_with_fn(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(pyfunction_with_module, m)?)
}</code></pre>
</li>
</ul>
<h2 id="per-argument-options"><a class="header" href="#per-argument-options">Per-argument options</a></h2>
<p>The <code>#[pyo3]</code> attribute can be used on individual arguments to modify properties of them in the generated function. It can take any combination of the following options:</p>
<ul>
<li>
<p><a id="from_py_with"></a> <code>#[pyo3(from_py_with = "...")]</code></p>
<p>Set this on an option to specify a custom function to convert the function argument from Python to the desired Rust type, instead of using the default <code>FromPyObject</code> extraction. The function signature must be <code>fn(&amp;Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;T&gt;</code> where <code>T</code> is the Rust type of the argument.</p>
<p>The following example uses <code>from_py_with</code> to convert the input Python object to its length:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

fn get_length(obj: &amp;Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;usize&gt; {
    let length = obj.len()?;
    Ok(length)
}

#[pyfunction]
fn object_length(#[pyo3(from_py_with = "get_length")] argument: usize) -&gt; usize {
    argument
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let f = pyo3::wrap_pyfunction_bound!(object_length)(py).unwrap();
</span><span class="boring">    assert_eq!(f.call1((vec![1, 2, 3],)).unwrap().extract::&lt;usize&gt;().unwrap(), 3);
</span><span class="boring">});</span></code></pre>
</li>
</ul>
<h2 id="advanced-function-patterns"><a class="header" href="#advanced-function-patterns">Advanced function patterns</a></h2>
<h3 id="calling-python-functions-in-rust"><a class="header" href="#calling-python-functions-in-rust">Calling Python functions in Rust</a></h3>
<p>You can pass Python <code>def</code>'d functions and built-in functions to Rust functions <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyFunction.html"><code>PyFunction</code></a>
corresponds to regular Python functions while <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyCFunction.html"><code>PyCFunction</code></a> describes built-ins such as
<code>repr()</code>.</p>
<p>You can also use <a href="https://docs.rs/pyo3/0.21.2/pyo3/prelude/trait.PyAnyMethods.html#tymethod.is_callable"><code>Bound&lt;'_, PyAny&gt;::is_callable</code></a> to check if you have a callable object. <code>is_callable</code>
will return <code>true</code> for functions (including lambdas), methods and objects with a <code>__call__</code> method.
You can call the object with <a href="https://docs.rs/pyo3/0.21.2/pyo3/prelude/trait.PyAnyMethods.html#tymethod.call"><code>Bound&lt;'_, PyAny&gt;::call</code></a> with the args as first parameter and the kwargs
(or <code>None</code>) as second parameter. There are also <a href="https://docs.rs/pyo3/0.21.2/pyo3/prelude/trait.PyAnyMethods.html#tymethod.call0"><code>Bound&lt;'_, PyAny&gt;::call0</code></a> with no args and
<a href="https://docs.rs/pyo3/0.21.2/pyo3/prelude/trait.PyAnyMethods.html#tymethod.call1"><code>Bound&lt;'_, PyAny&gt;::call1</code></a> with only positional args.</p>
<h3 id="calling-rust-functions-in-python"><a class="header" href="#calling-rust-functions-in-python">Calling Rust functions in Python</a></h3>
<p>The ways to convert a Rust function into a Python object vary depending on the function:</p>
<ul>
<li>Named functions, e.g. <code>fn foo()</code>: add <code>#[pyfunction]</code> and then use <a href="https://docs.rs/pyo3/0.21.2/pyo3/macro.wrap_pyfunction.html"><code>wrap_pyfunction!</code></a> to get the corresponding <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyCFunction.html"><code>PyCFunction</code></a>.</li>
<li>Anonymous functions (or closures), e.g. <code>foo: fn()</code> either:
<ul>
<li>use a <code>#[pyclass]</code> struct which stores the function as a field and implement <code>__call__</code> to call the stored function.</li>
<li>use <code>PyCFunction::new_closure</code> to create an object directly from the function.</li>
</ul>
</li>
</ul>
<h3 id="accessing-the-ffi-functions"><a class="header" href="#accessing-the-ffi-functions">Accessing the FFI functions</a></h3>
<p>In order to make Rust functions callable from Python, PyO3 generates an <code>extern "C"</code>
function whose exact signature depends on the Rust signature.  (PyO3 chooses the optimal
Python argument passing convention.) It then embeds the call to the Rust function inside this
FFI-wrapper function. This wrapper handles extraction of the regular arguments and the keyword
arguments from the input <code>PyObject</code>s.</p>
<p>The <code>wrap_pyfunction</code> macro can be used to directly get a <code>Bound&lt;PyCFunction&gt;</code> given a
<code>#[pyfunction]</code> and a <code>Bound&lt;PyModule&gt;</code>: <code>wrap_pyfunction!(rust_fun, module)</code>.</p>
<h2 id="pyfn-shorthand"><a class="header" href="#pyfn-shorthand"><code>#[pyfn]</code> shorthand</a></h2>
<p>There is a shorthand to <code>#[pyfunction]</code> and <code>wrap_pymodule!</code>: the function can be placed inside the module definition and
annotated with <code>#[pyfn]</code>. To simplify PyO3, it is expected that <code>#[pyfn]</code> may be removed in a future release (See <a href="https://github.com/PyO3/pyo3/issues/694">#694</a>).</p>
<p>An example of <code>#[pyfn]</code> is below:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pymodule]
fn my_extension(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    #[pyfn(m)]
    fn double(x: usize) -&gt; usize {
        x * 2
    }

    Ok(())
}</code></pre>
<p><code>#[pyfn(m)]</code> is just syntactic sugar for <code>#[pyfunction]</code>, and takes all the same options
documented in the rest of this chapter. The code above is expanded to the following:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pymodule]
fn my_extension(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    #[pyfunction]
    fn double(x: usize) -&gt; usize {
        x * 2
    }

    m.add_function(wrap_pyfunction!(double, m)?)?;
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-signatures"><a class="header" href="#function-signatures">Function signatures</a></h1>
<p>The <code>#[pyfunction]</code> attribute also accepts parameters to control how the generated Python function accepts arguments. Just like in Python, arguments can be positional-only, keyword-only, or accept either. <code>*args</code> lists and <code>**kwargs</code> dicts can also be accepted. These parameters also work for <code>#[pymethods]</code> which will be introduced in the <a href="function/../class.html">Python Classes</a> section of the guide.</p>
<p>Like Python, by default PyO3 accepts all arguments as either positional or keyword arguments. Most arguments are required by default, except for trailing <code>Option&lt;_&gt;</code> arguments, which are <a href="function/signature.html#trailing-optional-arguments">implicitly given a default of <code>None</code></a>. This behaviour can be configured by the <code>#[pyo3(signature = (...))]</code> option which allows writing a signature in Python syntax.</p>
<p>This section of the guide goes into detail about use of the <code>#[pyo3(signature = (...))]</code> option and its related option <code>#[pyo3(text_signature = "...")]</code></p>
<h2 id="using-pyo3signature--"><a class="header" href="#using-pyo3signature--">Using <code>#[pyo3(signature = (...))]</code></a></h2>
<p>For example, below is a function that accepts arbitrary keyword arguments (<code>**kwargs</code> in Python syntax) and returns the number that was passed:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyDict;

#[pyfunction]
#[pyo3(signature = (**kwds))]
fn num_kwds(kwds: Option&lt;&amp;Bound&lt;'_, PyDict&gt;&gt;) -&gt; usize {
    kwds.map_or(0, |dict| dict.len())
}

#[pymodule]
fn module_with_functions(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(num_kwds, m)?).unwrap();
    Ok(())
}</code></pre>
<p>Just like in Python, the following constructs can be part of the signature::</p>
<ul>
<li><code>/</code>: positional-only arguments separator, each parameter defined before <code>/</code> is a positional-only parameter.</li>
<li><code>*</code>: var arguments separator, each parameter defined after <code>*</code> is a keyword-only parameter.</li>
<li><code>*args</code>: "args" is var args. Type of the <code>args</code> parameter has to be <code>&amp;Bound&lt;'_, PyTuple&gt;</code>.</li>
<li><code>**kwargs</code>: "kwargs" receives keyword arguments. The type of the <code>kwargs</code> parameter has to be <code>Option&lt;&amp;Bound&lt;'_, PyDict&gt;&gt;</code>.</li>
<li><code>arg=Value</code>: arguments with default value.
If the <code>arg</code> argument is defined after var arguments, it is treated as a keyword-only argument.
Note that <code>Value</code> has to be valid rust code, PyO3 just inserts it into the generated
code unmodified.</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::{PyDict, PyTuple};
<span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[new]
    #[pyo3(signature = (num=-1))]
    fn new(num: i32) -&gt; Self {
        MyClass { num }
    }

    #[pyo3(signature = (num=10, *py_args, name="Hello", **py_kwargs))]
    fn method(
        &amp;mut self,
        num: i32,
        py_args: &amp;Bound&lt;'_, PyTuple&gt;,
        name: &amp;str,
        py_kwargs: Option&lt;&amp;Bound&lt;'_, PyDict&gt;&gt;,
    ) -&gt; String {
        let num_before = self.num;
        self.num = num;
        format!(
            "num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} ",
            num, num_before, py_args, name, py_kwargs,
        )
    }

    fn make_change(&amp;mut self, num: i32) -&gt; PyResult&lt;String&gt; {
        self.num = num;
        Ok(format!("num={}", self.num))
    }
}</code></pre>
<p>Arguments of type <code>Python</code> must not be part of the signature:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyfunction]
#[pyo3(signature = (lambda))]
pub fn simple_python_bound_function(py: Python&lt;'_&gt;, lambda: PyObject) -&gt; PyResult&lt;()&gt; {
    Ok(())
}</code></pre>
<p>N.B. the position of the <code>/</code> and <code>*</code> arguments (if included) control the system of handling positional and keyword arguments. In Python:</p>
<pre><code class="language-python">import mymodule

mc = mymodule.MyClass()
print(mc.method(44, False, "World", 666, x=44, y=55))
print(mc.method(num=-1, name="World"))
print(mc.make_change(44, False))
</code></pre>
<p>Produces output:</p>
<pre><code class="language-text">py_args=('World', 666), py_kwargs=Some({'x': 44, 'y': 55}), name=Hello, num=44
py_args=(), py_kwargs=None, name=World, num=-1
num=44
num=-1
</code></pre>
<blockquote>
<p>Note: to use keywords like <code>struct</code> as a function argument, use "raw identifier" syntax <code>r#struct</code> in both the signature and the function definition:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyfunction(signature = (r#struct = "foo"))]
fn function_with_keyword(r#struct: &amp;str) {
<span class="boring">    let _ = r#struct;
</span>    /* ... */
}</code></pre>
</blockquote>
<h2 id="trailing-optional-arguments"><a class="header" href="#trailing-optional-arguments">Trailing optional arguments</a></h2>
<p>As a convenience, functions without a <code>#[pyo3(signature = (...))]</code> option will treat trailing <code>Option&lt;T&gt;</code> arguments as having a default of <code>None</code>. In the example below, PyO3 will create <code>increment</code> with a signature of <code>increment(x, amount=None)</code>.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

/// Returns a copy of `x` increased by `amount`.
///
/// If `amount` is unspecified or `None`, equivalent to `x + 1`.
#[pyfunction]
fn increment(x: u64, amount: Option&lt;u64&gt;) -&gt; u64 {
    x + amount.unwrap_or(1)
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let fun = pyo3::wrap_pyfunction_bound!(increment, py)?;
</span><span class="boring">
</span><span class="boring">        let inspect = PyModule::import_bound(py, "inspect")?.getattr("signature")?;
</span><span class="boring">        let sig: String = inspect
</span><span class="boring">            .call1((fun,))?
</span><span class="boring">            .call_method0("__str__")?
</span><span class="boring">            .extract()?;
</span><span class="boring">
</span><span class="boring">        #[cfg(Py_3_8)]  // on 3.7 the signature doesn't render b, upstream bug?
</span><span class="boring">        assert_eq!(sig, "(x, amount=None)");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>To make trailing <code>Option&lt;T&gt;</code> arguments required, but still accept <code>None</code>, add a <code>#[pyo3(signature = (...))]</code> annotation. For the example above, this would be <code>#[pyo3(signature = (x, amount))]</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyfunction]
#[pyo3(signature = (x, amount))]
fn increment(x: u64, amount: Option&lt;u64&gt;) -&gt; u64 {
    x + amount.unwrap_or(1)
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let fun = pyo3::wrap_pyfunction_bound!(increment, py)?;
</span><span class="boring">
</span><span class="boring">        let inspect = PyModule::import_bound(py, "inspect")?.getattr("signature")?;
</span><span class="boring">        let sig: String = inspect
</span><span class="boring">            .call1((fun,))?
</span><span class="boring">            .call_method0("__str__")?
</span><span class="boring">            .extract()?;
</span><span class="boring">
</span><span class="boring">        #[cfg(Py_3_8)]  // on 3.7 the signature doesn't render b, upstream bug?
</span><span class="boring">        assert_eq!(sig, "(x, amount)");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>To help avoid confusion, PyO3 requires <code>#[pyo3(signature = (...))]</code> when an <code>Option&lt;T&gt;</code> argument is surrounded by arguments which aren't <code>Option&lt;T&gt;</code>.</p>
<h2 id="making-the-function-signature-available-to-python"><a class="header" href="#making-the-function-signature-available-to-python">Making the function signature available to Python</a></h2>
<p>The function signature is exposed to Python via the <code>__text_signature__</code> attribute. PyO3 automatically generates this for every <code>#[pyfunction]</code> and all <code>#[pymethods]</code> directly from the Rust function, taking into account any override done with the <code>#[pyo3(signature = (...))]</code> option.</p>
<p>This automatic generation can only display the value of default arguments for strings, integers, boolean types, and <code>None</code>. Any other default arguments will be displayed as <code>...</code>. (<code>.pyi</code> type stub files commonly also use <code>...</code> for default arguments in the same way.)</p>
<p>In cases where the automatically-generated signature needs adjusting, it can <a href="function/signature.html#overriding-the-generated-signature">be overridden</a> using the <code>#[pyo3(text_signature)]</code> option.)</p>
<p>The example below creates a function <code>add</code> which accepts two positional-only arguments <code>a</code> and <code>b</code>, where <code>b</code> has a default value of zero.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

/// This function adds two unsigned 64-bit integers.
#[pyfunction]
#[pyo3(signature = (a, b=0, /))]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let fun = pyo3::wrap_pyfunction_bound!(add, py)?;
</span><span class="boring">
</span><span class="boring">        let doc: String = fun.getattr("__doc__")?.extract()?;
</span><span class="boring">        assert_eq!(doc, "This function adds two unsigned 64-bit integers.");
</span><span class="boring">
</span><span class="boring">        let inspect = PyModule::import_bound(py, "inspect")?.getattr("signature")?;
</span><span class="boring">        let sig: String = inspect
</span><span class="boring">            .call1((fun,))?
</span><span class="boring">            .call_method0("__str__")?
</span><span class="boring">            .extract()?;
</span><span class="boring">
</span><span class="boring">        #[cfg(Py_3_8)]  // on 3.7 the signature doesn't render b, upstream bug?
</span><span class="boring">        assert_eq!(sig, "(a, b=0, /)");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>The following IPython output demonstrates how this generated signature will be seen from Python tooling:</p>
<pre><code class="language-text">&gt;&gt;&gt; pyo3_test.add.__text_signature__
'(a, b=..., /)'
&gt;&gt;&gt; pyo3_test.add?
Signature: pyo3_test.add(a, b=0, /)
Docstring: This function adds two unsigned 64-bit integers.
Type:      builtin_function_or_method
</code></pre>
<h3 id="overriding-the-generated-signature"><a class="header" href="#overriding-the-generated-signature">Overriding the generated signature</a></h3>
<p>The <code>#[pyo3(text_signature = "(&lt;some signature&gt;)")]</code> attribute can be used to override the default generated signature.</p>
<p>In the snippet below, the text signature attribute is used to include the default value of <code>0</code> for the argument <code>b</code>, instead of the automatically-generated default value of <code>...</code>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

/// This function adds two unsigned 64-bit integers.
#[pyfunction]
#[pyo3(signature = (a, b=0, /), text_signature = "(a, b=0, /)")]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let fun = pyo3::wrap_pyfunction_bound!(add, py)?;
</span><span class="boring">
</span><span class="boring">        let doc: String = fun.getattr("__doc__")?.extract()?;
</span><span class="boring">        assert_eq!(doc, "This function adds two unsigned 64-bit integers.");
</span><span class="boring">
</span><span class="boring">        let inspect = PyModule::import_bound(py, "inspect")?.getattr("signature")?;
</span><span class="boring">        let sig: String = inspect
</span><span class="boring">            .call1((fun,))?
</span><span class="boring">            .call_method0("__str__")?
</span><span class="boring">            .extract()?;
</span><span class="boring">        assert_eq!(sig, "(a, b=0, /)");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>PyO3 will include the contents of the annotation unmodified as the <code>__text_signature__</code>. Below shows how IPython will now present this (see the default value of 0 for b):</p>
<pre><code class="language-text">&gt;&gt;&gt; pyo3_test.add.__text_signature__
'(a, b=0, /)'
&gt;&gt;&gt; pyo3_test.add?
Signature: pyo3_test.add(a, b=0, /)
Docstring: This function adds two unsigned 64-bit integers.
Type:      builtin_function_or_method
</code></pre>
<p>If no signature is wanted at all, <code>#[pyo3(text_signature = None)]</code> will disable the built-in signature. The snippet below demonstrates use of this:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

/// This function adds two unsigned 64-bit integers.
#[pyfunction]
#[pyo3(signature = (a, b=0, /), text_signature = None)]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let fun = pyo3::wrap_pyfunction_bound!(add, py)?;
</span><span class="boring">
</span><span class="boring">        let doc: String = fun.getattr("__doc__")?.extract()?;
</span><span class="boring">        assert_eq!(doc, "This function adds two unsigned 64-bit integers.");
</span><span class="boring">        assert!(fun.getattr("__text_signature__")?.is_none());
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>Now the function's <code>__text_signature__</code> will be set to <code>None</code>, and IPython will not display any signature in the help:</p>
<pre><code class="language-text">&gt;&gt;&gt; pyo3_test.add.__text_signature__ == None
True
&gt;&gt;&gt; pyo3_test.add?
Docstring: This function adds two unsigned 64-bit integers.
Type:      builtin_function_or_method
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>This chapter contains a little background of error handling in Rust and how PyO3 integrates this with Python exceptions.</p>
<p>This covers enough detail to create a <code>#[pyfunction]</code> which raises Python exceptions from errors originating in Rust.</p>
<p>There is a later section of the guide on <a href="function/../exception.html">Python exceptions</a> which covers exception types in more detail.</p>
<h2 id="representing-python-exceptions"><a class="header" href="#representing-python-exceptions">Representing Python exceptions</a></h2>
<p>Rust code uses the generic <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a> enum to propagate errors. The error type <code>E</code> is chosen by the code author to describe the possible errors which can happen.</p>
<p>PyO3 has the <a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.PyErr.html"><code>PyErr</code></a> type which represents a Python exception. If a PyO3 API could result in a Python exception being raised, the return type of that <code>API</code> will be <a href="https://docs.rs/pyo3/0.21.2/pyo3/prelude/type.PyResult.html"><code>PyResult&lt;T&gt;</code></a>, which is an alias for the type <code>Result&lt;T, PyErr&gt;</code>.</p>
<p>In summary:</p>
<ul>
<li>When Python exceptions are raised and caught by PyO3, the exception will be stored in the <code>Err</code> variant of the <code>PyResult</code>.</li>
<li>Passing Python exceptions through Rust code then uses all the "normal" techniques such as the <code>?</code> operator, with <code>PyErr</code> as the error type.</li>
<li>Finally, when a <code>PyResult</code> crosses from Rust back to Python via PyO3, if the result is an <code>Err</code> variant the contained exception will be raised.</li>
</ul>
<p>(There are many great tutorials on Rust error handling and the <code>?</code> operator, so this guide will not go into detail on Rust-specific topics.)</p>
<h2 id="raising-an-exception-from-a-function"><a class="header" href="#raising-an-exception-from-a-function">Raising an exception from a function</a></h2>
<p>As indicated in the previous section, when a <code>PyResult</code> containing an <code>Err</code> crosses from Rust to Python, PyO3 will raise the exception contained within.</p>
<p>Accordingly, to raise an exception from a <code>#[pyfunction]</code>, change the return type <code>T</code> to <code>PyResult&lt;T&gt;</code>. When the function returns an <code>Err</code> it will raise a Python exception. (Other <code>Result&lt;T, E&gt;</code> types can be used as long as the error <code>E</code> has a <code>From</code> conversion for <code>PyErr</code>, see <a href="function/error-handling.html#custom-rust-error-types">custom Rust error types</a> below.)</p>
<p>This also works for functions in <code>#[pymethods]</code>.</p>
<p>For example, the following <code>check_positive</code> function raises a <code>ValueError</code> when the input is negative:</p>
<pre><code class="language-rust">use pyo3::exceptions::PyValueError;
use pyo3::prelude::*;

#[pyfunction]
fn check_positive(x: i32) -&gt; PyResult&lt;()&gt; {
    if x &lt; 0 {
        Err(PyValueError::new_err("x is negative"))
    } else {
        Ok(())
    }
}
<span class="boring">
</span><span class="boring">fn main(){
</span><span class="boring">	Python::with_gil(|py|{
</span><span class="boring">		let fun = pyo3::wrap_pyfunction_bound!(check_positive, py).unwrap();
</span><span class="boring">		fun.call1((-1,)).unwrap_err();
</span><span class="boring">		fun.call1((1,)).unwrap();
</span><span class="boring">	});
</span><span class="boring">}</span></code></pre>
<p>All built-in Python exception types are defined in the <a href="https://docs.rs/pyo3/0.21.2/pyo3/exceptions/index.html"><code>pyo3::exceptions</code></a> module. They have a <code>new_err</code> constructor to directly build a <code>PyErr</code>, as seen in the example above.</p>
<h2 id="custom-rust-error-types"><a class="header" href="#custom-rust-error-types">Custom Rust error types</a></h2>
<p>PyO3 will automatically convert a <code>Result&lt;T, E&gt;</code> returned by a <code>#[pyfunction]</code> into a <code>PyResult&lt;T&gt;</code> as long as there is an implementation of <code>std::from::From&lt;E&gt; for PyErr</code>. Many error types in the Rust standard library have a <a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html"><code>From</code></a> conversion defined in this way.</p>
<p>If the type <code>E</code> you are handling is defined in a third-party crate, see the section on <a href="function/error-handling.html#foreign-rust-error-types">foreign rust error types</a> below for ways to work with this error.</p>
<p>The following example makes use of the implementation of <code>From&lt;ParseIntError&gt; for PyErr</code> to raise exceptions encountered when parsing strings as integers:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>use std::num::ParseIntError;

#[pyfunction]
fn parse_int(x: &amp;str) -&gt; Result&lt;usize, ParseIntError&gt; {
    x.parse()
}

<span class="boring">fn main() {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let fun = pyo3::wrap_pyfunction_bound!(parse_int, py).unwrap();
</span><span class="boring">        let value: usize = fun.call1(("5",)).unwrap().extract().unwrap();
</span><span class="boring">        assert_eq!(value, 5);
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<p>When passed a string which doesn't contain a floating-point number, the exception raised will look like the below:</p>
<pre><code class="language-python">&gt;&gt;&gt; parse_int("bar")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: invalid digit found in string
</code></pre>
<p>As a more complete example, the following snippet defines a Rust error named <code>CustomIOError</code>. It then defines a <code>From&lt;CustomIOError&gt; for PyErr</code>, which returns a <code>PyErr</code> representing Python's <code>OSError</code>.
Therefore, it can use this error in the result of a <code>#[pyfunction]</code> directly, relying on the conversion if it has to be propagated into a Python exception.</p>
<pre><code class="language-rust">use pyo3::exceptions::PyOSError;
use pyo3::prelude::*;
use std::fmt;

#[derive(Debug)]
struct CustomIOError;

impl std::error::Error for CustomIOError {}

impl fmt::Display for CustomIOError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "Oh no!")
    }
}

impl std::convert::From&lt;CustomIOError&gt; for PyErr {
    fn from(err: CustomIOError) -&gt; PyErr {
        PyOSError::new_err(err.to_string())
    }
}

pub struct Connection {/* ... */}

fn bind(addr: String) -&gt; Result&lt;Connection, CustomIOError&gt; {
    if &amp;addr == "0.0.0.0" {
        Err(CustomIOError)
    } else {
        Ok(Connection{ /* ... */})
    }
}

#[pyfunction]
fn connect(s: String) -&gt; Result&lt;(), CustomIOError&gt; {
    bind(s)?;
    // etc.
    Ok(())
}

fn main() {
    Python::with_gil(|py| {
        let fun = pyo3::wrap_pyfunction_bound!(connect, py).unwrap();
        let err = fun.call1(("0.0.0.0",)).unwrap_err();
        assert!(err.is_instance_of::&lt;PyOSError&gt;(py));
    });
}</code></pre>
<p>If lazy construction of the Python exception instance is desired, the
<a href="https://docs.rs/pyo3/0.21.2/pyo3/trait.PyErrArguments.html"><code>PyErrArguments</code></a>
trait can be implemented instead of <code>From</code>. In that case, actual exception argument creation is delayed
until the <code>PyErr</code> is needed.</p>
<p>A final note is that any errors <code>E</code> which have a <code>From</code> conversion can be used with the <code>?</code>
("try") operator with them. An alternative implementation of the above <code>parse_int</code> which instead returns <code>PyResult</code> is below:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

fn parse_int(s: String) -&gt; PyResult&lt;usize&gt; {
    let x = s.parse()?;
    Ok(x)
}
<span class="boring">
</span><span class="boring">use pyo3::exceptions::PyValueError;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        assert_eq!(parse_int(String::from("1")).unwrap(), 1);
</span><span class="boring">        assert_eq!(parse_int(String::from("1337")).unwrap(), 1337);
</span><span class="boring">
</span><span class="boring">        assert!(parse_int(String::from("-1"))
</span><span class="boring">            .unwrap_err()
</span><span class="boring">            .is_instance_of::&lt;PyValueError&gt;(py));
</span><span class="boring">        assert!(parse_int(String::from("foo"))
</span><span class="boring">            .unwrap_err()
</span><span class="boring">            .is_instance_of::&lt;PyValueError&gt;(py));
</span><span class="boring">        assert!(parse_int(String::from("13.37"))
</span><span class="boring">            .unwrap_err()
</span><span class="boring">            .is_instance_of::&lt;PyValueError&gt;(py));
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h2 id="foreign-rust-error-types"><a class="header" href="#foreign-rust-error-types">Foreign Rust error types</a></h2>
<p>The Rust compiler will not permit implementation of traits for types outside of the crate where the type is defined. (This is known as the "orphan rule".)</p>
<p>Given a type <code>OtherError</code> which is defined in third-party code, there are two main strategies available to integrate it with PyO3:</p>
<ul>
<li>Create a newtype wrapper, e.g. <code>MyOtherError</code>. Then implement <code>From&lt;MyOtherError&gt; for PyErr</code> (or <code>PyErrArguments</code>), as well as <code>From&lt;OtherError&gt;</code> for <code>MyOtherError</code>.</li>
<li>Use Rust's Result combinators such as <code>map_err</code> to write code freely to convert <code>OtherError</code> into whatever is needed. This requires boilerplate at every usage however gives unlimited flexibility.</li>
</ul>
<p>To detail the newtype strategy a little further, the key trick is to return <code>Result&lt;T, MyOtherError&gt;</code> from the <code>#[pyfunction]</code>. This means that PyO3 will make use of <code>From&lt;MyOtherError&gt; for PyErr</code> to create Python exceptions while the <code>#[pyfunction]</code> implementation can use <code>?</code> to convert <code>OtherError</code> to <code>MyOtherError</code> automatically.</p>
<p>The following example demonstrates this for some imaginary third-party crate <code>some_crate</code> with a function <code>get_x</code> returning <code>Result&lt;i32, OtherError&gt;</code>:</p>
<pre><code class="language-rust"><span class="boring">mod some_crate {
</span><span class="boring">  pub struct OtherError(());
</span><span class="boring">  impl OtherError {
</span><span class="boring">      pub fn message(&amp;self) -&gt; &amp;'static str { "some error occurred" }
</span><span class="boring">  }
</span><span class="boring">  pub fn get_x() -&gt; Result&lt;i32, OtherError&gt; { Ok(5) }
</span><span class="boring">}
</span>
use pyo3::prelude::*;
use pyo3::exceptions::PyValueError;
use some_crate::{OtherError, get_x};

struct MyOtherError(OtherError);

impl From&lt;MyOtherError&gt; for PyErr {
    fn from(error: MyOtherError) -&gt; Self {
        PyValueError::new_err(error.0.message())
    }
}

impl From&lt;OtherError&gt; for MyOtherError {
    fn from(other: OtherError) -&gt; Self {
        Self(other)
    }
}

#[pyfunction]
fn wrapped_get_x() -&gt; Result&lt;i32, MyOtherError&gt; {
    // get_x is a function returning Result&lt;i32, OtherError&gt;
    let x: i32 = get_x()?;
    Ok(x)
}

<span class="boring">fn main() {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let fun = pyo3::wrap_pyfunction_bound!(wrapped_get_x, py).unwrap();
</span><span class="boring">        let value: usize = fun.call0().unwrap().extract().unwrap();
</span><span class="boring">        assert_eq!(value, 5);
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-classes"><a class="header" href="#python-classes">Python classes</a></h1>
<p>PyO3 exposes a group of attributes powered by Rust's proc macro system for defining Python classes as Rust structs.</p>
<p>The main attribute is <code>#[pyclass]</code>, which is placed upon a Rust <code>struct</code> or <code>enum</code> to generate a Python type for it. They will usually also have <em>one</em> <code>#[pymethods]</code>-annotated <code>impl</code> block for the struct, which is used to define Python methods and constants for the generated Python type. (If the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature is enabled, each <code>#[pyclass]</code> is allowed to have multiple <code>#[pymethods]</code> blocks.) <code>#[pymethods]</code> may also have implementations for Python magic methods such as <code>__str__</code>.</p>
<p>This chapter will discuss the functionality and configuration these attributes offer. Below is a list of links to the relevant section of this chapter for each:</p>
<ul>
<li><a href="class.html#defining-a-new-class"><code>#[pyclass]</code></a>
<ul>
<li><a href="class.html#object-properties-using-pyo3get-set"><code>#[pyo3(get, set)]</code></a></li>
</ul>
</li>
<li><a href="class.html#instance-methods"><code>#[pymethods]</code></a>
<ul>
<li><a href="class.html#constructor"><code>#[new]</code></a></li>
<li><a href="class.html#object-properties-using-getter-and-setter"><code>#[getter]</code></a></li>
<li><a href="class.html#object-properties-using-getter-and-setter"><code>#[setter]</code></a></li>
<li><a href="class.html#static-methods"><code>#[staticmethod]</code></a></li>
<li><a href="class.html#class-methods"><code>#[classmethod]</code></a></li>
<li><a href="class.html#class-attributes"><code>#[classattr]</code></a></li>
<li><a href="class.html#method-arguments"><code>#[args]</code></a></li>
</ul>
</li>
<li><a href="class/protocols.html">Magic methods and slots</a></li>
<li><a href="class.html#classes-as-function-arguments">Classes as function arguments</a></li>
</ul>
<h2 id="defining-a-new-class"><a class="header" href="#defining-a-new-class">Defining a new class</a></h2>
<p>To define a custom Python class, add the <code>#[pyclass]</code> attribute to a Rust struct or enum.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

#[pyclass]
struct MyClass {
    inner: i32,
}

// A "tuple" struct
#[pyclass]
struct Number(i32);

// PyO3 supports unit-only enums (which contain only unit variants)
// These simple enums behave similarly to Python's enumerations (enum.Enum)
#[pyclass]
enum MyEnum {
    Variant,
    OtherVariant = 30, // PyO3 supports custom discriminants.
}

// PyO3 supports custom discriminants in unit-only enums
#[pyclass]
enum HttpResponse {
    Ok = 200,
    NotFound = 404,
    Teapot = 418,
    // ...
}

// PyO3 also supports enums with non-unit variants
// These complex enums have sligtly different behavior from the simple enums above
// They are meant to work with instance checks and match statement patterns
#[pyclass]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
    RegularPolygon { side_count: u32, radius: f64 },
    Nothing {},
}</code></pre>
<p>The above example generates implementations for <a href="https://docs.rs/pyo3/0.21.2/pyo3/type_object/trait.PyTypeInfo.html"><code>PyTypeInfo</code></a> and <a href="https://docs.rs/pyo3/0.21.2/pyo3/pyclass/trait.PyClass.html"><code>PyClass</code></a> for <code>MyClass</code>, <code>Number</code>, <code>MyEnum</code>, <code>HttpResponse</code>, and <code>Shape</code>. To see these generated implementations, refer to the <a href="class.html#implementation-details">implementation details</a> at the end of this chapter.</p>
<h3 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h3>
<p>To integrate Rust types with Python, PyO3 needs to place some restrictions on the types which can be annotated with <code>#[pyclass]</code>. In particular, they must have no lifetime parameters, no generic parameters, and must implement <code>Send</code>. The reason for each of these is explained below.</p>
<h4 id="no-lifetime-parameters"><a class="header" href="#no-lifetime-parameters">No lifetime parameters</a></h4>
<p>Rust lifetimes are used by the Rust compiler to reason about a program's memory safety. They are a compile-time only concept; there is no way to access Rust lifetimes at runtime from a dynamic language like Python.</p>
<p>As soon as Rust data is exposed to Python, there is no guarantee that the Rust compiler can make on how long the data will live. Python is a reference-counted language and those references can be held for an arbitrarily long time which is untraceable by the Rust compiler. The only possible way to express this correctly is to require that any <code>#[pyclass]</code> does not borrow data for any lifetime shorter than the <code>'static</code> lifetime, i.e. the <code>#[pyclass]</code> cannot have any lifetime parameters.</p>
<p>When you need to share ownership of data between Python and Rust, instead of using borrowed references with lifetimes consider using reference-counted smart pointers such as <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> or <a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.Py.html"><code>Py</code></a>.</p>
<h4 id="no-generic-parameters"><a class="header" href="#no-generic-parameters">No generic parameters</a></h4>
<p>A Rust <code>struct Foo&lt;T&gt;</code> with a generic parameter <code>T</code> generates new compiled implementations each time it is used with a different concrete type for <code>T</code>. These new implementations are generated by the compiler at each usage site. This is incompatible with wrapping <code>Foo</code> in Python, where there needs to be a single compiled implementation of <code>Foo</code> which is integrated with the Python interpreter.</p>
<p>Currently, the best alternative is to write a macro which expands to a new <code>#[pyclass]</code> for each instantiation you want:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

struct GenericClass&lt;T&gt; {
    data: T,
}

macro_rules! create_interface {
    ($name: ident, $type: ident) =&gt; {
        #[pyclass]
        pub struct $name {
            inner: GenericClass&lt;$type&gt;,
        }
        #[pymethods]
        impl $name {
            #[new]
            pub fn new(data: $type) -&gt; Self {
                Self {
                    inner: GenericClass { data: data },
                }
            }
        }
    };
}

create_interface!(IntClass, i64);
create_interface!(FloatClass, String);</code></pre>
<h4 id="must-be-send"><a class="header" href="#must-be-send">Must be Send</a></h4>
<p>Because Python objects are freely shared between threads by the Python interpreter, there is no guarantee which thread will eventually drop the object. Therefore all types annotated with <code>#[pyclass]</code> must implement <code>Send</code> (unless annotated with <a href="class.html#customizing-the-class"><code>#[pyclass(unsendable)]</code></a>).</p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>By default, it is not possible to create an instance of a custom class from Python code.
To declare a constructor, you need to define a method and annotate it with the <code>#[new]</code>
attribute. Only Python's <code>__new__</code> method can be specified, <code>__init__</code> is not available.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -&gt; Self {
        Number(value)
    }
}</code></pre>
<p>Alternatively, if your <code>new</code> method may fail you can return <code>PyResult&lt;Self&gt;</code>.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::exceptions::PyValueError;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Nonzero(i32);
</span><span class="boring">
</span>#[pymethods]
impl Nonzero {
    #[new]
    fn py_new(value: i32) -&gt; PyResult&lt;Self&gt; {
        if value == 0 {
            Err(PyValueError::new_err("cannot be zero"))
        } else {
            Ok(Nonzero(value))
        }
    }
}</code></pre>
<p>If you want to return an existing object (for example, because your <code>new</code>
method caches the values it returns), <code>new</code> can return <code>pyo3::Py&lt;Self&gt;</code>.</p>
<p>As you can see, the Rust method name is not important here; this way you can
still, use <code>new()</code> for a Rust-level constructor.</p>
<p>If no method marked with <code>#[new]</code> is declared, object instances can only be
created from Rust, but not from Python.</p>
<p>For arguments, see the <a href="class.html#method-arguments"><code>Method arguments</code></a> section below.</p>
<h2 id="adding-the-class-to-a-module"><a class="header" href="#adding-the-class-to-a-module">Adding the class to a module</a></h2>
<p>The next step is to create the module initializer and add our class to it:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymodule]
fn my_module(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Number&gt;()?;
    Ok(())
}</code></pre>
<h2 id="bound-and-interior-mutability"><a class="header" href="#bound-and-interior-mutability">Bound<T> and interior mutability</a></h2>
<p>Often is useful to turn a <code>#[pyclass]</code> type <code>T</code> into a Python object and access it from Rust code. The [<code>Py&lt;T&gt;</code>] and [<code>Bound&lt;'py, T&gt;</code>] smart pointers are the ways to represent a Python object in PyO3's API. More detail can be found about them <a href="./types.html#pyo3s-smart-pointers">in the Python objects</a> section of the guide.</p>
<p>Most Python objects do not offer exclusive (<code>&amp;mut</code>) access (see the <a href="./python-from-rust.html#pythons-memory-model">section on Python's memory model</a>). However, Rust structs wrapped as Python objects (called <code>pyclass</code> types) often <em>do</em> need <code>&amp;mut</code> access. Due to the GIL, PyO3 <em>can</em> guarantee exclusive access to them.</p>
<p>The Rust borrow checker cannot reason about <code>&amp;mut</code> references once an object's ownership has been passed to the Python interpreter. This means that borrow checking is done at runtime using with a scheme very similar to <code>std::cell::RefCell&lt;T&gt;</code>. This is known as <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a>.</p>
<p>Users who are familiar with <code>RefCell&lt;T&gt;</code> can use <code>Py&lt;T&gt;</code> and <code>Bound&lt;'py, T&gt;</code> just like <code>RefCell&lt;T&gt;</code>.</p>
<p>For users who are not very familiar with <code>RefCell&lt;T&gt;</code>, here is a reminder of Rust's rules of borrowing:</p>
<ul>
<li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</li>
<li>References can never outlast the data they refer to.</li>
</ul>
<p><code>Py&lt;T&gt;</code> and <code>Bound&lt;'py, T&gt;</code>, like <code>RefCell&lt;T&gt;</code>, ensure these borrowing rules by tracking references at runtime.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get)]
    num: i32,
}
Python::with_gil(|py| {
    let obj = Bound::new(py, MyClass { num: 3 }).unwrap();
    {
        let obj_ref = obj.borrow(); // Get PyRef
        assert_eq!(obj_ref.num, 3);
        // You cannot get PyRefMut unless all PyRefs are dropped
        assert!(obj.try_borrow_mut().is_err());
    }
    {
        let mut obj_mut = obj.borrow_mut(); // Get PyRefMut
        obj_mut.num = 5;
        // You cannot get any other refs until the PyRefMut is dropped
        assert!(obj.try_borrow().is_err());
        assert!(obj.try_borrow_mut().is_err());
    }

    // You can convert `Bound` to a Python object
    pyo3::py_run!(py, obj, "assert obj.num == 5");
});</code></pre>
<p>A <code>Bound&lt;'py, T&gt;</code> is restricted to the GIL lifetime <code>'py</code>. To make the object longer lived (for example, to store it in a struct on the
Rust side), use <code>Py&lt;T&gt;</code>. <code>Py&lt;T&gt;</code> needs a <code>Python&lt;'_&gt;</code> token to allow access:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

fn return_myclass() -&gt; Py&lt;MyClass&gt; {
    Python::with_gil(|py| Py::new(py, MyClass { num: 1 }).unwrap())
}

let obj = return_myclass();

Python::with_gil(|py| {
    let bound = obj.bind(py); // Py&lt;MyClass&gt;::bind returns &amp;Bound&lt;'py, MyClass&gt;
    let obj_ref = bound.borrow(); // Get PyRef&lt;T&gt;
    assert_eq!(obj_ref.num, 1);
});</code></pre>
<h3 id="frozen-classes-opting-out-of-interior-mutability"><a class="header" href="#frozen-classes-opting-out-of-interior-mutability">frozen classes: Opting out of interior mutability</a></h3>
<p>As detailed above, runtime borrow checking is currently enabled by default. But a class can opt of out it by declaring itself <code>frozen</code>. It can still use interior mutability via standard Rust types like <code>RefCell</code> or <code>Mutex</code>, but it is not bound to the implementation provided by PyO3 and can choose the most appropriate strategy on field-by-field basis.</p>
<p>Classes which are <code>frozen</code> and also <code>Sync</code>, e.g. they do use <code>Mutex</code> but not <code>RefCell</code>, can be accessed without needing the Python GIL via the <code>Bound::get</code> and <code>Py::get</code> methods:</p>
<pre><code class="language-rust">use std::sync::atomic::{AtomicUsize, Ordering};
<span class="boring">use pyo3::prelude::*;
</span>
#[pyclass(frozen)]
struct FrozenCounter {
    value: AtomicUsize,
}

let py_counter: Py&lt;FrozenCounter&gt; = Python::with_gil(|py| {
    let counter = FrozenCounter {
        value: AtomicUsize::new(0),
    };

    Py::new(py, counter).unwrap()
});

py_counter.get().value.fetch_add(1, Ordering::Relaxed);</code></pre>
<p>Frozen classes are likely to become the default thereby guiding the PyO3 ecosystem towards a more deliberate application of interior mutability. Eventually, this should enable further optimizations of PyO3's internals and avoid downstream code paying the cost of interior mutability when it is not actually required.</p>
<h2 id="customizing-the-class"><a class="header" href="#customizing-the-class">Customizing the class</a></h2>
<p><code>#[pyclass]</code> can be used with the following parameters:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><span style="white-space: pre"><code>crate = "some::path"</code></span></td><td style="text-align: left">Path to import the <code>pyo3</code> crate, if it's not accessible at <code>::pyo3</code>.</td></tr>
<tr><td style="text-align: left"><code>dict</code></td><td style="text-align: left">Gives instances of this class an empty <code>__dict__</code> to store custom attributes.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>extends = BaseType</code></span></td><td style="text-align: left">Use a custom baseclass. Defaults to <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html"><code>PyAny</code></a></td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>freelist = N</code></span></td><td style="text-align: left">Implements a <a href="https://en.wikipedia.org/wiki/Free_list">free list</a> of size N. This can improve performance for types that are often created and deleted in quick succession. Profile your code to see whether <code>freelist</code> is right for you.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>frozen</code></span></td><td style="text-align: left">Declares that your pyclass is immutable. It removes the borrow checker overhead when retrieving a shared reference to the Rust struct, but disables the ability to get a mutable reference.</td></tr>
<tr><td style="text-align: left"><code>get_all</code></td><td style="text-align: left">Generates getters for all fields of the pyclass.</td></tr>
<tr><td style="text-align: left"><code>mapping</code></td><td style="text-align: left">Inform PyO3 that this class is a <a href="https://pyo3.rs/latest/class/protocols.html#mapping--sequence-types"><code>Mapping</code></a>, and so leave its implementation of sequence C-API slots empty.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>module = "module_name"</code></span></td><td style="text-align: left">Python code will see the class as being defined in this module. Defaults to <code>builtins</code>.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>name = "python_name"</code></span></td><td style="text-align: left">Sets the name that Python sees this class as. Defaults to the name of the Rust struct.</td></tr>
<tr><td style="text-align: left"><code>rename_all = "renaming_rule"</code></td><td style="text-align: left">Applies renaming rules to every getters and setters of a struct, or every variants of an enum. Possible values are: "camelCase", "kebab-case", "lowercase", "PascalCase", "SCREAMING-KEBAB-CASE", "SCREAMING_SNAKE_CASE", "snake_case", "UPPERCASE".</td></tr>
<tr><td style="text-align: left"><code>sequence</code></td><td style="text-align: left">Inform PyO3 that this class is a <a href="https://pyo3.rs/latest/class/protocols.html#mapping--sequence-types"><code>Sequence</code></a>, and so leave its C-API mapping length slot empty.</td></tr>
<tr><td style="text-align: left"><code>set_all</code></td><td style="text-align: left">Generates setters for all fields of the pyclass.</td></tr>
<tr><td style="text-align: left"><code>subclass</code></td><td style="text-align: left">Allows other Python classes and <code>#[pyclass]</code> to inherit from this class. Enums cannot be subclassed.</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>text_signature = "(arg1, arg2, ...)"</code></span></td><td style="text-align: left">Sets the text signature for the Python class' <code>__new__</code> method.</td></tr>
<tr><td style="text-align: left"><code>unsendable</code></td><td style="text-align: left">Required if your struct is not <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>. Rather than using <code>unsendable</code>, consider implementing your struct in a threadsafe way by e.g. substituting <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> with <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>. By using <code>unsendable</code>, your class will panic when accessed by another thread. Also note the Python's GC is multi-threaded and while unsendable classes will not be traversed on foreign threads to avoid UB, this can lead to memory leaks.</td></tr>
<tr><td style="text-align: left"><code>weakref</code></td><td style="text-align: left">Allows this class to be <a href="https://docs.python.org/3/library/weakref.html">weakly referenceable</a>.</td></tr>
</tbody></table>
</div>
<p>All of these parameters can either be passed directly on the <code>#[pyclass(...)]</code> annotation, or as one or
more accompanying <code>#[pyo3(...)]</code> annotations, e.g.:</p>
<pre><code class="language-rust ignore">// Argument supplied directly to the `#[pyclass]` annotation.
#[pyclass(name = "SomeName", subclass)]
struct MyClass {}

// Argument supplied as a separate annotation.
#[pyclass]
#[pyo3(name = "SomeName", subclass)]
struct MyClass {}</code></pre>
<p>These parameters are covered in various sections of this guide.</p>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>Generally, <code>#[new]</code> methods have to return <code>T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code> or
<code>PyResult&lt;T&gt; where T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code>.</p>
<p>For constructors that may fail, you should wrap the return type in a PyResult as well.
Consult the table below to determine which type your constructor should return:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><strong>Cannot fail</strong></th><th><strong>May fail</strong></th></tr></thead><tbody>
<tr><td><strong>No inheritance</strong></td><td><code>T</code></td><td><code>PyResult&lt;T&gt;</code></td></tr>
<tr><td><strong>Inheritance(T Inherits U)</strong></td><td><code>(T, U)</code></td><td><code>PyResult&lt;(T, U)&gt;</code></td></tr>
<tr><td><strong>Inheritance(General Case)</strong></td><td><a href="https://docs.rs/pyo3/0.21.2/pyo3/pyclass_init/struct.PyClassInitializer.html"><code>PyClassInitializer&lt;T&gt;</code></a></td><td><code>PyResult&lt;PyClassInitializer&lt;T&gt;&gt;</code></td></tr>
</tbody></table>
</div>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>By default, <code>object</code>, i.e. <code>PyAny</code> is used as the base class. To override this default,
use the <code>extends</code> parameter for <code>pyclass</code> with the full path to the base class.
Currently, only classes defined in Rust and builtins provided by PyO3 can be inherited
from; inheriting from other classes defined in Python is not yet supported
(<a href="https://github.com/PyO3/pyo3/issues/991">#991</a>).</p>
<p>For convenience, <code>(T, U)</code> implements <code>Into&lt;PyClassInitializer&lt;T&gt;&gt;</code> where <code>U</code> is the
base class of <code>T</code>.
But for a more deeply nested inheritance, you have to return <code>PyClassInitializer&lt;T&gt;</code>
explicitly.</p>
<p>To get a parent class from a child, use <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> instead of <code>&amp;self</code> for methods,
or <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a> instead of <code>&amp;mut self</code>.
Then you can access a parent class by <code>self_.as_ref()</code> as <code>&amp;Self::BaseClass</code>,
or by <code>self_.into_super()</code> as <code>PyRef&lt;Self::BaseClass&gt;</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass(subclass)]
struct BaseClass {
    val1: usize,
}

#[pymethods]
impl BaseClass {
    #[new]
    fn new() -&gt; Self {
        BaseClass { val1: 10 }
    }

    pub fn method(&amp;self) -&gt; PyResult&lt;usize&gt; {
        Ok(self.val1)
    }
}

#[pyclass(extends=BaseClass, subclass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; (Self, BaseClass) {
        (SubClass { val2: 15 }, BaseClass::new())
    }

    fn method2(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let super_ = self_.as_ref(); // Get &amp;BaseClass
        super_.method().map(|x| x * self_.val2)
    }
}

#[pyclass(extends=SubClass)]
struct SubSubClass {
    val3: usize,
}

#[pymethods]
impl SubSubClass {
    #[new]
    fn new() -&gt; PyClassInitializer&lt;Self&gt; {
        PyClassInitializer::from(SubClass::new()).add_subclass(SubSubClass { val3: 20 })
    }

    fn method3(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let v = self_.val3;
        let super_ = self_.into_super(); // Get PyRef&lt;'_, SubClass&gt;
        SubClass::method2(super_).map(|x| x * v)
    }

    #[staticmethod]
    fn factory_method(py: Python&lt;'_&gt;, val: usize) -&gt; PyResult&lt;PyObject&gt; {
        let base = PyClassInitializer::from(BaseClass::new());
        let sub = base.add_subclass(SubClass { val2: val });
        if val % 2 == 0 {
            Ok(Py::new(py, sub)?.to_object(py))
        } else {
            let sub_sub = sub.add_subclass(SubSubClass { val3: val });
            Ok(Py::new(py, sub_sub)?.to_object(py))
        }
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let subsub = pyo3::Py::new(py, SubSubClass::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.method3() == 3000");
</span><span class="boring">    let subsub = SubSubClass::factory_method(py, 2).unwrap();
</span><span class="boring">    let subsubsub = SubSubClass::factory_method(py, 3).unwrap();
</span><span class="boring">    let cls = py.get_type_bound::&lt;SubSubClass&gt;();
</span><span class="boring">    pyo3::py_run!(py, subsub cls, "assert not isinstance(subsub, cls)");
</span><span class="boring">    pyo3::py_run!(py, subsubsub cls, "assert isinstance(subsubsub, cls)");
</span><span class="boring">});</span></code></pre>
<p>You can inherit native types such as <code>PyDict</code>, if they implement
<a href="https://docs.rs/pyo3/0.21.2/pyo3/type_object/trait.PySizedLayout.html"><code>PySizedLayout</code></a>.
This is not supported when building for the Python limited API (aka the <code>abi3</code> feature of PyO3).</p>
<p>To convert between the Rust type and its native base class, you can take
<code>slf</code> as a Python object. To access the Rust fields use <code>slf.borrow()</code> or
<code>slf.borrow_mut()</code>, and to access the base class use <code>slf.downcast::&lt;BaseClass&gt;()</code>.</p>
<pre><code class="language-rust"><span class="boring">#[cfg(not(Py_LIMITED_API))] {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;
use std::collections::HashMap;

#[pyclass(extends=PyDict)]
#[derive(Default)]
struct DictWithCounter {
    counter: HashMap&lt;String, usize&gt;,
}

#[pymethods]
impl DictWithCounter {
    #[new]
    fn new() -&gt; Self {
        Self::default()
    }

    fn set(slf: &amp;Bound&lt;'_, Self&gt;, key: String, value: Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;()&gt; {
        slf.borrow_mut().counter.entry(key.clone()).or_insert(0);
        let dict = slf.downcast::&lt;PyDict&gt;()?;
        dict.set_item(key, value)
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let cnt = pyo3::Py::new(py, DictWithCounter::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, cnt, "cnt.set('abc', 10); assert cnt['abc'] == 10")
</span><span class="boring">});
</span><span class="boring">}</span></code></pre>
<p>If <code>SubClass</code> does not provide a base class initialization, the compilation fails.</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct BaseClass {
    val1: usize,
}

#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}

#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; Self {
        SubClass { val2: 15 }
    }
}</code></pre>
<p>The <code>__new__</code> constructor of a native base class is called implicitly when
creating a new instance from Python.  Be sure to accept arguments in the
<code>#[new]</code> method that you want the base class to get, even if they are not used
in that <code>fn</code>:</p>
<pre><code class="language-rust"><span class="boring">#[allow(dead_code)]
</span><span class="boring">#[cfg(not(Py_LIMITED_API))] {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;

#[pyclass(extends=PyDict)]
struct MyDict {
    private: i32,
}

#[pymethods]
impl MyDict {
    #[new]
    #[pyo3(signature = (*args, **kwargs))]
    fn new(args: &amp;Bound&lt;'_, PyAny&gt;, kwargs: Option&lt;&amp;Bound&lt;'_, PyAny&gt;&gt;) -&gt; Self {
        Self { private: 0 }
    }

    // some custom methods that use `private` here...
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let cls = py.get_type_bound::&lt;MyDict&gt;();
</span><span class="boring">    pyo3::py_run!(py, cls, "cls(a=1, b=2)")
</span><span class="boring">});
</span><span class="boring">}</span></code></pre>
<p>Here, the <code>args</code> and <code>kwargs</code> allow creating instances of the subclass passing
initial items, such as <code>MyDict(item_sequence)</code> or <code>MyDict(a=1, b=2)</code>.</p>
<h2 id="object-properties"><a class="header" href="#object-properties">Object properties</a></h2>
<p>PyO3 supports two ways to add properties to your <code>#[pyclass]</code>:</p>
<ul>
<li>For simple struct fields with no side effects, a <code>#[pyo3(get, set)]</code> attribute can be added directly to the field definition in the <code>#[pyclass]</code>.</li>
<li>For properties which require computation you can define <code>#[getter]</code> and <code>#[setter]</code> functions in the <a href="class.html#instance-methods"><code>#[pymethods]</code></a> block.</li>
</ul>
<p>We'll cover each of these in the following sections.</p>
<h3 id="object-properties-using-pyo3get-set"><a class="header" href="#object-properties-using-pyo3get-set">Object properties using <code>#[pyo3(get, set)]</code></a></h3>
<p>For simple cases where a member variable is just read and written with no side effects, you can declare getters and setters in your <code>#[pyclass]</code> field definition using the <code>pyo3</code> attribute, like in the example below:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get, set)]
    num: i32,
}</code></pre>
<p>The above would make the <code>num</code> field available for reading and writing as a <code>self.num</code> Python property. To expose the property with a different name to the field, specify this alongside the rest of the options, e.g. <code>#[pyo3(get, set, name = "custom_name")]</code>.</p>
<p>Properties can be readonly or writeonly by using just <code>#[pyo3(get)]</code> or <code>#[pyo3(set)]</code> respectively.</p>
<p>To use these annotations, your field type must implement some conversion traits:</p>
<ul>
<li>For <code>get</code> the field type must implement both <code>IntoPy&lt;PyObject&gt;</code> and <code>Clone</code>.</li>
<li>For <code>set</code> the field type must implement <code>FromPyObject</code>.</li>
</ul>
<p>For example, implementations of those traits are provided for the <code>Cell</code> type, if the inner type also implements the trait. This means you can use <code>#[pyo3(get, set)]</code> on fields wrapped in a <code>Cell</code>.</p>
<h3 id="object-properties-using-getter-and-setter"><a class="header" href="#object-properties-using-getter-and-setter">Object properties using <code>#[getter]</code> and <code>#[setter]</code></a></h3>
<p>For cases which don't satisfy the <code>#[pyo3(get, set)]</code> trait requirements, or need side effects, descriptor methods can be defined in a <code>#[pymethods]</code> <code>impl</code> block.</p>
<p>This is done using the <code>#[getter]</code> and <code>#[setter]</code> attributes, like in the example below:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}

#[pymethods]
impl MyClass {
    #[getter]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }
}</code></pre>
<p>A getter or setter's function name is used as the property name by default. There are several
ways how to override the name.</p>
<p>If a function name starts with <code>get_</code> or <code>set_</code> for getter or setter respectively,
the descriptor name becomes the function name with this prefix removed. This is also useful in case of
Rust keywords like <code>type</code>
(<a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/raw-identifiers.html">raw identifiers</a>
can be used since Rust 2018).</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter]
    fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}</code></pre>
<p>In this case, a property <code>num</code> is defined and available from Python code as <code>self.num</code>.</p>
<p>Both the <code>#[getter]</code> and <code>#[setter]</code> attributes accept one parameter.
If this parameter is specified, it is used as the property name, i.e.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter(number)]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }

    #[setter(number)]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}</code></pre>
<p>In this case, the property <code>number</code> is defined and available from Python code as <code>self.number</code>.</p>
<p>Attributes defined by <code>#[setter]</code> or <code>#[pyo3(set)]</code> will always raise <code>AttributeError</code> on <code>del</code>
operations. Support for defining custom <code>del</code> behavior is tracked in
<a href="https://github.com/PyO3/pyo3/issues/1778">#1778</a>.</p>
<h2 id="instance-methods"><a class="header" href="#instance-methods">Instance methods</a></h2>
<p>To define a Python compatible method, an <code>impl</code> block for your struct has to be annotated with the
<code>#[pymethods]</code> attribute. PyO3 generates Python compatible wrappers for all functions in this
block with some variations, like descriptors, class method static methods, etc.</p>
<p>Since Rust allows any number of <code>impl</code> blocks, you can easily split methods
between those accessible to Python (and Rust) and those accessible only to Rust. However to have multiple
<code>#[pymethods]</code>-annotated <code>impl</code> blocks for the same struct you must enable the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature of PyO3.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }

    fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}</code></pre>
<p>Calls to these methods are protected by the GIL, so both <code>&amp;self</code> and <code>&amp;mut self</code> can be used.
The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>;
the latter is allowed if the method cannot raise Python exceptions.</p>
<p>A <code>Python</code> parameter can be specified as part of method signature, in this case the <code>py</code> argument
gets injected by the method wrapper, e.g.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method2(&amp;self, py: Python&lt;'_&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}</code></pre>
<p>From the Python perspective, the <code>method2</code> in this example does not accept any arguments.</p>
<h2 id="class-methods"><a class="header" href="#class-methods">Class methods</a></h2>
<p>To create a class method for a custom class, the method needs to be annotated
with the <code>#[classmethod]</code> attribute.
This is the equivalent of the Python decorator <code>@classmethod</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    #[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[classmethod]
    fn cls_method(cls: &amp;Bound&lt;'_, PyType&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}</code></pre>
<p>Declares a class method callable from Python.</p>
<ul>
<li>The first parameter is the type object of the class on which the method is called.
This may be the type object of a derived class.</li>
<li>The first parameter implicitly has type <code>&amp;Bound&lt;'_, PyType&gt;</code>.</li>
<li>For details on <code>parameter-list</code>, see the documentation of <code>Method arguments</code> section.</li>
<li>The return type must be <code>PyResult&lt;T&gt;</code> or <code>T</code> for some <code>T</code> that implements <code>IntoPy&lt;PyObject&gt;</code>.</li>
</ul>
<h3 id="constructors-which-accept-a-class-argument"><a class="header" href="#constructors-which-accept-a-class-argument">Constructors which accept a class argument</a></h3>
<p>To create a constructor which takes a positional class argument, you can combine the <code>#[classmethod]</code> and <code>#[new]</code> modifiers:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct BaseClass(PyObject);
</span><span class="boring">
</span>#[pymethods]
impl BaseClass {
    #[new]
    #[classmethod]
    fn py_new(cls: &amp;Bound&lt;'_, PyType&gt;) -&gt; PyResult&lt;Self&gt; {
        // Get an abstract attribute (presumably) declared on a subclass of this class.
        let subclass_attr: Bound&lt;'_, PyAny&gt; = cls.getattr("a_class_attr")?;
        Ok(Self(subclass_attr.unbind()))
    }
}</code></pre>
<h2 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h2>
<p>To create a static method for a custom class, the method needs to be annotated with the
<code>#[staticmethod]</code> attribute. The return type must be <code>T</code> or <code>PyResult&lt;T&gt;</code> for some <code>T</code> that implements
<code>IntoPy&lt;PyObject&gt;</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    #[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[staticmethod]
    fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}</code></pre>
<h2 id="class-attributes"><a class="header" href="#class-attributes">Class attributes</a></h2>
<p>To create a class attribute (also called <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables">class variable</a>), a method without
any arguments can be annotated with the <code>#[classattr]</code> attribute.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    fn my_attribute() -&gt; String {
        "hello".to_string()
    }
}

Python::with_gil(|py| {
    let my_class = py.get_type_bound::&lt;MyClass&gt;();
    pyo3::py_run!(py, my_class, "assert my_class.my_attribute == 'hello'")
});</code></pre>
<blockquote>
<p>Note: if the method has a <code>Result</code> return type and returns an <code>Err</code>, PyO3 will panic during
class creation.</p>
</blockquote>
<p>If the class attribute is defined with <code>const</code> code only, one can also annotate associated
constants:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    const MY_CONST_ATTRIBUTE: &amp;'static str = "foobar";
}</code></pre>
<h2 id="classes-as-function-arguments"><a class="header" href="#classes-as-function-arguments">Classes as function arguments</a></h2>
<p>Free functions defined using <code>#[pyfunction]</code> interact with classes through the same mechanisms as the self parameters of instance methods, i.e. they can take GIL-bound references, GIL-bound reference wrappers or GIL-indepedent references:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    my_field: i32,
}

// Take a reference when the underlying `Bound` is irrelevant.
#[pyfunction]
fn increment_field(my_class: &amp;mut MyClass) {
    my_class.my_field += 1;
}

// Take a reference wrapper when borrowing should be automatic,
// but interaction with the underlying `Bound` is desired.
#[pyfunction]
fn print_field(my_class: PyRef&lt;'_, MyClass&gt;) {
    println!("{}", my_class.my_field);
}

// Take a reference to the underlying Bound
// when borrowing needs to be managed manually.
#[pyfunction]
fn increment_then_print_field(my_class: &amp;Bound&lt;'_, MyClass&gt;) {
    my_class.borrow_mut().my_field += 1;

    println!("{}", my_class.borrow().my_field);
}

// Take a GIL-indepedent reference when you want to store the reference elsewhere.
#[pyfunction]
fn print_refcnt(my_class: Py&lt;MyClass&gt;, py: Python&lt;'_&gt;) {
    println!("{}", my_class.get_refcnt(py));
}</code></pre>
<p>Classes can also be passed by value if they can be cloned, i.e. they automatically implement <code>FromPyObject</code> if they implement <code>Clone</code>, e.g. via <code>#[derive(Clone)]</code>:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
#[derive(Clone)]
struct MyClass {
    my_field: Box&lt;i32&gt;,
}

#[pyfunction]
fn dissamble_clone(my_class: MyClass) {
    let MyClass { mut my_field } = my_class;
    *my_field += 1;
}</code></pre>
<p>Note that <code>#[derive(FromPyObject)]</code> on a class is usually not useful as it tries to construct a new Rust value by filling in the fields by looking up attributes of any given Python value.</p>
<h2 id="method-arguments"><a class="header" href="#method-arguments">Method arguments</a></h2>
<p>Similar to <code>#[pyfunction]</code>, the <code>#[pyo3(signature = (...))]</code> attribute can be used to specify the way that <code>#[pymethods]</code> accept arguments. Consult the documentation for <a href="./function/signature.html"><code>function signatures</code></a> to see the parameters this attribute accepts.</p>
<p>The following example defines a class <code>MyClass</code> with a method <code>method</code>. This method has a signature that sets default values for <code>num</code> and <code>name</code>, and indicates that <code>py_args</code> should collect all extra positional arguments and <code>py_kwargs</code> all extra keyword arguments:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::{PyDict, PyTuple};
<span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[new]
    #[pyo3(signature = (num=-1))]
    fn new(num: i32) -&gt; Self {
        MyClass { num }
    }

    #[pyo3(signature = (num=10, *py_args, name="Hello", **py_kwargs))]
    fn method(
        &amp;mut self,
        num: i32,
        py_args: &amp;Bound&lt;'_, PyTuple&gt;,
        name: &amp;str,
        py_kwargs: Option&lt;&amp;Bound&lt;'_, PyDict&gt;&gt;,
    ) -&gt; String {
        let num_before = self.num;
        self.num = num;
        format!(
            "num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} ",
            num, num_before, py_args, name, py_kwargs,
        )
    }
}</code></pre>
<p>In Python, this might be used like:</p>
<pre><code class="language-python">&gt;&gt;&gt; import mymodule
&gt;&gt;&gt; mc = mymodule.MyClass()
&gt;&gt;&gt; print(mc.method(44, False, "World", 666, x=44, y=55))
py_args=('World', 666), py_kwargs=Some({'x': 44, 'y': 55}), name=Hello, num=44, num_before=-1
&gt;&gt;&gt; print(mc.method(num=-1, name="World"))
py_args=(), py_kwargs=None, name=World, num=-1, num_before=44
</code></pre>
<p>The <a href="./function/signature.html#overriding-the-generated-signature"><code>#[pyo3(text_signature = "...")</code></a> option for <code>#[pyfunction]</code> also works for <code>#[pymethods]</code>.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;
use pyo3::types::PyType;

#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
    #[new]
    #[pyo3(text_signature = "(c, d)")]
    fn new(c: i32, d: &amp;str) -&gt; Self {
        Self {}
    }
    // the self argument should be written $self
    #[pyo3(text_signature = "($self, e, f)")]
    fn my_method(&amp;self, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    // similarly for classmethod arguments, use $cls
    #[classmethod]
    #[pyo3(text_signature = "($cls, e, f)")]
    fn my_class_method(cls: &amp;Bound&lt;'_, PyType&gt;, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[staticmethod]
    #[pyo3(text_signature = "(e, f)")]
    fn my_static_method(e: i32, f: i32) -&gt; i32 {
        e + f
    }
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let inspect = PyModule::import_bound(py, "inspect")?.getattr("signature")?;
</span><span class="boring">        let module = PyModule::new_bound(py, "my_module")?;
</span><span class="boring">        module.add_class::&lt;MyClass&gt;()?;
</span><span class="boring">        let class = module.getattr("MyClass")?;
</span><span class="boring">
</span><span class="boring">        if cfg!(not(Py_LIMITED_API)) || py.version_info() &gt;= (3, 10)  {
</span><span class="boring">            let doc: String = class.getattr("__doc__")?.extract()?;
</span><span class="boring">            assert_eq!(doc, "");
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((&amp;class,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(c, d)");
</span><span class="boring">        } else {
</span><span class="boring">            let doc: String = class.getattr("__doc__")?.extract()?;
</span><span class="boring">            assert_eq!(doc, "");
</span><span class="boring">
</span><span class="boring">            inspect.call1((&amp;class,)).expect_err("`text_signature` on classes is not compatible with compilation in `abi3` mode until Python 3.10 or greater");
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr("my_method")?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr("__doc__")?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(self, /, e, f)");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr("my_class_method")?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr("__doc__")?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(e, f)");  // inspect.signature skips the $cls arg
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr("my_static_method")?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr("__doc__")?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(e, f)");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>Note that <code>text_signature</code> on <code>#[new]</code> is not compatible with compilation in
<code>abi3</code> mode until Python 3.10 or greater.</p>
<h3 id="method-receivers-and-lifetime-elision"><a class="header" href="#method-receivers-and-lifetime-elision">Method receivers and lifetime elision</a></h3>
<p>PyO3 supports writing instance methods using the normal method receivers for shared <code>&amp;self</code> and unique <code>&amp;mut self</code> references. This interacts with <a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision</a> insofar as the lifetime of a such a receiver is assigned to all elided output lifetime parameters.</p>
<p>This is a good default for general Rust code where return values are more likely to borrow from the receiver than from the other arguments, if they contain any lifetimes at all. However, when returning bound references <code>Bound&lt;'py, T&gt;</code> in PyO3-based code, the GIL lifetime <code>'py</code> should usually be derived from a GIL token <code>py: Python&lt;'py&gt;</code> passed as an argument instead of the receiver.</p>
<p>Specifically, signatures like</p>
<pre><code class="language-rust ignore">fn frobnicate(&amp;self, py: Python) -&gt; Bound&lt;Foo&gt;;</code></pre>
<p>will not work as they are inferred as</p>
<pre><code class="language-rust ignore">fn frobnicate&lt;'a, 'py&gt;(&amp;'a self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'a, Foo&gt;;</code></pre>
<p>instead of the intended</p>
<pre><code class="language-rust ignore">fn frobnicate&lt;'a, 'py&gt;(&amp;'a self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'py, Foo&gt;;</code></pre>
<p>and should usually be written as</p>
<pre><code class="language-rust ignore">fn frobnicate&lt;'py&gt;(&amp;self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'py, Foo&gt;;</code></pre>
<p>The same problem does not exist for <code>#[pyfunction]</code>s as the special case for receiver lifetimes does not apply and indeed a signature like</p>
<pre><code class="language-rust ignore">fn frobnicate(bar: &amp;Bar, py: Python) -&gt; Bound&lt;Foo&gt;;</code></pre>
<p>will yield compiler error <a href="https://doc.rust-lang.org/error_codes/E0106.html">E0106 "missing lifetime specifier"</a>.</p>
<h2 id="pyclass-enums"><a class="header" href="#pyclass-enums"><code>#[pyclass]</code> enums</a></h2>
<p>Enum support in PyO3 comes in two flavors, depending on what kind of variants the enum has: simple and complex.</p>
<h3 id="simple-enums"><a class="header" href="#simple-enums">Simple enums</a></h3>
<p>A simple enum (a.k.a. C-like enum) has only unit variants.</p>
<p>PyO3 adds a class attribute for each variant, so you can access them in Python without defining <code>#[new]</code>. PyO3 also provides default implementations of <code>__richcmp__</code> and <code>__int__</code>, so they can be compared using <code>==</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum {
    Variant,
    OtherVariant,
}

Python::with_gil(|py| {
    let x = Py::new(py, MyEnum::Variant).unwrap();
    let y = Py::new(py, MyEnum::OtherVariant).unwrap();
    let cls = py.get_type_bound::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x y cls, r#"
        assert x == cls.Variant
        assert y == cls.OtherVariant
        assert x != y
    "#)
})</code></pre>
<p>You can also convert your simple enums into <code>int</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum {
    Variant,
    OtherVariant = 10,
}

Python::with_gil(|py| {
    let cls = py.get_type_bound::&lt;MyEnum&gt;();
    let x = MyEnum::Variant as i32; // The exact value is assigned by the compiler.
    pyo3::py_run!(py, cls x, r#"
        assert int(cls.Variant) == x
        assert int(cls.OtherVariant) == 10
        assert cls.OtherVariant == 10  # You can also compare against int.
        assert 10 == cls.OtherVariant
    "#)
})</code></pre>
<p>PyO3 also provides <code>__repr__</code> for enums:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum{
    Variant,
    OtherVariant,
}

Python::with_gil(|py| {
    let cls = py.get_type_bound::&lt;MyEnum&gt;();
    let x = Py::new(py, MyEnum::Variant).unwrap();
    pyo3::py_run!(py, cls x, r#"
        assert repr(x) == 'MyEnum.Variant'
        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'
    "#)
})</code></pre>
<p>All methods defined by PyO3 can be overridden. For example here's how you override <code>__repr__</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum {
    Answer = 42,
}

#[pymethods]
impl MyEnum {
    fn __repr__(&amp;self) -&gt; &amp;'static str {
        "42"
    }
}

Python::with_gil(|py| {
    let cls = py.get_type_bound::&lt;MyEnum&gt;();
    pyo3::py_run!(py, cls, "assert repr(cls.Answer) == '42'")
})</code></pre>
<p>Enums and their variants can also be renamed using <code>#[pyo3(name)]</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(name = "RenamedEnum")]
enum MyEnum {
    #[pyo3(name = "UPPERCASE")]
    Variant,
}

Python::with_gil(|py| {
    let x = Py::new(py, MyEnum::Variant).unwrap();
    let cls = py.get_type_bound::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x cls, r#"
        assert repr(x) == 'RenamedEnum.UPPERCASE'
        assert x == cls.UPPERCASE
    "#)
})</code></pre>
<p>You may not use enums as a base class or let enums inherit from other classes.</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(subclass)]
enum BadBase {
    Var1,
}</code></pre>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass(subclass)]
struct Base;

#[pyclass(extends=Base)]
enum BadSubclass {
    Var1,
}</code></pre>
<p><code>#[pyclass]</code> enums are currently not interoperable with <code>IntEnum</code> in Python.</p>
<h3 id="complex-enums"><a class="header" href="#complex-enums">Complex enums</a></h3>
<p>An enum is complex if it has any non-unit (struct or tuple) variants.</p>
<p>Currently PyO3 supports only struct variants in a complex enum. Support for unit and tuple variants is planned.</p>
<p>PyO3 adds a class attribute for each variant, which may be used to construct values and in match patterns. PyO3 also provides getter methods for all fields of each variant.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
    RegularPolygon { side_count: u32, radius: f64 },
    Nothing { },
}

<span class="boring">#[cfg(Py_3_10)]
</span>Python::with_gil(|py| {
    let circle = Shape::Circle { radius: 10.0 }.into_py(py);
    let square = Shape::RegularPolygon { side_count: 4, radius: 10.0 }.into_py(py);
    let cls = py.get_type_bound::&lt;Shape&gt;();
    pyo3::py_run!(py, circle square cls, r#"
        assert isinstance(circle, cls)
        assert isinstance(circle, cls.Circle)
        assert circle.radius == 10.0

        assert isinstance(square, cls)
        assert isinstance(square, cls.RegularPolygon)
        assert square.side_count == 4
        assert square.radius == 10.0

        def count_vertices(cls, shape):
            match shape:
                case cls.Circle():
                    return 0
                case cls.Rectangle():
                    return 4
                case cls.RegularPolygon(side_count=n):
                    return n
                case cls.Nothing():
                    return 0

        assert count_vertices(cls, circle) == 0
        assert count_vertices(cls, square) == 4
    "#)
})</code></pre>
<p>WARNING: <code>Py::new</code> and <code>.into_py</code> are currently inconsistent. Note how the constructed value is <em>not</em> an instance of the specific variant. For this reason, constructing values is only recommended using <code>.into_py</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum {
    Variant { i: i32 },
}

Python::with_gil(|py| {
    let x = Py::new(py, MyEnum::Variant { i: 42 }).unwrap();
    let cls = py.get_type_bound::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x cls, r#"
        assert isinstance(x, cls)
        assert not isinstance(x, cls.Variant)
    "#)
})</code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h2>
<p>The <code>#[pyclass]</code> macros rely on a lot of conditional code generation: each <code>#[pyclass]</code> can optionally have a <code>#[pymethods]</code> block.</p>
<p>To support this flexibility the <code>#[pyclass]</code> macro expands to a blob of boilerplate code which sets up the structure for <a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">"dtolnay specialization"</a>. This implementation pattern enables the Rust compiler to use <code>#[pymethods]</code> implementations when they are present, and fall back to default (empty) definitions when they are not.</p>
<p>This simple technique works for the case when there is zero or one implementations. To support multiple <code>#[pymethods]</code> for a <code>#[pyclass]</code> (in the <a href="features.html#multiple-pymethods"><code>multiple-pymethods</code></a> feature), a registry mechanism provided by the <a href="https://github.com/dtolnay/inventory"><code>inventory</code></a> crate is used instead. This collects <code>impl</code>s at library load time, but isn't supported on all platforms. See <a href="https://github.com/dtolnay/inventory#how-it-works">inventory: how it works</a> for more details.</p>
<p>The <code>#[pyclass]</code> macro expands to roughly the code seen below. The <code>PyClassImplCollector</code> is the type used internally by PyO3 for dtolnay specialization:</p>
<pre><code class="language-rust"><span class="boring">#[cfg(not(feature = "multiple-pymethods"))] {
</span><span class="boring">use pyo3::prelude::*;
</span>// Note: the implementation differs slightly with the `multiple-pymethods` feature enabled.
struct MyClass {
<span class="boring">    #[allow(dead_code)]
</span>    num: i32,
}

impl pyo3::types::DerefToPyAny for MyClass {}

<span class="boring">#[allow(deprecated)]
</span>unsafe impl pyo3::type_object::HasPyGilRef for MyClass {
    type AsRefTarget = pyo3::PyCell&lt;Self&gt;;
}
unsafe impl pyo3::type_object::PyTypeInfo for MyClass {
    const NAME: &amp;'static str = "MyClass";
    const MODULE: ::std::option::Option&lt;&amp;'static str&gt; = ::std::option::Option::None;
    #[inline]
    fn type_object_raw(py: pyo3::Python&lt;'_&gt;) -&gt; *mut pyo3::ffi::PyTypeObject {
        &lt;Self as pyo3::impl_::pyclass::PyClassImpl&gt;::lazy_type_object()
            .get_or_init(py)
            .as_type_ptr()
    }
}

impl pyo3::PyClass for MyClass {
    type Frozen = pyo3::pyclass::boolean_struct::False;
}

impl&lt;'a, 'py&gt; pyo3::impl_::extract_argument::PyFunctionArgument&lt;'a, 'py&gt; for &amp;'a MyClass
{
    type Holder = ::std::option::Option&lt;pyo3::PyRef&lt;'py, MyClass&gt;&gt;;

    #[inline]
    fn extract(obj: &amp;'a pyo3::Bound&lt;'py, PyAny&gt;, holder: &amp;'a mut Self::Holder) -&gt; pyo3::PyResult&lt;Self&gt; {
        pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
    }
}

impl&lt;'a, 'py&gt; pyo3::impl_::extract_argument::PyFunctionArgument&lt;'a, 'py&gt; for &amp;'a mut MyClass
{
    type Holder = ::std::option::Option&lt;pyo3::PyRefMut&lt;'py, MyClass&gt;&gt;;

    #[inline]
    fn extract(obj: &amp;'a pyo3::Bound&lt;'py, PyAny&gt;, holder: &amp;'a mut Self::Holder) -&gt; pyo3::PyResult&lt;Self&gt; {
        pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
    }
}

impl pyo3::IntoPy&lt;PyObject&gt; for MyClass {
    fn into_py(self, py: pyo3::Python&lt;'_&gt;) -&gt; pyo3::PyObject {
        pyo3::IntoPy::into_py(pyo3::Py::new(py, self).unwrap(), py)
    }
}

impl pyo3::impl_::pyclass::PyClassImpl for MyClass {
    const IS_BASETYPE: bool = false;
    const IS_SUBCLASS: bool = false;
    const IS_MAPPING: bool = false;
    const IS_SEQUENCE: bool = false;
    type BaseType = PyAny;
    type ThreadChecker = pyo3::impl_::pyclass::SendablePyClass&lt;MyClass&gt;;
    type PyClassMutability = &lt;&lt;pyo3::PyAny as pyo3::impl_::pyclass::PyClassBaseType&gt;::PyClassMutability as pyo3::impl_::pycell::PyClassMutability&gt;::MutableChild;
    type Dict = pyo3::impl_::pyclass::PyClassDummySlot;
    type WeakRef = pyo3::impl_::pyclass::PyClassDummySlot;
    type BaseNativeType = pyo3::PyAny;

    fn items_iter() -&gt; pyo3::impl_::pyclass::PyClassItemsIter {
        use pyo3::impl_::pyclass::*;
        let collector = PyClassImplCollector::&lt;MyClass&gt;::new();
        static INTRINSIC_ITEMS: PyClassItems = PyClassItems { slots: &amp;[], methods: &amp;[] };
        PyClassItemsIter::new(&amp;INTRINSIC_ITEMS, collector.py_methods())
    }

    fn lazy_type_object() -&gt; &amp;'static pyo3::impl_::pyclass::LazyTypeObject&lt;MyClass&gt; {
        use pyo3::impl_::pyclass::LazyTypeObject;
        static TYPE_OBJECT: LazyTypeObject&lt;MyClass&gt; = LazyTypeObject::new();
        &amp;TYPE_OBJECT
    }

    fn doc(py: Python&lt;'_&gt;) -&gt; pyo3::PyResult&lt;&amp;'static ::std::ffi::CStr&gt; {
        use pyo3::impl_::pyclass::*;
        static DOC: pyo3::sync::GILOnceCell&lt;::std::borrow::Cow&lt;'static, ::std::ffi::CStr&gt;&gt; = pyo3::sync::GILOnceCell::new();
        DOC.get_or_try_init(py, || {
            let collector = PyClassImplCollector::&lt;Self&gt;::new();
            build_pyclass_doc(&lt;MyClass as pyo3::PyTypeInfo&gt;::NAME, "\0", collector.new_text_signature())
        }).map(::std::ops::Deref::deref)
    }
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let cls = py.get_type_bound::&lt;MyClass&gt;();
</span><span class="boring">    pyo3::py_run!(py, cls, "assert cls.__name__ == 'MyClass'")
</span><span class="boring">});
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="magic-methods-and-slots"><a class="header" href="#magic-methods-and-slots">Magic methods and slots</a></h1>
<p>Python's object model defines several protocols for different object behavior, such as the sequence, mapping, and number protocols. You may be familiar with implementing these protocols in Python classes by "magic" methods, such as <code>__str__</code> or <code>__repr__</code>. Because of the double-underscores surrounding their name, these are also known as "dunder" methods.</p>
<p>In the Python C-API which PyO3 is implemented upon, many of these magic methods have to be placed into special "slots" on the class type object, as covered in the previous section.</p>
<p>If a function name in <code>#[pymethods]</code> is a recognised magic method, it will be automatically placed into the correct slot in the Python type object. The function name is taken from the usual rules for naming <code>#[pymethods]</code>: the <code>#[pyo3(name = "...")]</code> attribute is used if present, otherwise the Rust function name is used.</p>
<p>The magic methods handled by PyO3 are very similar to the standard Python ones on <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names">this page</a> - in particular they are the subset which have slots as <a href="https://docs.python.org/3/c-api/typeobj.html">defined here</a>. Some of the slots do not have a magic method in Python, which leads to a few additional magic methods defined only in PyO3:</p>
<ul>
<li>Magic methods for garbage collection</li>
<li>Magic methods for the buffer protocol</li>
</ul>
<p>When PyO3 handles a magic method, a couple of changes apply compared to other <code>#[pymethods]</code>:</p>
<ul>
<li>The Rust function signature is restricted to match the magic method.</li>
<li>The <code>#[pyo3(signature = (...)]</code> and <code>#[pyo3(text_signature = "...")]</code> attributes are not allowed.</li>
</ul>
<p>The following sections list of all magic methods PyO3 currently handles.  The
given signatures should be interpreted as follows:</p>
<ul>
<li>All methods take a receiver as first argument, shown as <code>&lt;self&gt;</code>. It can be
<code>&amp;self</code>, <code>&amp;mut self</code> or a <code>Bound</code> reference like <code>self_: PyRef&lt;'_, Self&gt;</code> and
<code>self_: PyRefMut&lt;'_, Self&gt;</code>, as described <a href="class/../class.html#inheritance">here</a>.</li>
<li>An optional <code>Python&lt;'py&gt;</code> argument is always allowed as the first argument.</li>
<li>Return values can be optionally wrapped in <code>PyResult</code>.</li>
<li><code>object</code> means that any type is allowed that can be extracted from a Python
object (if argument) or converted to a Python object (if return value).</li>
<li>Other types must match what's given, e.g. <code>pyo3::basic::CompareOp</code> for
<code>__richcmp__</code>'s second argument.</li>
<li>For the comparison and arithmetic methods, extraction errors are not
propagated as exceptions, but lead to a return of <code>NotImplemented</code>.</li>
<li>For some magic methods, the return values are not restricted by PyO3, but
checked by the Python interpreter. For example, <code>__str__</code> needs to return a
string object.  This is indicated by <code>object (Python type)</code>.</li>
</ul>
<h3 id="basic-object-customization"><a class="header" href="#basic-object-customization">Basic object customization</a></h3>
<ul>
<li>
<p><code>__str__(&lt;self&gt;) -&gt; object (str)</code></p>
</li>
<li>
<p><code>__repr__(&lt;self&gt;) -&gt; object (str)</code></p>
</li>
<li>
<p><code>__hash__(&lt;self&gt;) -&gt; isize</code></p>
<p>Objects that compare equal must have the same hash value. Any type up to 64 bits may be returned instead of <code>isize</code>, PyO3 will convert to an isize automatically (wrapping unsigned types like <code>u64</code> and <code>usize</code>).</p>
<details>
<summary>Disabling Python's default hash</summary>
By default, all `#[pyclass]` types have a default hash implementation from Python. Types which should not be hashable can override this by setting `__hash__` to `None`. This is the same mechanism as for a pure-Python class. This is done like so:
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span>#[pyclass]
struct NotHashable {}

#[pymethods]
impl NotHashable {
    #[classattr]
    const __hash__: Option&lt;PyObject&gt; = None;
}</code></pre>
</details>
</li>
<li>
<p><code>__lt__(&lt;self&gt;, object) -&gt; object</code></p>
</li>
<li>
<p><code>__le__(&lt;self&gt;, object) -&gt; object</code></p>
</li>
<li>
<p><code>__eq__(&lt;self&gt;, object) -&gt; object</code></p>
</li>
<li>
<p><code>__ne__(&lt;self&gt;, object) -&gt; object</code></p>
</li>
<li>
<p><code>__gt__(&lt;self&gt;, object) -&gt; object</code></p>
</li>
<li>
<p><code>__ge__(&lt;self&gt;, object) -&gt; object</code></p>
<p>The implementations of Python's "rich comparison" operators <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code> and <code>&gt;=</code> respectively.</p>
<p><em>Note that implementing any of these methods will cause Python not to generate a default <code>__hash__</code> implementation, so consider also implementing <code>__hash__</code>.</em></p>
<details>
<summary>Return type</summary>
The return type will normally be `bool` or `PyResult<bool>`, however any Python object can be returned.
</details>
</li>
<li>
<p><code>__richcmp__(&lt;self&gt;, object, pyo3::basic::CompareOp) -&gt; object</code></p>
<p>Implements Python comparison operations (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>) in a single method.
The <code>CompareOp</code> argument indicates the comparison operation being performed. You can use
<a href="https://docs.rs/pyo3/0.21.2/pyo3/pyclass/enum.CompareOp.html#method.matches"><code>CompareOp::matches</code></a> to adapt a Rust <code>std::cmp::Ordering</code> result to the requested comparison.</p>
<p><em>This method cannot be implemented in combination with any of <code>__lt__</code>, <code>__le__</code>, <code>__eq__</code>, <code>__ne__</code>, <code>__gt__</code>, or <code>__ge__</code>.</em></p>
<p><em>Note that implementing <code>__richcmp__</code> will cause Python not to generate a default <code>__hash__</code> implementation, so consider implementing <code>__hash__</code> when implementing <code>__richcmp__</code>.</em></p>
<details>
<summary>Return type</summary>
The return type will normally be `PyResult<bool>`, but any Python object can be returned.
<p>If you want to leave some operations unimplemented, you can return <code>py.NotImplemented()</code>
for some of the operations:</p>
<pre><code class="language-rust">use pyo3::class::basic::CompareOp;

<span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __richcmp__(&amp;self, other: &amp;Self, op: CompareOp, py: Python&lt;'_&gt;) -&gt; PyObject {
        match op {
            CompareOp::Eq =&gt; (self.0 == other.0).into_py(py),
            CompareOp::Ne =&gt; (self.0 != other.0).into_py(py),
            _ =&gt; py.NotImplemented(),
        }
    }
}</code></pre>
<p>If the second argument <code>object</code> is not of the type specified in the
signature, the generated code will automatically <code>return NotImplemented</code>.</p>
</details>
</li>
<li>
<p><code>__getattr__(&lt;self&gt;, object) -&gt; object</code></p>
</li>
<li>
<p><code>__getattribute__(&lt;self&gt;, object) -&gt; object</code></p>
<details>
<summary>Differences between `__getattr__` and `__getattribute__`</summary>
As in Python, `__getattr__` is only called if the attribute is not found
by normal attribute lookup.  `__getattribute__`, on the other hand, is
called for *every* attribute access.  If it wants to access existing
attributes on `self`, it needs to be very careful not to introduce
infinite recursion, and use `baseclass.__getattribute__()`.
</details>
</li>
<li>
<p><code>__setattr__(&lt;self&gt;, value: object) -&gt; ()</code></p>
</li>
<li>
<p><code>__delattr__(&lt;self&gt;, object) -&gt; ()</code></p>
<p>Overrides attribute access.</p>
</li>
<li>
<p><code>__bool__(&lt;self&gt;) -&gt; bool</code></p>
<p>Determines the "truthyness" of an object.</p>
</li>
<li>
<p><code>__call__(&lt;self&gt;, ...) -&gt; object</code> - here, any argument list can be defined
as for normal <code>pymethods</code></p>
</li>
</ul>
<h3 id="iterable-objects"><a class="header" href="#iterable-objects">Iterable objects</a></h3>
<p>Iterators can be defined using these methods:</p>
<ul>
<li><code>__iter__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__next__(&lt;self&gt;) -&gt; Option&lt;object&gt; or IterNextOutput</code> (<a href="class/protocols.html#returning-a-value-from-iteration">see details</a>)</li>
</ul>
<p>Returning <code>None</code> from <code>__next__</code> indicates that that there are no further items.</p>
<p>Example:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyclass]
struct MyIterator {
    iter: Box&lt;dyn Iterator&lt;Item = PyObject&gt; + Send&gt;,
}

#[pymethods]
impl MyIterator {
    fn __iter__(slf: PyRef&lt;'_, Self&gt;) -&gt; PyRef&lt;'_, Self&gt; {
        slf
    }
    fn __next__(mut slf: PyRefMut&lt;'_, Self&gt;) -&gt; Option&lt;PyObject&gt; {
        slf.iter.next()
    }
}</code></pre>
<p>In many cases you'll have a distinction between the type being iterated over
(i.e. the <em>iterable</em>) and the iterator it provides. In this case, the iterable
only needs to implement <code>__iter__()</code> while the iterator must implement both
<code>__iter__()</code> and <code>__next__()</code>. For example:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct Iter {
    inner: std::vec::IntoIter&lt;usize&gt;,
}

#[pymethods]
impl Iter {
    fn __iter__(slf: PyRef&lt;'_, Self&gt;) -&gt; PyRef&lt;'_, Self&gt; {
        slf
    }

    fn __next__(mut slf: PyRefMut&lt;'_, Self&gt;) -&gt; Option&lt;usize&gt; {
        slf.inner.next()
    }
}

#[pyclass]
struct Container {
    iter: Vec&lt;usize&gt;,
}

#[pymethods]
impl Container {
    fn __iter__(slf: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;Py&lt;Iter&gt;&gt; {
        let iter = Iter {
            inner: slf.iter.clone().into_iter(),
        };
        Py::new(slf.py(), iter)
    }
}

<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let container = Container { iter: vec![1, 2, 3, 4] };
</span><span class="boring">    let inst = pyo3::Py::new(py, container).unwrap();
</span><span class="boring">    pyo3::py_run!(py, inst, "assert list(inst) == [1, 2, 3, 4]");
</span><span class="boring">    pyo3::py_run!(py, inst, "assert list(iter(iter(inst))) == [1, 2, 3, 4]");
</span><span class="boring">});</span></code></pre>
<p>For more details on Python's iteration protocols, check out <a href="https://docs.python.org/library/stdtypes.html#iterator-types">the "Iterator Types" section of the library
documentation</a>.</p>
<h4 id="returning-a-value-from-iteration"><a class="header" href="#returning-a-value-from-iteration">Returning a value from iteration</a></h4>
<p>This guide has so far shown how to use <code>Option&lt;T&gt;</code> to implement yielding values
during iteration.  In Python a generator can also return a value. To express
this in Rust, PyO3 provides the <a href="https://docs.rs/pyo3/0.21.2/pyo3/pyclass/enum.IterNextOutput.html"><code>IterNextOutput</code></a> enum to both <code>Yield</code> values
and <code>Return</code> a final value - see its docs for further details and an example.</p>
<h3 id="awaitable-objects"><a class="header" href="#awaitable-objects">Awaitable objects</a></h3>
<ul>
<li><code>__await__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__aiter__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__anext__(&lt;self&gt;) -&gt; Option&lt;object&gt; or IterANextOutput</code></li>
</ul>
<h3 id="mapping--sequence-types"><a class="header" href="#mapping--sequence-types">Mapping &amp; Sequence types</a></h3>
<p>The magic methods in this section can be used to implement Python container types. They are two main categories of container in Python: "mappings" such as <code>dict</code>, with arbitrary keys, and "sequences" such as <code>list</code> and <code>tuple</code>, with integer keys.</p>
<p>The Python C-API which PyO3 is built upon has separate "slots" for sequences and mappings. When writing a <code>class</code> in pure Python, there is no such distinction in the implementation - a <code>__getitem__</code> implementation will fill the slots for both the mapping and sequence forms, for example.</p>
<p>By default PyO3 reproduces the Python behaviour of filling both mapping and sequence slots. This makes sense for the "simple" case which matches Python, and also for sequences, where the mapping slot is used anyway to implement slice indexing.</p>
<p>Mapping types usually will not want the sequence slots filled. Having them filled will lead to outcomes which may be unwanted, such as:</p>
<ul>
<li>The mapping type will successfully cast to <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PySequence.html"><code>PySequence</code></a>. This may lead to consumers of the type handling it incorrectly.</li>
<li>Python provides a default implementation of <code>__iter__</code> for sequences, which calls <code>__getitem__</code> with consecutive positive integers starting from 0 until an <code>IndexError</code> is returned. Unless the mapping only contains consecutive positive integer keys, this <code>__iter__</code> implementation will likely not be the intended behavior.</li>
</ul>
<p>Use the <code>#[pyclass(mapping)]</code> annotation to instruct PyO3 to only fill the mapping slots, leaving the sequence ones empty. This will apply to <code>__getitem__</code>, <code>__setitem__</code>, and <code>__delitem__</code>.</p>
<p>Use the <code>#[pyclass(sequence)]</code> annotation to instruct PyO3 to fill the <code>sq_length</code> slot instead of the <code>mp_length</code> slot for <code>__len__</code>. This will help libraries such as <code>numpy</code> recognise the class as a sequence, however will also cause CPython to automatically add the sequence length to any negative indices before passing them to <code>__getitem__</code>. (<code>__getitem__</code>, <code>__setitem__</code> and <code>__delitem__</code> mapping slots are still used for sequences, for slice operations.)</p>
<ul>
<li>
<p><code>__len__(&lt;self&gt;) -&gt; usize</code></p>
<p>Implements the built-in function <code>len()</code>.</p>
</li>
<li>
<p><code>__contains__(&lt;self&gt;, object) -&gt; bool</code></p>
<p>Implements membership test operators.
Should return true if <code>item</code> is in <code>self</code>, false otherwise.
For objects that don’t define <code>__contains__()</code>, the membership test simply
traverses the sequence until it finds a match.</p>
<details>
<summary>Disabling Python's default contains</summary>
<p>By default, all <code>#[pyclass]</code> types with an <code>__iter__</code> method support a
default implementation of the <code>in</code> operator. Types which do not want this
can override this by setting <code>__contains__</code> to <code>None</code>. This is the same
mechanism as for a pure-Python class. This is done like so:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span>#[pyclass]
struct NoContains {}

#[pymethods]
impl NoContains {
    #[classattr]
    const __contains__: Option&lt;PyObject&gt; = None;
}</code></pre>
</details>
</li>
<li>
<p><code>__getitem__(&lt;self&gt;, object) -&gt; object</code></p>
<p>Implements retrieval of the <code>self[a]</code> element.</p>
<p><em>Note:</em> Negative integer indexes are not handled specially by PyO3.
However, for classes with <code>#[pyclass(sequence)]</code>, when a negative index is
accessed via <code>PySequence::get_item</code>, the underlying C API already adjusts
the index to be positive.</p>
</li>
<li>
<p><code>__setitem__(&lt;self&gt;, object, object) -&gt; ()</code></p>
<p>Implements assignment to the <code>self[a]</code> element.
Should only be implemented if elements can be replaced.</p>
<p>Same behavior regarding negative indices as for <code>__getitem__</code>.</p>
</li>
<li>
<p><code>__delitem__(&lt;self&gt;, object) -&gt; ()</code></p>
<p>Implements deletion of the <code>self[a]</code> element.
Should only be implemented if elements can be deleted.</p>
<p>Same behavior regarding negative indices as for <code>__getitem__</code>.</p>
</li>
</ul>
<ul>
<li>
<p><code>fn __concat__(&amp;self, other: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Concatenates two sequences.
Used by the <code>+</code> operator, after trying the numeric addition via
the <code>__add__</code> and <code>__radd__</code> methods.</p>
</li>
<li>
<p><code>fn __repeat__(&amp;self, count: isize) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Repeats the sequence <code>count</code> times.
Used by the <code>*</code> operator, after trying the numeric multiplication via
the <code>__mul__</code> and <code>__rmul__</code> methods.</p>
</li>
<li>
<p><code>fn __inplace_concat__(&amp;self, other: impl FromPyObject) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Concatenates two sequences.
Used by the <code>+=</code> operator, after trying the numeric addition via
the <code>__iadd__</code> method.</p>
</li>
<li>
<p><code>fn __inplace_repeat__(&amp;self, count: isize) -&gt; PyResult&lt;impl ToPyObject&gt;</code></p>
<p>Concatenates two sequences.
Used by the <code>*=</code> operator, after trying the numeric multiplication via
the <code>__imul__</code> method.</p>
</li>
</ul>
<h3 id="descriptors"><a class="header" href="#descriptors">Descriptors</a></h3>
<ul>
<li><code>__get__(&lt;self&gt;, object, object) -&gt; object</code></li>
<li><code>__set__(&lt;self&gt;, object, object) -&gt; ()</code></li>
<li><code>__delete__(&lt;self&gt;, object) -&gt; ()</code></li>
</ul>
<h3 id="numeric-types"><a class="header" href="#numeric-types">Numeric types</a></h3>
<p>Binary arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>divmod()</code>,
<code>pow()</code> and <code>**</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, and <code>|</code>) and their reflected versions:</p>
<p>(If the <code>object</code> is not of the type specified in the signature, the generated code
will automatically <code>return NotImplemented</code>.)</p>
<ul>
<li><code>__add__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__radd__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__sub__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rsub__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__mul__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rmul__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__matmul__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rmatmul__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__floordiv__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rfloordiv__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__truediv__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rtruediv__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__divmod__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rdivmod__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__mod__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rmod__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__lshift__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rlshift__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rshift__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rrshift__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__and__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rand__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__xor__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__rxor__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__or__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__ror__(&lt;self&gt;, object) -&gt; object</code></li>
<li><code>__pow__(&lt;self&gt;, object, object) -&gt; object</code></li>
<li><code>__rpow__(&lt;self&gt;, object, object) -&gt; object</code></li>
</ul>
<p>In-place assignment operations (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>@=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>,
<code>**=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>):</p>
<ul>
<li><code>__iadd__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__isub__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__imul__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__imatmul__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__itruediv__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__ifloordiv__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__imod__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__ipow__(&lt;self&gt;, object, object) -&gt; ()</code></li>
<li><code>__ilshift__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__irshift__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__iand__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__ixor__(&lt;self&gt;, object) -&gt; ()</code></li>
<li><code>__ior__(&lt;self&gt;, object) -&gt; ()</code></li>
</ul>
<p>Unary operations (<code>-</code>, <code>+</code>, <code>abs()</code> and <code>~</code>):</p>
<ul>
<li><code>__pos__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__neg__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__abs__(&lt;self&gt;) -&gt; object</code></li>
<li><code>__invert__(&lt;self&gt;) -&gt; object</code></li>
</ul>
<p>Coercions:</p>
<ul>
<li><code>__index__(&lt;self&gt;) -&gt; object (int)</code></li>
<li><code>__int__(&lt;self&gt;) -&gt; object (int)</code></li>
<li><code>__float__(&lt;self&gt;) -&gt; object (float)</code></li>
</ul>
<h3 id="buffer-objects"><a class="header" href="#buffer-objects">Buffer objects</a></h3>
<ul>
<li><code>__getbuffer__(&lt;self&gt;, *mut ffi::Py_buffer, flags) -&gt; ()</code></li>
<li><code>__releasebuffer__(&lt;self&gt;, *mut ffi::Py_buffer) -&gt; ()</code>
Errors returned from <code>__releasebuffer__</code> will be sent to <code>sys.unraiseablehook</code>. It is strongly advised to never return an error from <code>__releasebuffer__</code>, and if it really is necessary, to make best effort to perform any required freeing operations before returning. <code>__releasebuffer__</code> will not be called a second time; anything not freed will be leaked.</li>
</ul>
<h3 id="garbage-collector-integration"><a class="header" href="#garbage-collector-integration">Garbage Collector Integration</a></h3>
<p>If your type owns references to other Python objects, you will need to integrate
with Python's garbage collector so that the GC is aware of those references.  To
do this, implement the two methods <code>__traverse__</code> and <code>__clear__</code>.  These
correspond to the slots <code>tp_traverse</code> and <code>tp_clear</code> in the Python C API.
<code>__traverse__</code> must call <code>visit.call()</code> for each reference to another Python
object.  <code>__clear__</code> must clear out any mutable references to other Python
objects (thus breaking reference cycles). Immutable references do not have to be
cleared, as every cycle must contain at least one mutable reference.</p>
<ul>
<li><code>__traverse__(&lt;self&gt;, pyo3::class::gc::PyVisit&lt;'_&gt;) -&gt; Result&lt;(), pyo3::class::gc::PyTraverseError&gt;</code></li>
<li><code>__clear__(&lt;self&gt;) -&gt; ()</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::PyTraverseError;
use pyo3::gc::PyVisit;

#[pyclass]
struct ClassWithGCSupport {
    obj: Option&lt;PyObject&gt;,
}

#[pymethods]
impl ClassWithGCSupport {
    fn __traverse__(&amp;self, visit: PyVisit&lt;'_&gt;) -&gt; Result&lt;(), PyTraverseError&gt; {
        if let Some(obj) = &amp;self.obj {
            visit.call(obj)?
        }
        Ok(())
    }

    fn __clear__(&amp;mut self) {
        // Clear reference, this decrements ref counter.
        self.obj = None;
    }
}</code></pre>
<p>Usually, an implementation of <code>__traverse__</code> should do nothing but calls to <code>visit.call</code>.
Most importantly, safe access to the GIL is prohibited inside implementations of <code>__traverse__</code>,
i.e. <code>Python::with_gil</code> will panic.</p>
<blockquote>
<p>Note: these methods are part of the C API, PyPy does not necessarily honor them. If you are building for PyPy you should measure memory consumption to make sure you do not have runaway memory growth. See <a href="https://github.com/pypy/pypy/issues/3848">this issue on the PyPy bug tracker</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-object-customization-1"><a class="header" href="#basic-object-customization-1">Basic object customization</a></h1>
<p>Recall the <code>Number</code> class from the previous chapter:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

#[pyclass]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -&gt; Self {
        Self(value)
    }
}

#[pymodule]
fn my_module(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Number&gt;()?;
    Ok(())
}</code></pre>
<p>At this point Python code can import the module, access the class and create class instances - but
nothing else.</p>
<pre><code class="language-python">from my_module import Number

n = Number(5)
print(n)
</code></pre>
<pre><code class="language-text">&lt;builtins.Number object at 0x000002B4D185D7D0&gt;
</code></pre>
<h3 id="string-representations"><a class="header" href="#string-representations">String representations</a></h3>
<p>It can't even print an user-readable representation of itself! We can fix that by defining the
<code>__repr__</code> and <code>__str__</code> methods inside a <code>#[pymethods]</code> block. We do this by accessing the value
contained inside <code>Number</code>.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    // For `__repr__` we want to return a string that Python code could use to recreate
    // the `Number`, like `Number(5)` for example.
    fn __repr__(&amp;self) -&gt; String {
        // We use the `format!` macro to create a string. Its first argument is a
        // format string, followed by any number of parameters which replace the
        // `{}`'s in the format string.
        //
        //                       👇 Tuple field access in Rust uses a dot
        format!("Number({})", self.0)
    }
    // `__str__` is generally used to create an "informal" representation, so we
    // just forward to `i32`'s `ToString` trait implementation to print a bare number.
    fn __str__(&amp;self) -&gt; String {
        self.0.to_string()
    }
}</code></pre>
<h4 id="accessing-the-class-name"><a class="header" href="#accessing-the-class-name">Accessing the class name</a></h4>
<p>In the <code>__repr__</code>, we used a hard-coded class name. This is sometimes not ideal,
because if the class is subclassed in Python, we would like the repr to reflect
the subclass name. This is typically done in Python code by accessing
<code>self.__class__.__name__</code>. In order to be able to access the Python type information
<em>and</em> the Rust struct, we need to use a <code>Bound</code> as the <code>self</code> argument.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __repr__(slf: &amp;Bound&lt;'_, Self&gt;) -&gt; PyResult&lt;String&gt; {
        // This is the equivalent of `self.__class__.__name__` in Python.
        let class_name: String = slf.get_type().qualname()?;
        // To access fields of the Rust struct, we need to borrow the `PyCell`.
        Ok(format!("{}({})", class_name, slf.borrow().0))
    }
}</code></pre>
<h3 id="hashing"><a class="header" href="#hashing">Hashing</a></h3>
<p>Let's also implement hashing. We'll just hash the <code>i32</code>. For that we need a <a href="https://doc.rust-lang.org/std/hash/trait.Hasher.html"><code>Hasher</code></a>. The one
provided by <code>std</code> is <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html"><code>DefaultHasher</code></a>, which uses the <a href="https://en.wikipedia.org/wiki/SipHash">SipHash</a> algorithm.</p>
<pre><code class="language-rust">use std::collections::hash_map::DefaultHasher;

// Required to call the `.hash` and `.finish` methods, which are defined on traits.
use std::hash::{Hash, Hasher};

<span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __hash__(&amp;self) -&gt; u64 {
        let mut hasher = DefaultHasher::new();
        self.0.hash(&amp;mut hasher);
        hasher.finish()
    }
}</code></pre>
<blockquote>
<p><strong>Note</strong>: When implementing <code>__hash__</code> and comparisons, it is important that the following property holds:</p>
<pre><code class="language-text">k1 == k2 -&gt; hash(k1) == hash(k2)
</code></pre>
<p>In other words, if two keys are equal, their hashes must also be equal. In addition you must take
care that your classes' hash doesn't change during its lifetime. In this tutorial we do that by not
letting Python code change our <code>Number</code> class. In other words, it is immutable.</p>
<p>By default, all <code>#[pyclass]</code> types have a default hash implementation from Python.
Types which should not be hashable can override this by setting <code>__hash__</code> to None.
This is the same mechanism as for a pure-Python class. This is done like so:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct NotHashable {}

#[pymethods]
impl NotHashable {
    #[classattr]
    const __hash__: Option&lt;Py&lt;PyAny&gt;&gt; = None;
}</code></pre>
</blockquote>
<h3 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h3>
<p>PyO3 supports the usual magic comparison methods available in Python such as <code>__eq__</code>, <code>__lt__</code>
and so on. It is also possible to support all six operations at once with <code>__richcmp__</code>.
This method will be called with a value of <code>CompareOp</code> depending on the operation.</p>
<pre><code class="language-rust">use pyo3::class::basic::CompareOp;

<span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __richcmp__(&amp;self, other: &amp;Self, op: CompareOp) -&gt; PyResult&lt;bool&gt; {
        match op {
            CompareOp::Lt =&gt; Ok(self.0 &lt; other.0),
            CompareOp::Le =&gt; Ok(self.0 &lt;= other.0),
            CompareOp::Eq =&gt; Ok(self.0 == other.0),
            CompareOp::Ne =&gt; Ok(self.0 != other.0),
            CompareOp::Gt =&gt; Ok(self.0 &gt; other.0),
            CompareOp::Ge =&gt; Ok(self.0 &gt;= other.0),
        }
    }
}</code></pre>
<p>If you obtain the result by comparing two Rust values, as in this example, you
can take a shortcut using <code>CompareOp::matches</code>:</p>
<pre><code class="language-rust">use pyo3::class::basic::CompareOp;

<span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __richcmp__(&amp;self, other: &amp;Self, op: CompareOp) -&gt; bool {
        op.matches(self.0.cmp(&amp;other.0))
    }
}</code></pre>
<p>It checks that the <code>std::cmp::Ordering</code> obtained from Rust's <code>Ord</code> matches
the given <code>CompareOp</code>.</p>
<p>Alternatively, you can implement just equality using <code>__eq__</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __eq__(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 == other.0
    }
}

<span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let x = &amp;Bound::new(py, Number(4))?;
</span><span class="boring">        let y = &amp;Bound::new(py, Number(4))?;
</span><span class="boring">        assert!(x.eq(y)?);
</span><span class="boring">        assert!(!x.ne(y)?);
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h3 id="truthyness"><a class="header" href="#truthyness">Truthyness</a></h3>
<p>We'll consider <code>Number</code> to be <code>True</code> if it is nonzero:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __bool__(&amp;self) -&gt; bool {
        self.0 != 0
    }
}</code></pre>
<h3 id="final-code"><a class="header" href="#final-code">Final code</a></h3>
<pre><code class="language-rust">use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

use pyo3::prelude::*;
use pyo3::class::basic::CompareOp;

#[pyclass]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -&gt; Self {
        Self(value)
    }

    fn __repr__(slf: &amp;Bound&lt;'_, Self&gt;) -&gt; PyResult&lt;String&gt; {
        let class_name: String = slf.get_type().qualname()?;
        Ok(format!("{}({})", class_name, slf.borrow().0))
    }

    fn __str__(&amp;self) -&gt; String {
        self.0.to_string()
    }

    fn __hash__(&amp;self) -&gt; u64 {
        let mut hasher = DefaultHasher::new();
        self.0.hash(&amp;mut hasher);
        hasher.finish()
    }

    fn __richcmp__(&amp;self, other: &amp;Self, op: CompareOp) -&gt; PyResult&lt;bool&gt; {
        match op {
            CompareOp::Lt =&gt; Ok(self.0 &lt; other.0),
            CompareOp::Le =&gt; Ok(self.0 &lt;= other.0),
            CompareOp::Eq =&gt; Ok(self.0 == other.0),
            CompareOp::Ne =&gt; Ok(self.0 != other.0),
            CompareOp::Gt =&gt; Ok(self.0 &gt; other.0),
            CompareOp::Ge =&gt; Ok(self.0 &gt;= other.0),
        }
    }

    fn __bool__(&amp;self) -&gt; bool {
        self.0 != 0
    }
}

#[pymodule]
fn my_module(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Number&gt;()?;
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="emulating-numeric-types"><a class="header" href="#emulating-numeric-types">Emulating numeric types</a></h1>
<p>At this point we have a <code>Number</code> class that we can't actually do any math on!</p>
<p>Before proceeding, we should think about how we want to handle overflows. There are three obvious solutions:</p>
<ul>
<li>We can have infinite precision just like Python's <code>int</code>. However that would be quite boring - we'd
be reinventing the wheel.</li>
<li>We can raise exceptions whenever <code>Number</code> overflows, but that makes the API painful to use.</li>
<li>We can wrap around the boundary of <code>i32</code>. This is the approach we'll take here. To do that we'll just forward to <code>i32</code>'s
<code>wrapping_*</code> methods.</li>
</ul>
<h3 id="fixing-our-constructor"><a class="header" href="#fixing-our-constructor">Fixing our constructor</a></h3>
<p>Let's address the first overflow, in <code>Number</code>'s constructor:</p>
<pre><code class="language-python">from my_module import Number

n = Number(1 &lt;&lt; 1337)
</code></pre>
<pre><code class="language-text">Traceback (most recent call last):
  File "example.py", line 3, in &lt;module&gt;
    n = Number(1 &lt;&lt; 1337)
OverflowError: Python int too large to convert to C long
</code></pre>
<p>Instead of relying on the default <a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> extraction to parse arguments, we can specify our
own extraction function, using the <code>#[pyo3(from_py_with = "...")]</code> attribute. Unfortunately PyO3
doesn't provide a way to wrap Python integers out of the box, but we can do a Python call to mask it
and cast it to an <code>i32</code>.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

fn wrap(obj: &amp;Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;i32&gt; {
    let val = obj.call_method1("__and__", (0xFFFFFFFF_u32,))?;
    let val: u32 = val.extract()?;
    //     👇 This intentionally overflows!
    Ok(val as i32)
}</code></pre>
<p>We also add documentation, via <code>///</code> comments, which are visible to Python users.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

fn wrap(obj: &amp;Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;i32&gt; {
    let val = obj.call_method1("__and__", (0xFFFFFFFF_u32,))?;
    let val: u32 = val.extract()?;
    Ok(val as i32)
}

/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.
/// It's not a story C would tell you. It's a Rust legend.
#[pyclass(module = "my_module")]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(#[pyo3(from_py_with = "wrap")] value: i32) -&gt; Self {
        Self(value)
    }
}</code></pre>
<p>With that out of the way, let's implement some operators:</p>
<pre><code class="language-rust">use pyo3::exceptions::{PyZeroDivisionError, PyValueError};

<span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __add__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_add(other.0))
    }

    fn __sub__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_sub(other.0))
    }

    fn __mul__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_mul(other.0))
    }

    fn __truediv__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match self.0.checked_div(other.0) {
            Some(i) =&gt; Ok(Self(i)),
            None =&gt; Err(PyZeroDivisionError::new_err("division by zero")),
        }
    }

    fn __floordiv__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match self.0.checked_div(other.0) {
            Some(i) =&gt; Ok(Self(i)),
            None =&gt; Err(PyZeroDivisionError::new_err("division by zero")),
        }
    }

    fn __rshift__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match other.0.try_into() {
            Ok(rhs) =&gt; Ok(Self(self.0.wrapping_shr(rhs))),
            Err(_) =&gt; Err(PyValueError::new_err("negative shift count")),
        }
    }

    fn __lshift__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match other.0.try_into() {
            Ok(rhs) =&gt; Ok(Self(self.0.wrapping_shl(rhs))),
            Err(_) =&gt; Err(PyValueError::new_err("negative shift count")),
        }
    }
}</code></pre>
<h3 id="unary-arithmetic-operations"><a class="header" href="#unary-arithmetic-operations">Unary arithmetic operations</a></h3>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    fn __pos__(slf: PyRef&lt;'_, Self&gt;) -&gt; PyRef&lt;'_, Self&gt; {
        slf
    }

    fn __neg__(&amp;self) -&gt; Self {
        Self(-self.0)
    }

    fn __abs__(&amp;self) -&gt; Self {
        Self(self.0.abs())
    }

    fn __invert__(&amp;self) -&gt; Self {
        Self(!self.0)
    }
}</code></pre>
<h3 id="support-for-the-complex-int-and-float-built-in-functions"><a class="header" href="#support-for-the-complex-int-and-float-built-in-functions">Support for the <code>complex()</code>, <code>int()</code> and <code>float()</code> built-in functions.</a></h3>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>use pyo3::types::PyComplex;

#[pymethods]
impl Number {
    fn __int__(&amp;self) -&gt; i32 {
        self.0
    }

    fn __float__(&amp;self) -&gt; f64 {
        self.0 as f64
    }

    fn __complex__&lt;'py&gt;(&amp;self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'py, PyComplex&gt; {
        PyComplex::from_doubles_bound(py, self.0 as f64, 0.0)
    }
}</code></pre>
<p>We do not implement the in-place operations like <code>__iadd__</code> because we do not wish to mutate <code>Number</code>.
Similarly we're not interested in supporting operations with different types, so we do not implement
the reflected operations like <code>__radd__</code> either.</p>
<p>Now Python can use our <code>Number</code> class:</p>
<pre><code class="language-python">from my_module import Number

def hash_djb2(s: str):
	'''
	A version of Daniel J. Bernstein's djb2 string hashing algorithm
	Like many hashing algorithms, it relies on integer wrapping.
	'''

	n = Number(0)
	five = Number(5)

	for x in s:
		n = Number(ord(x)) + ((n &lt;&lt; five) - n)
	return n

assert hash_djb2('l50_50') == Number(-1152549421)
</code></pre>
<h3 id="final-code-1"><a class="header" href="#final-code-1">Final code</a></h3>
<pre><code class="language-rust">use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

use pyo3::exceptions::{PyValueError, PyZeroDivisionError};
use pyo3::prelude::*;
use pyo3::class::basic::CompareOp;
use pyo3::types::PyComplex;

fn wrap(obj: &amp;Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;i32&gt; {
    let val = obj.call_method1("__and__", (0xFFFFFFFF_u32,))?;
    let val: u32 = val.extract()?;
    Ok(val as i32)
}
/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.
/// It's not a story C would tell you. It's a Rust legend.
#[pyclass(module = "my_module")]
struct Number(i32);

#[pymethods]
impl Number {
    #[new]
    fn new(#[pyo3(from_py_with = "wrap")] value: i32) -&gt; Self {
        Self(value)
    }

    fn __repr__(slf: &amp;Bound&lt;'_, Self&gt;) -&gt; PyResult&lt;String&gt; {
       // Get the class name dynamically in case `Number` is subclassed
       let class_name: String = slf.get_type().qualname()?;
        Ok(format!("{}({})", class_name, slf.borrow().0))
    }

    fn __str__(&amp;self) -&gt; String {
        self.0.to_string()
    }

    fn __hash__(&amp;self) -&gt; u64 {
        let mut hasher = DefaultHasher::new();
        self.0.hash(&amp;mut hasher);
        hasher.finish()
    }

    fn __richcmp__(&amp;self, other: &amp;Self, op: CompareOp) -&gt; PyResult&lt;bool&gt; {
        match op {
            CompareOp::Lt =&gt; Ok(self.0 &lt; other.0),
            CompareOp::Le =&gt; Ok(self.0 &lt;= other.0),
            CompareOp::Eq =&gt; Ok(self.0 == other.0),
            CompareOp::Ne =&gt; Ok(self.0 != other.0),
            CompareOp::Gt =&gt; Ok(self.0 &gt; other.0),
            CompareOp::Ge =&gt; Ok(self.0 &gt;= other.0),
        }
    }

    fn __bool__(&amp;self) -&gt; bool {
        self.0 != 0
    }

    fn __add__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_add(other.0))
    }

    fn __sub__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_sub(other.0))
    }

    fn __mul__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0.wrapping_mul(other.0))
    }

    fn __truediv__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match self.0.checked_div(other.0) {
            Some(i) =&gt; Ok(Self(i)),
            None =&gt; Err(PyZeroDivisionError::new_err("division by zero")),
        }
    }

    fn __floordiv__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match self.0.checked_div(other.0) {
            Some(i) =&gt; Ok(Self(i)),
            None =&gt; Err(PyZeroDivisionError::new_err("division by zero")),
        }
    }

    fn __rshift__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match other.0.try_into() {
            Ok(rhs) =&gt; Ok(Self(self.0.wrapping_shr(rhs))),
            Err(_) =&gt; Err(PyValueError::new_err("negative shift count")),
        }
    }

    fn __lshift__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        match other.0.try_into() {
            Ok(rhs) =&gt; Ok(Self(self.0.wrapping_shl(rhs))),
            Err(_) =&gt; Err(PyValueError::new_err("negative shift count")),
        }
    }

    fn __xor__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0 ^ other.0)
    }

    fn __or__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0 | other.0)
    }

    fn __and__(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0 &amp; other.0)
    }

    fn __int__(&amp;self) -&gt; i32 {
        self.0
    }

    fn __float__(&amp;self) -&gt; f64 {
        self.0 as f64
    }

    fn __complex__&lt;'py&gt;(&amp;self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'py, PyComplex&gt; {
        PyComplex::from_doubles_bound(py, self.0 as f64, 0.0)
    }
}

#[pymodule]
fn my_module(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;Number&gt;()?;
    Ok(())
}
<span class="boring">const SCRIPT: &amp;'static str = r#"
</span><span class="boring">def hash_djb2(s: str):
</span><span class="boring">    n = Number(0)
</span><span class="boring">    five = Number(5)
</span><span class="boring">
</span><span class="boring">    for x in s:
</span><span class="boring">        n = Number(ord(x)) + ((n &lt;&lt; five) - n)
</span><span class="boring">    return n
</span><span class="boring">
</span><span class="boring">assert hash_djb2('l50_50') == Number(-1152549421)
</span><span class="boring">assert hash_djb2('logo') == Number(3327403)
</span><span class="boring">assert hash_djb2('horizon') == Number(1097468315)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">assert Number(2) + Number(2) == Number(4)
</span><span class="boring">assert Number(2) + Number(2) != Number(5)
</span><span class="boring">
</span><span class="boring">assert Number(13) - Number(7) == Number(6)
</span><span class="boring">assert Number(13) - Number(-7) == Number(20)
</span><span class="boring">
</span><span class="boring">assert Number(13) / Number(7) == Number(1)
</span><span class="boring">assert Number(13) // Number(7) == Number(1)
</span><span class="boring">
</span><span class="boring">assert Number(13) * Number(7) == Number(13*7)
</span><span class="boring">
</span><span class="boring">assert Number(13) &gt; Number(7)
</span><span class="boring">assert Number(13) &lt; Number(20)
</span><span class="boring">assert Number(13) == Number(13)
</span><span class="boring">assert Number(13) &gt;= Number(7)
</span><span class="boring">assert Number(13) &lt;= Number(20)
</span><span class="boring">assert Number(13) == Number(13)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">assert (True if Number(1) else False)
</span><span class="boring">assert (False if Number(0) else True)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">assert int(Number(13)) == 13
</span><span class="boring">assert float(Number(13)) == 13
</span><span class="boring">assert Number.__doc__ == "Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.\nIt's not a story C would tell you. It's a Rust legend."
</span><span class="boring">assert Number(12345234523452) == Number(1498514748)
</span><span class="boring">try:
</span><span class="boring">    import inspect
</span><span class="boring">    assert inspect.signature(Number).__str__() == '(value)'
</span><span class="boring">except ValueError:
</span><span class="boring">    # Not supported with `abi3` before Python 3.10
</span><span class="boring">    pass
</span><span class="boring">assert Number(1337).__str__() == '1337'
</span><span class="boring">assert Number(1337).__repr__() == 'Number(1337)'
</span>"#;

<span class="boring">
</span><span class="boring">use pyo3::PyTypeInfo;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let globals = PyModule::import_bound(py, "__main__")?.dict();
</span><span class="boring">        globals.set_item("Number", Number::type_object_bound(py))?;
</span><span class="boring">
</span><span class="boring">        py.run_bound(SCRIPT, Some(&amp;globals), None)?;
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h2 id="appendix-writing-some-unsafe-code"><a class="header" href="#appendix-writing-some-unsafe-code">Appendix: Writing some unsafe code</a></h2>
<p>At the beginning of this chapter we said that PyO3 doesn't provide a way to wrap Python integers out
of the box but that's a half truth. There's not a PyO3 API for it, but there's a Python C API
function that does:</p>
<pre><code class="language-c">unsigned long PyLong_AsUnsignedLongMask(PyObject *obj)
</code></pre>
<p>We can call this function from Rust by using <a href="https://docs.rs/pyo3/0.21.2/pyo3/ffi/fn.PyLong_AsUnsignedLongMask.html"><code>pyo3::ffi::PyLong_AsUnsignedLongMask</code></a>. This is an <em>unsafe</em>
function, which means we have to use an unsafe block to call it and take responsibility for upholding
the contracts of this function. Let's review those contracts:</p>
<ul>
<li>The GIL must be held. If it's not, calling this function causes a data race.</li>
<li>The pointer must be valid, i.e. it must be properly aligned and point to a valid Python object.</li>
</ul>
<p>Let's create that helper function. The signature has to be <code>fn(&amp;Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;T&gt;</code>.</p>
<ul>
<li><code>&amp;Bound&lt;'_, PyAny&gt;</code> represents a checked borrowed reference, so the pointer derived from it is valid (and not null).</li>
<li>Whenever we have borrowed references to Python objects in scope, it is guaranteed that the GIL is held. This reference is also where we can get a <a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html"><code>Python</code></a> token to use in our call to <a href="https://docs.rs/pyo3/0.21.2/pyo3/prelude/struct.PyErr.html#method.take"><code>PyErr::take</code></a>.</li>
</ul>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use std::os::raw::c_ulong;
use pyo3::prelude::*;
use pyo3::ffi;

fn wrap(obj: &amp;Bound&lt;'_, PyAny&gt;) -&gt; Result&lt;i32, PyErr&gt; {
    let py: Python&lt;'_&gt; = obj.py();

    unsafe {
        let ptr = obj.as_ptr();

        let ret: c_ulong = ffi::PyLong_AsUnsignedLongMask(ptr);
        if ret == c_ulong::MAX {
            if let Some(err) = PyErr::take(py) {
                return Err(err);
            }
        }

        Ok(ret as i32)
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="emulating-callable-objects"><a class="header" href="#emulating-callable-objects">Emulating callable objects</a></h1>
<p>Classes can be callable if they have a <code>#[pymethod]</code> named <code>__call__</code>.
This allows instances of a class to behave similar to functions.</p>
<p>This method's signature must look like <code>__call__(&lt;self&gt;, ...) -&gt; object</code> - here,
any argument list can be defined as for normal pymethods</p>
<h3 id="example-implementing-a-call-counter"><a class="header" href="#example-implementing-a-call-counter">Example: Implementing a call counter</a></h3>
<p>The following pyclass is a basic decorator - its constructor takes a Python object
as argument and calls that object when called. An equivalent Python implementation
is linked at the end.</p>
<p>An example crate containing this pyclass can be found <a href="https://github.com/PyO3/pyo3/tree/main/examples/decorator">here</a></p>
<pre><code class="language-rust ignore">use pyo3::prelude::*;
use pyo3::types::{PyDict, PyTuple};
use std::cell::Cell;

/// A function decorator that keeps track how often it is called.
///
/// It otherwise doesn't do anything special.
#[pyclass(name = "Counter")]
pub struct PyCounter {
    // Keeps track of how many calls have gone through.
    //
    // See the discussion at the end for why `Cell` is used.
    count: Cell&lt;u64&gt;,

    // This is the actual function being wrapped.
    wraps: Py&lt;PyAny&gt;,
}

#[pymethods]
impl PyCounter {
    // Note that we don't validate whether `wraps` is actually callable.
    //
    // While we could use `PyAny::is_callable` for that, it has some flaws:
    //    1. It doesn't guarantee the object can actually be called successfully
    //    2. We still need to handle any exceptions that the function might raise
    #[new]
    fn __new__(wraps: Py&lt;PyAny&gt;) -&gt; Self {
        PyCounter {
            count: Cell::new(0),
            wraps,
        }
    }

    #[getter]
    fn count(&amp;self) -&gt; u64 {
        self.count.get()
    }

    #[pyo3(signature = (*args, **kwargs))]
    fn __call__(
        &amp;self,
        py: Python&lt;'_&gt;,
        args: &amp;Bound&lt;'_, PyTuple&gt;,
        kwargs: Option&lt;&amp;Bound&lt;'_, PyDict&gt;&gt;,
    ) -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {
        let old_count = self.count.get();
        let new_count = old_count + 1;
        self.count.set(new_count);
        let name = self.wraps.getattr(py, "__name__")?;

        println!("{} has been called {} time(s).", name, new_count);

        // After doing something, we finally forward the call to the wrapped function
        let ret = self.wraps.call_bound(py, args, kwargs)?;

        // We could do something with the return value of
        // the function before returning it
        Ok(ret)
    }
}

#[pymodule]
pub fn decorator(module: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    module.add_class::&lt;PyCounter&gt;()?;
    Ok(())
}</code></pre>
<p>Python code:</p>
<pre><code class="language-python">from decorator import Counter


@Counter
def say_hello():
    print("hello")


say_hello()
say_hello()
say_hello()
say_hello()

assert say_hello.count == 4
</code></pre>
<p>Output:</p>
<pre><code class="language-text">say_hello has been called 1 time(s).
hello
say_hello has been called 2 time(s).
hello
say_hello has been called 3 time(s).
hello
say_hello has been called 4 time(s).
hello
</code></pre>
<h3 id="pure-python-implementation"><a class="header" href="#pure-python-implementation">Pure Python implementation</a></h3>
<p>A Python implementation of this looks similar to the Rust version:</p>
<pre><code class="language-python">class Counter:
    def __init__(self, wraps):
        self.count = 0
        self.wraps = wraps

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"{self.wraps.__name__} has been called {self.count} time(s)")
        self.wraps(*args, **kwargs)
</code></pre>
<p>Note that it can also be implemented as a higher order function:</p>
<pre><code class="language-python">def Counter(wraps):
    count = 0
    def call(*args, **kwargs):
        nonlocal count
        count += 1
        print(f"{wraps.__name__} has been called {count} time(s)")
        return wraps(*args, **kwargs)
    return call
</code></pre>
<h3 id="what-is-the-cell-for"><a class="header" href="#what-is-the-cell-for">What is the <code>Cell</code> for?</a></h3>
<p>A <a href="https://github.com/PyO3/pyo3/discussions/2598" title="Thread Safe Decorator &lt;Help Wanted&gt; · Discussion #2598 · PyO3/pyo3">previous implementation</a> used a normal <code>u64</code>, which meant it required a <code>&amp;mut self</code> receiver to update the count:</p>
<pre><code class="language-rust ignore">#[pyo3(signature = (*args, **kwargs))]
fn __call__(
    &amp;mut self,
    py: Python&lt;'_&gt;,
    args: &amp;Bound&lt;'_, PyTuple&gt;,
    kwargs: Option&lt;&amp;Bound&lt;'_, PyDict&gt;&gt;,
) -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {
    self.count += 1;
    let name = self.wraps.getattr(py, "__name__")?;

    println!("{} has been called {} time(s).", name, self.count);

    // After doing something, we finally forward the call to the wrapped function
    let ret = self.wraps.call(py, args, kwargs)?;

    // We could do something with the return value of
    // the function before returning it
    Ok(ret)
}</code></pre>
<p>The problem with this is that the <code>&amp;mut self</code> receiver means PyO3 has to borrow it exclusively,
and hold this borrow across the<code>self.wraps.call(py, args, kwargs)</code> call. This call returns control to the user's Python code
which is free to call arbitrary things, <em>including</em> the decorated function. If that happens PyO3 is unable to create a second unique borrow and will be forced to raise an exception.</p>
<p>As a result, something innocent like this will raise an exception:</p>
<pre><code class="language-py">@Counter
def say_hello():
    if say_hello.count &lt; 2:
        print(f"hello from decorator")

say_hello()
# RuntimeError: Already borrowed
</code></pre>
<p>The implementation in this chapter fixes that by never borrowing exclusively; all the methods take <code>&amp;self</code> as receivers, of which multiple may exist simultaneously. This requires a shared counter and the easiest way to do that is to use <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html" title="Cell in std::cell - Rust"><code>Cell</code></a>, so that's what is used here.</p>
<p>This shows the dangers of running arbitrary Python code - note that "running arbitrary Python code" can be far more subtle than the example above:</p>
<ul>
<li>Python's asynchronous executor may park the current thread in the middle of Python code, even in Python code that <em>you</em> control, and let other Python code run.</li>
<li>Dropping arbitrary Python objects may invoke destructors defined in Python (<code>__del__</code> methods).</li>
<li>Calling Python's C-api (most PyO3 apis call C-api functions internally) may raise exceptions, which may allow Python code in signal handlers to run.</li>
</ul>
<p>This is especially important if you are writing unsafe code; Python code must never be able to cause undefined behavior. You must ensure that your Rust code is in a consistent state before doing any of the above things.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-python-in-rust-code"><a class="header" href="#calling-python-in-rust-code">Calling Python in Rust code</a></h1>
<p>This chapter of the guide documents some ways to interact with Python code from Rust.</p>
<p>Below is an introduction to the <code>'py</code> lifetime and some general remarks about how PyO3's API reasons about Python code.</p>
<p>The subchapters also cover the following topics:</p>
<ul>
<li>Python object types available in PyO3's API</li>
<li>How to work with Python exceptions</li>
<li>How to call Python functions</li>
<li>How to execute existing Python code</li>
</ul>
<h2 id="the-py-lifetime"><a class="header" href="#the-py-lifetime">The <code>'py</code> lifetime</a></h2>
<p>To safely interact with the Python interpreter a Rust thread must have a corresponding Python thread state and hold the <a href="python-from-rust.html#the-global-interpreter-lock">Global Interpreter Lock (GIL)</a>. PyO3 has a <code>Python&lt;'py&gt;</code> token that is used to prove that these conditions
are met. Its lifetime <code>'py</code> is a central part of PyO3's API.</p>
<p>The <code>Python&lt;'py&gt;</code> token serves three purposes:</p>
<ul>
<li>It provides global APIs for the Python interpreter, such as [<code>py.eval_bound()</code>][eval] and [<code>py.import_bound()</code>][import].</li>
<li>It can be passed to functions that require a proof of holding the GIL, such as [<code>Py::clone_ref</code>][clone_ref].</li>
<li>Its lifetime <code>'py</code> is used to bind many of PyO3's types to the Python interpreter, such as [<code>Bound&lt;'py, T&gt;</code>][Bound].</li>
</ul>
<p>PyO3's types that are bound to the <code>'py</code> lifetime, for example <code>Bound&lt;'py, T&gt;</code>, all contain a <code>Python&lt;'py&gt;</code> token. This means they have full access to the Python interpreter and offer a complete API for interacting with Python objects.</p>
<p>Consult <a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#obtaining-a-python-token">PyO3's API documentation</a> to learn how to acquire one of these tokens.</p>
<h3 id="the-global-interpreter-lock"><a class="header" href="#the-global-interpreter-lock">The Global Interpreter Lock</a></h3>
<p>Concurrent programming in Python is aided by the Global Interpreter Lock (GIL), which ensures that only one Python thread can use the Python interpreter and its API at the same time. This allows it to be used to synchronize code. See the <a href="https://docs.rs/pyo3/0.21.2/pyo3/sync/index.html"><code>pyo3::sync</code></a> module for synchronization tools PyO3 offers that are based on the GIL's guarantees.</p>
<p>Non-Python operations (system calls and native Rust code) can unlock the GIL. See <a href="parallelism.html">the section on parallelism</a> for how to do that using PyO3's API.</p>
<h2 id="pythons-memory-model"><a class="header" href="#pythons-memory-model">Python's memory model</a></h2>
<p>Python's memory model differs from Rust's memory model in two key ways:</p>
<ul>
<li>There is no concept of ownership; all Python objects are shared and usually implemented via reference counting</li>
<li>There is no concept of exclusive (<code>&amp;mut</code>) references; any reference can mutate a Python object</li>
</ul>
<p>PyO3's API reflects this by providing <a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">smart pointer</a> types, <code>Py&lt;T&gt;</code>, <code>Bound&lt;'py, T&gt;</code>, and (the very rarely used) <code>Borrowed&lt;'a, 'py, T&gt;</code>. These smart pointers all use Python reference counting. See the <a href="./types.html">subchapter on types</a> for more detail on these types.</p>
<p>Because of the lack of exclusive <code>&amp;mut</code> references, PyO3's APIs for Python objects, for example [<code>PyListMethods::append</code>], use shared references. This is safe because Python objects have internal mechanisms to prevent data races (as of time of writing, the Python GIL).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-object-types"><a class="header" href="#python-object-types">Python object types</a></h1>
<p>PyO3 offers two main sets of types to interact with Python objects. This section of the guide expands into detail about these types and how to choose which to use.</p>
<p>The first set of types is are the <a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">smart pointers</a> which all Python objects are wrapped in. These are <code>Py&lt;T&gt;</code>, <code>Bound&lt;'py, T&gt;</code>, and <code>Borrowed&lt;'a, 'py, T&gt;</code>. The <a href="types.html#pyo3s-smart-pointers">first section below</a> expands on each of these in detail and why there are three of them.</p>
<p>The second set of types are types which fill in the generic parameter <code>T</code> of the smart pointers. The most common is <code>PyAny</code>, which represents any Python object (similar to Python's <code>typing.Any</code>). There are also concrete types for many Python built-in types, such as <code>PyList</code>, <code>PyDict</code>, and <code>PyTuple</code>. User defined <code>#[pyclass]</code> types also fit this category. The <a href="types.html#concrete-python-types">second section below</a> expands on how to use these types.</p>
<p>Before PyO3 0.21, PyO3's main API to interact with Python objects was a deprecated API known as the "GIL Refs" API, containing reference types such as <code>&amp;PyAny</code>, <code>&amp;PyList</code>, and <code>&amp;PyCell&lt;T&gt;</code> for user-defined <code>#[pyclass]</code> types. The <a href="types.html#the-gil-refs-api">third section below</a> details this deprecated API.</p>
<h2 id="pyo3s-smart-pointers"><a class="header" href="#pyo3s-smart-pointers">PyO3's smart pointers</a></h2>
<p>PyO3's API offers three generic smart pointers: <code>Py&lt;T&gt;</code>, <code>Bound&lt;'py, T&gt;</code> and <code>Borrowed&lt;'a, 'py, T&gt;</code>. For each of these the type parameter <code>T</code> will be filled by a <a href="types.html#concrete-python-types">concrete Python type</a>. For example, a Python list object can be represented by <code>Py&lt;PyList&gt;</code>, <code>Bound&lt;'py, PyList&gt;</code>, and <code>Borrowed&lt;'a, 'py, PyList&gt;</code>.</p>
<p>These smart pointers behave differently due to their lifetime parameters. <code>Py&lt;T&gt;</code> has no lifetime parameters, <code>Bound&lt;'py, T&gt;</code> has <a href="./python-from-rust.html#the-py-lifetime">the <code>'py</code> lifetime</a> as a parameter, and <code>Borrowed&lt;'a, 'py, T&gt;</code> has the <code>'py</code> lifetime plus an additional lifetime <code>'a</code> to denote the lifetime it is borrowing data for. (You can read more about these lifetimes in the subsections below).</p>
<p>Python objects are reference counted, like <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a>. A major reason for these smart pointers is to bring Python's reference counting to a Rust API.</p>
<p>The recommendation of when to use each of these smart pointers is as follows:</p>
<ul>
<li>Use <code>Bound&lt;'py, T&gt;</code> for as much as possible, as it offers the most efficient and complete API.</li>
<li>Use <code>Py&lt;T&gt;</code> mostly just for storage inside Rust <code>struct</code>s which do not want to or can't add a lifetime parameter for <code>Bound&lt;'py, T&gt;</code>.</li>
<li><code>Borrowed&lt;'a, 'py, T&gt;</code> is almost never used. It is occasionally present at the boundary between Rust and the Python interpreter, for example when borrowing data from Python tuples (which is safe because they are immutable).</li>
</ul>
<p>The sections below also explain these smart pointers in a little more detail.</p>
<h3 id="pyt-and-pyobject"><a class="header" href="#pyt-and-pyobject"><code>Py&lt;T&gt;</code> (and <code>PyObject</code>)</a></h3>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.Py.html"><code>Py&lt;T&gt;</code></a> is the foundational smart pointer in PyO3's API. The type parameter <code>T</code> denotes the type of the Python object. Very frequently this is <code>PyAny</code>, meaning any Python object. This is so common that <code>Py&lt;PyAny&gt;</code> has a type alias <code>PyObject</code>.</p>
<p>Because <code>Py&lt;T&gt;</code> is not bound to <a href="./python-from-rust.html#the-py-lifetime">the <code>'py</code> lifetime</a>, it is the type to use when storing a Python object inside a Rust <code>struct</code> or <code>enum</code> which do not want to have a lifetime parameter. In particular, <a href="class.html"><code>#[pyclass]</code></a> types are not permitted to have a lifetime, so <code>Py&lt;T&gt;</code> is the correct type to store Python objects inside them.</p>
<p>The lack of binding to the <code>'py</code> lifetime also carries drawbacks:</p>
<ul>
<li>Almost all methods on <code>Py&lt;T&gt;</code> require a <code>Python&lt;'py&gt;</code> token as the first argument</li>
<li>Other functionality, such as <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>, needs to check at runtime for attachment to the Python GIL, at a small performance cost</li>
</ul>
<p>Because of the drawbacks <code>Bound&lt;'py, T&gt;</code> is preferred for many of PyO3's APIs. In particular, <code>Bound&lt;'py, T&gt;</code> is the better for function arguments.</p>
<p>To convert a <code>Py&lt;T&gt;</code> into a <code>Bound&lt;'py, T&gt;</code>, the <code>Py::bind</code> and <code>Py::into_bound</code> methods are available. <code>Bound&lt;'py, T&gt;</code> can be converted back into <code>Py&lt;T&gt;</code> using <a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.Bound.html#method.unbind"><code>Bound::unbind</code></a>.</p>
<h3 id="boundpy-t"><a class="header" href="#boundpy-t"><code>Bound&lt;'py, T&gt;</code></a></h3>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.Bound.html"><code>Bound&lt;'py, T&gt;</code></a> is the counterpart to <code>Py&lt;T&gt;</code> which is also bound to the <code>'py</code> lifetime. It can be thought of as equivalent to the Rust tuple <code>(Python&lt;'py&gt;, Py&lt;T&gt;)</code>.</p>
<p>By having the binding to the <code>'py</code> lifetime, <code>Bound&lt;'py, T&gt;</code> can offer the complete PyO3 API at maximum efficiency. This means that in almost all cases where <code>Py&lt;T&gt;</code> is not necessary for lifetime reasons, <code>Bound&lt;'py, T&gt;</code> should be used.</p>
<p><code>Bound&lt;'py, T&gt;</code> engages in Python reference counting. This means that <code>Bound&lt;'py, T&gt;</code> owns a Python object. Rust code which just wants to borrow a Python object should use a shared reference <code>&amp;Bound&lt;'py, T&gt;</code>. Just like <code>std::sync::Arc</code>, using <code>.clone()</code> and <code>drop()</code> will cheaply increment and decrement the reference count of the object (just in this case, the reference counting is implemented by the Python interpreter itself).</p>
<p>To give an example of how <code>Bound&lt;'py, T&gt;</code> is PyO3's primary API type, consider the following Python code:</p>
<pre><code class="language-python">def example():
    x = list()   # create a Python list
    x.append(1)  # append the integer 1 to it
    y = x        # create a second reference to the list
    del x        # delete the original reference
</code></pre>
<p>Using PyO3's API, and in particular <code>Bound&lt;'py, PyList&gt;</code>, this code translates into the following Rust code:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyList;

fn example&lt;'py&gt;(py: Python&lt;'py&gt;) -&gt; PyResult&lt;()&gt; {
    let x: Bound&lt;'py, PyList&gt; = PyList::empty_bound(py);
    x.append(1)?;
    let y: Bound&lt;'py, PyList&gt; = x.clone(); // y is a new reference to the same list
    drop(x); // release the original reference x
    Ok(())
}
<span class="boring">Python::with_gil(example).unwrap();</span></code></pre>
<p>Or, without the type annotations:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyList;

fn example(py: Python&lt;'_&gt;) -&gt; PyResult&lt;()&gt; {
    let x = PyList::empty_bound(py);
    x.append(1)?;
    let y = x.clone();
    drop(x);
    Ok(())
}
<span class="boring">Python::with_gil(example).unwrap();</span></code></pre>
<h4 id="function-argument-lifetimes"><a class="header" href="#function-argument-lifetimes">Function argument lifetimes</a></h4>
<p>Because the <code>'py</code> lifetime often appears in many function arguments as part of the <code>Bound&lt;'py, T&gt;</code> smart pointer, the Rust compiler will often require annotations of input and output lifetimes. This occurs when the function output has at least one lifetime, and there is more than one lifetime present on the inputs.</p>
<p>To demonstrate, consider this function which takes accepts Python objects and applies the <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.add">Python <code>+</code> operation</a> to them:</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>fn add(left: &amp;'_ Bound&lt;'_, PyAny&gt;, right: &amp;'_ Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;Bound&lt;'_, PyAny&gt;&gt; {
    left.add(right)
}</code></pre>
<p>Because the Python <code>+</code> operation might raise an exception, this function returns <code>PyResult&lt;Bound&lt;'_, PyAny&gt;&gt;</code>. It doesn't need ownership of the inputs, so it takes <code>&amp;Bound&lt;'_, PyAny&gt;</code> shared references. To demonstrate the point, all lifetimes have used the wildcard <code>'_</code> to allow the Rust compiler to attempt to infer them. Because there are four input lifetimes (two lifetimes of the shared references, and two <code>'py</code> lifetimes unnamed inside the <code>Bound&lt;'_, PyAny&gt;</code> pointers), the compiler cannot reason about which must be connected to the output.</p>
<p>The correct way to solve this is to add the <code>'py</code> lifetime as a parameter for the function, and name all the <code>'py</code> lifetimes inside the <code>Bound&lt;'py, PyAny&gt;</code> smart pointers. For the shared references, it's also fine to reduce <code>&amp;'_</code> to just <code>&amp;</code>. The working end result is below:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>fn add&lt;'py&gt;(
    left: &amp;Bound&lt;'py, PyAny&gt;,
    right: &amp;Bound&lt;'py, PyAny&gt;,
) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; {
    left.add(right)
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let s = pyo3::types::PyString::new_bound(py, "s");
</span><span class="boring">    assert!(add(&amp;s, &amp;s).unwrap().eq("ss").unwrap());
</span><span class="boring">})</span></code></pre>
<p>If naming the <code>'py</code> lifetime adds unwanted complexity to the function signature, it is also acceptable to return <code>PyObject</code> (aka <code>Py&lt;PyAny&gt;</code>), which has no lifetime. The cost is instead paid by a slight increase in implementation complexity, as seen by the introduction of a call to <a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.Bound.html#method.unbind"><code>Bound::unbind</code></a>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>fn add(left: &amp;Bound&lt;'_, PyAny&gt;, right: &amp;Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;PyObject&gt; {
    let output: Bound&lt;'_, PyAny&gt; = left.add(right)?;
    Ok(output.unbind())
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let s = pyo3::types::PyString::new_bound(py, "s");
</span><span class="boring">    assert!(add(&amp;s, &amp;s).unwrap().bind(py).eq("ss").unwrap());
</span><span class="boring">})</span></code></pre>
<h3 id="borroweda-py-t"><a class="header" href="#borroweda-py-t"><code>Borrowed&lt;'a, 'py, T&gt;</code></a></h3>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.Borrowed.html"><code>Borrowed&lt;'a, 'py, T&gt;</code></a> is an advanced type used just occasionally at the edge of interaction with the Python interpreter. It can be thought of as analogous to the shared reference <code>&amp;'a Bound&lt;'py, T&gt;</code>. The difference is that <code>Borrowed&lt;'a, 'py, T&gt;</code> is just a smart pointer rather than a reference-to-a-smart-pointer, which is a helpful reduction in indirection in specific interactions with the Python interpreter.</p>
<p><code>Borrowed&lt;'a, 'py, T&gt;</code> dereferences to <code>Bound&lt;'py, T&gt;</code>, so all methods on <code>Bound&lt;'py, T&gt;</code> are available on <code>Borrowed&lt;'a, 'py, T&gt;</code>.</p>
<p>An example where <code>Borrowed&lt;'a, 'py, T&gt;</code> is used is in <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyTupleMethods.html#tymethod.get_item"><code>PyTupleMethods::get_borrowed_item</code></a>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyTuple;

<span class="boring">fn example&lt;'py&gt;(py: Python&lt;'py&gt;) -&gt; PyResult&lt;()&gt; {
</span>// Create a new tuple with the elements (0, 1, 2)
let t = PyTuple::new_bound(py, [0, 1, 2]);
for i in 0..=2 {
    let entry: Borrowed&lt;'_, 'py, PyAny&gt; = t.get_borrowed_item(i)?;
    // `PyAnyMethods::extract` is available on `Borrowed`
    // via the dereference to `Bound`
    let value: usize = entry.extract()?;
    assert_eq!(i, value);
}
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">Python::with_gil(example).unwrap();</span></code></pre>
<h3 id="casting-between-smart-pointer-types"><a class="header" href="#casting-between-smart-pointer-types">Casting between smart pointer types</a></h3>
<p>To convert between <code>Py&lt;T&gt;</code> and <code>Bound&lt;'py, T&gt;</code> use the <code>bind()</code> / <code>into_bound()</code> methods. Use the <code>as_unbound()</code> / <code>unbind()</code> methods to go back from <code>Bound&lt;'py, T&gt;</code> to <code>Py&lt;T&gt;</code>.</p>
<pre><code class="language-rust ignore">let obj: Py&lt;PyAny&gt; = ...;
let bound: &amp;Bound&lt;'py, PyAny&gt; = obj.bind(py);
let bound: Bound&lt;'py, PyAny&gt; = obj.into_bound(py);

let obj: &amp;Py&lt;PyAny&gt; = bound.as_unbound();
let obj: Py&lt;PyAny&gt; = bound.unbind();</code></pre>
<p>To convert between <code>Bound&lt;'py, T&gt;</code> and <code>Borrowed&lt;'a, 'py, T&gt;</code> use the <code>as_borrowed()</code> method. <code>Borrowed&lt;'a, 'py, T&gt;</code> has a deref coercion to <code>Bound&lt;'py, T&gt;</code>. Use the <code>to_owned()</code> method to increment the Python reference count and to create a new <code>Bound&lt;'py, T&gt;</code> from the <code>Borrowed&lt;'a, 'py, T&gt;</code>.</p>
<pre><code class="language-rust ignore">let bound: Bound&lt;'py, PyAny&gt; = ...;
let borrowed: Borrowed&lt;'_, 'py, PyAny&gt; = bound.as_borrowed();

// deref coercion
let bound: &amp;Bound&lt;'py, PyAny&gt; = &amp;borrowed;

// create a new Bound by increase the Python reference count
let bound: Bound&lt;'py, PyAny&gt; = borrowed.to_owned();</code></pre>
<p>To convert between <code>Py&lt;T&gt;</code> and <code>Borrowed&lt;'a, 'py, T&gt;</code> use the <code>bind_borrowed()</code> method. Use either <code>as_unbound()</code> or <code>.to_owned().unbind()</code> to go back to <code>Py&lt;T&gt;</code> from <code>Borrowed&lt;'a, 'py, T&gt;</code>, via <code>Bound&lt;'py, T&gt;</code>.</p>
<pre><code class="language-rust ignore">let obj: Py&lt;PyAny&gt; = ...;
let borrowed: Borrowed&lt;'_, 'py, PyAny&gt; = bound.as_borrowed();

// via deref coercion to Bound and then using Bound::as_unbound
let obj: &amp;Py&lt;PyAny&gt; = borrowed.as_unbound();

// via a new Bound by increasing the Python reference count, and unbind it
let obj: Py&lt;PyAny&gt; = borrowed.to_owned().unbind().</code></pre>
<h2 id="concrete-python-types"><a class="header" href="#concrete-python-types">Concrete Python types</a></h2>
<p>In all of <code>Py&lt;T&gt;</code>, <code>Bound&lt;'py, T&gt;</code>, and <code>Borrowed&lt;'a, 'py, T&gt;</code>, the type parameter <code>T</code> denotes the type of the Python object referred to by the smart pointer.</p>
<p>This parameter <code>T</code> can be filled by:</p>
<ul>
<li><a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyAny.html"><code>PyAny</code></a>, which represents any Python object,</li>
<li>Native Python types such as <code>PyList</code>, <code>PyTuple</code>, and <code>PyDict</code>, and</li>
<li><a href="class.html"><code>#[pyclass]</code></a> types defined from Rust</li>
</ul>
<p>The following subsections covers some further detail about how to work with these types:</p>
<ul>
<li>the APIs that are available for these concrete types,</li>
<li>how to cast <code>Bound&lt;'py, T&gt;</code> to a specific concrete type, and</li>
<li>how to get Rust data out of a <code>Bound&lt;'py, T&gt;</code>.</li>
</ul>
<h3 id="using-apis-for-concrete-python-types"><a class="header" href="#using-apis-for-concrete-python-types">Using APIs for concrete Python types</a></h3>
<p>Each concrete Python type such as <code>PyAny</code>, <code>PyTuple</code> and <code>PyDict</code> exposes its API on the corresponding bound smart pointer <code>Bound&lt;'py, PyAny&gt;</code>, <code>Bound&lt;'py, PyTuple&gt;</code> and <code>Bound&lt;'py, PyDict&gt;</code>.</p>
<p>Each type's API is exposed as a trait: <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html"><code>PyAnyMethods</code></a>, <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyTupleMethods.html"><code>PyTupleMethods</code></a>, <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyDictMethods.html"><code>PyDictMethods</code></a>, and so on for all concrete types. Using traits rather than associated methods on the <code>Bound</code> smart pointer is done for a couple of reasons:</p>
<ul>
<li>Clarity of documentation: each trait gets its own documentation page in the PyO3 API docs. If all methods were on the <code>Bound</code> smart pointer directly, the vast majority of PyO3's API would be on a single, extremely long, documentation page.</li>
<li>Consistency: downstream code implementing Rust APIs for existing Python types can also follow this pattern of using a trait. Downstream code would not be allowed to add new associated methods directly on the <code>Bound</code> type.</li>
<li>Future design: it is hoped that a future Rust with <a href="https://github.com/rust-lang/rust/issues/44874">arbitrary self types</a> will remove the need for these traits in favour of placing the methods directly on <code>PyAny</code>, <code>PyTuple</code>, <code>PyDict</code>, and so on.</li>
</ul>
<p>These traits are all included in the <code>pyo3::prelude</code> module, so with the glob import <code>use pyo3::prelude::*</code> the full PyO3 API is made available to downstream code.</p>
<p>The following function accesses the first item in the input Python list, using the <code>.get_item()</code> method from the <code>PyListMethods</code> trait:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyList;

fn get_first_item&lt;'py&gt;(list: &amp;Bound&lt;'py, PyList&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; {
    list.get_item(0)
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let l = PyList::new_bound(py, ["hello world"]);
</span><span class="boring">    assert!(get_first_item(&amp;l).unwrap().eq("hello world").unwrap());
</span><span class="boring">})</span></code></pre>
<h3 id="casting-between-python-object-types"><a class="header" href="#casting-between-python-object-types">Casting between Python object types</a></h3>
<p>To cast <code>Bound&lt;'py, T&gt;</code> smart pointers to some other type, use the <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.downcast"><code>.downcast()</code></a> family of functions. This converts <code>&amp;Bound&lt;'py, T&gt;</code> to a different <code>&amp;Bound&lt;'py, U&gt;</code>, without transferring ownership. There is also <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.downcast_into"><code>.downcast_into()</code></a> to convert <code>Bound&lt;'py, T&gt;</code> to <code>Bound&lt;'py, U&gt;</code> with transfer of ownership. These methods are available for all types <code>T</code> which implement the <a href="https://docs.rs/pyo3/0.21.2/pyo3/type_object/trait.PyTypeCheck.html"><code>PyTypeCheck</code></a> trait.</p>
<p>Casting to <code>Bound&lt;'py, PyAny&gt;</code> can be done with <code>.as_any()</code> or <code>.into_any()</code>.</p>
<p>For example, the following snippet shows how to cast <code>Bound&lt;'py, PyAny&gt;</code> to <code>Bound&lt;'py, PyTuple&gt;</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyTuple;
</span><span class="boring">fn example&lt;'py&gt;(py: Python&lt;'py&gt;) -&gt; PyResult&lt;()&gt; {
</span>// create a new Python `tuple`, and use `.into_any()` to erase the type
let obj: Bound&lt;'py, PyAny&gt; = PyTuple::empty_bound(py).into_any();

// use `.downcast()` to cast to `PyTuple` without transferring ownership
let _: &amp;Bound&lt;'py, PyTuple&gt; = obj.downcast()?;

// use `.downcast_into()` to cast to `PyTuple` with transfer of ownership
let _: Bound&lt;'py, PyTuple&gt; = obj.downcast_into()?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">Python::with_gil(example).unwrap()</span></code></pre>
<p>Custom <a href="class.html"><code>#[pyclass]</code></a> types implement <a href="https://docs.rs/pyo3/0.21.2/pyo3/type_object/trait.PyTypeCheck.html"><code>PyTypeCheck</code></a>, so <code>.downcast()</code> also works for these types. The snippet below is the same as the snippet above casting instead to a custom type <code>MyClass</code>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyclass]
struct MyClass {}

<span class="boring">fn example&lt;'py&gt;(py: Python&lt;'py&gt;) -&gt; PyResult&lt;()&gt; {
</span>// create a new Python `tuple`, and use `.into_any()` to erase the type
let obj: Bound&lt;'py, PyAny&gt; = Bound::new(py, MyClass {})?.into_any();

// use `.downcast()` to cast to `MyClass` without transferring ownership
let _: &amp;Bound&lt;'py, MyClass&gt; = obj.downcast()?;

// use `.downcast_into()` to cast to `MyClass` with transfer of ownership
let _: Bound&lt;'py, MyClass&gt; = obj.downcast_into()?;
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">Python::with_gil(example).unwrap()</span></code></pre>
<h3 id="extracting-rust-data-from-python-objects"><a class="header" href="#extracting-rust-data-from-python-objects">Extracting Rust data from Python objects</a></h3>
<p>To extract Rust data from Python objects, use <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.extract"><code>.extract()</code></a> instead of <code>.downcast()</code>. This method is available for all types which implement the [<code>FromPyObject</code>] trait.</p>
<p>For example, the following snippet extracts a Rust tuple of integers from a Python tuple:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyTuple;
</span><span class="boring">fn example&lt;'py&gt;(py: Python&lt;'py&gt;) -&gt; PyResult&lt;()&gt; {
</span>// create a new Python `tuple`, and use `.into_any()` to erase the type
let obj: Bound&lt;'py, PyAny&gt; = PyTuple::new_bound(py, [1, 2, 3]).into_any();

// extracting the Python `tuple` to a rust `(i32, i32, i32)` tuple
let (x, y, z) = obj.extract::&lt;(i32, i32, i32)&gt;()?;
assert_eq!((x, y, z), (1, 2, 3));
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">Python::with_gil(example).unwrap()</span></code></pre>
<p>To avoid copying data, <a href="class.html"><code>#[pyclass]</code></a> types can directly reference Rust data stored within the Python objects without needing to <code>.extract()</code>. See the <a href="./class.html#bound-and-interior-mutability">corresponding documentation in the class section of the guide</a>
for more detail.</p>
<h2 id="the-gil-refs-api"><a class="header" href="#the-gil-refs-api">The GIL Refs API</a></h2>
<p>The GIL Refs API was PyO3's primary API prior to PyO3 0.21. The main difference was that instead of the <code>Bound&lt;'py, PyAny&gt;</code> smart pointer, the "GIL Reference" <code>&amp;'py PyAny</code> was used. (This was similar for other Python types.)</p>
<p>As of PyO3 0.21, the GIL Refs API is deprecated. See the <a href="./migration.html#from-020-to-021">migration guide</a> for details on how to upgrade.</p>
<p>The following sections note some historical detail about the GIL Refs API.</p>
<h3 id="pyany"><a class="header" href="#pyany"><a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyAny.html"><code>PyAny</code></a></a></h3>
<p><strong>Represented:</strong> a Python object of unspecified type. In the GIL Refs API, this was only accessed as the GIL Ref <code>&amp;'py PyAny</code>.</p>
<p><strong>Used:</strong> <code>&amp;'py PyAny</code> was used to refer to some Python object when the GIL lifetime was available for the whole duration access was needed. For example, intermediate values and arguments to <code>pyfunction</code>s or <code>pymethod</code>s implemented in Rust where any type is allowed.</p>
<p><strong>Conversions:</strong></p>
<p>For a <code>&amp;PyAny</code> object reference <code>any</code> where the underlying object is a Python-native type such as
a list:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // PyList::empty is part of the deprecated "GIL Refs" API.
let obj: &amp;PyAny = PyList::empty(py);

// To &amp;PyList with PyAny::downcast
let _: &amp;PyList = obj.downcast()?;

// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = obj.into();

// To Py&lt;PyList&gt; with PyAny::extract
let _: Py&lt;PyList&gt; = obj.extract()?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();</span></code></pre>
<p>For a <code>&amp;PyAny</code> object reference <code>any</code> where the underlying object is a <code>#[pyclass]</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass] #[derive(Clone)] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // into_ref is part of the deprecated GIL Refs API
let obj: &amp;PyAny = Py::new(py, MyClass {})?.into_ref(py);

// To &amp;PyCell&lt;MyClass&gt; with PyAny::downcast
#[allow(deprecated)] // &amp;PyCell is part of the deprecated GIL Refs API
let _: &amp;PyCell&lt;MyClass&gt; = obj.downcast()?;

// To Py&lt;PyAny&gt; (aka PyObject) with .into()
let _: Py&lt;PyAny&gt; = obj.into();

// To Py&lt;MyClass&gt; with PyAny::extract
let _: Py&lt;MyClass&gt; = obj.extract()?;

// To MyClass with PyAny::extract, if MyClass: Clone
let _: MyClass = obj.extract()?;

// To PyRef&lt;'_, MyClass&gt; or PyRefMut&lt;'_, MyClass&gt; with PyAny::extract
let _: PyRef&lt;'_, MyClass&gt; = obj.extract()?;
let _: PyRefMut&lt;'_, MyClass&gt; = obj.extract()?;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();</span></code></pre>
<h3 id="pytuple-pydict-and-many-more"><a class="header" href="#pytuple-pydict-and-many-more"><code>PyTuple</code>, <code>PyDict</code>, and many more</a></h3>
<p><strong>Represented:</strong> a native Python object of known type. In the GIL Refs API, they were only accessed as the GIL Refs <code>&amp;'py PyTuple</code>, <code>&amp;'py PyDict</code>.</p>
<p><strong>Used:</strong> <code>&amp;'py PyTuple</code> and similar were used to operate with native Python types while holding the GIL. Like <code>PyAny</code>, this is the most convenient form to use for function arguments and intermediate values.</p>
<p>These GIL Refs implement <code>Deref&lt;Target = PyAny&gt;</code>, so they all expose the same methods which can be found on <code>PyAny</code>.</p>
<p>To see all Python types exposed by <code>PyO3</code> consult the <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/index.html"><code>pyo3::types</code></a> module.</p>
<p><strong>Conversions:</strong></p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // PyList::empty is part of the deprecated "GIL Refs" API.
let list = PyList::empty(py);

// Use methods from PyAny on all Python types with Deref implementation
let _ = list.repr()?;

// To &amp;PyAny automatically with Deref implementation
let _: &amp;PyAny = list;

// To &amp;PyAny explicitly with .as_ref()
#[allow(deprecated)] // as_ref is part of the deprecated "GIL Refs" API.
let _: &amp;PyAny = list.as_ref();

// To Py&lt;T&gt; with .into() or Py::from()
let _: Py&lt;PyList&gt; = list.into();

// To PyObject with .into() or .to_object(py)
let _: PyObject = list.into();
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();</span></code></pre>
<h3 id="pyt-and-pyobject-1"><a class="header" href="#pyt-and-pyobject-1"><code>Py&lt;T&gt;</code> and <code>PyObject</code></a></h3>
<p><strong>Represented:</strong> a GIL-independent reference to a Python object. This can be a Python native type
(like <code>PyTuple</code>), or a <code>pyclass</code> type implemented in Rust. The most commonly-used variant,
<code>Py&lt;PyAny&gt;</code>, is also known as <code>PyObject</code>.</p>
<p><strong>Used:</strong> Whenever you want to carry around references to a Python object without caring about a
GIL lifetime.  For example, storing Python object references in a Rust struct that outlives the
Python-Rust FFI boundary, or returning objects from functions implemented in Rust back to Python.</p>
<p>Can be cloned using Python reference counts with <code>.clone()</code>.</p>
<h3 id="pycellsometype"><a class="header" href="#pycellsometype"><code>PyCell&lt;SomeType&gt;</code></a></h3>
<p><strong>Represented:</strong> a reference to a Rust object (instance of <code>PyClass</code>) wrapped in a Python object.  The cell part is an analog to stdlib's <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> to allow access to <code>&amp;mut</code> references.</p>
<p><strong>Used:</strong> for accessing pure-Rust API of the instance (members and functions taking <code>&amp;SomeType</code> or <code>&amp;mut SomeType</code>) while maintaining the aliasing rules of Rust references.</p>
<p>Like PyO3's Python native types, the GIL Ref <code>&amp;PyCell&lt;T&gt;</code> implements <code>Deref&lt;Target = PyAny&gt;</code>, so it also exposed all of the methods on <code>PyAny</code>.</p>
<p><strong>Conversions:</strong></p>
<p><code>PyCell&lt;T&gt;</code> was used to access <code>&amp;T</code> and <code>&amp;mut T</code> via <code>PyRef&lt;T&gt;</code> and <code>PyRefMut&lt;T&gt;</code> respectively.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // &amp;PyCell is part of the deprecated GIL Refs API
let cell: &amp;PyCell&lt;MyClass&gt; = PyCell::new(py, MyClass {})?;

// To PyRef&lt;T&gt; with .borrow() or .try_borrow()
let py_ref: PyRef&lt;'_, MyClass&gt; = cell.try_borrow()?;
let _: &amp;MyClass = &amp;*py_ref;
<span class="boring">drop(py_ref);
</span>
// To PyRefMut&lt;T&gt; with .borrow_mut() or .try_borrow_mut()
let mut py_ref_mut: PyRefMut&lt;'_, MyClass&gt; = cell.try_borrow_mut()?;
let _: &amp;mut MyClass = &amp;mut *py_ref_mut;
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();</span></code></pre>
<p><code>PyCell&lt;T&gt;</code> was also accessed like a Python-native type.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass] struct MyClass { }
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // &amp;PyCell is part of the deprecate GIL Refs API
let cell: &amp;PyCell&lt;MyClass&gt; = PyCell::new(py, MyClass {})?;

// Use methods from PyAny on PyCell&lt;T&gt; with Deref implementation
let _ = cell.repr()?;

// To &amp;PyAny automatically with Deref implementation
let _: &amp;PyAny = cell;

// To &amp;PyAny explicitly with .as_ref()
#[allow(deprecated)] // as_ref is part of the deprecated "GIL Refs" API.
let _: &amp;PyAny = cell.as_ref();
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-exceptions"><a class="header" href="#python-exceptions">Python exceptions</a></h1>
<h2 id="defining-a-new-exception"><a class="header" href="#defining-a-new-exception">Defining a new exception</a></h2>
<p>Use the <a href="https://docs.rs/pyo3/0.21.2/pyo3/macro.create_exception.html"><code>create_exception!</code></a> macro:</p>
<pre><code class="language-rust">use pyo3::create_exception;

create_exception!(module, MyError, pyo3::exceptions::PyException);</code></pre>
<ul>
<li><code>module</code> is the name of the containing module.</li>
<li><code>MyError</code> is the name of the new exception type.</li>
</ul>
<p>For example:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::create_exception;
use pyo3::types::IntoPyDict;
use pyo3::exceptions::PyException;

create_exception!(mymodule, CustomError, PyException);

Python::with_gil(|py| {
    let ctx = [("CustomError", py.get_type_bound::&lt;CustomError&gt;())].into_py_dict_bound(py);
    pyo3::py_run!(
        py,
        *ctx,
        "assert str(CustomError) == \"&lt;class 'mymodule.CustomError'&gt;\""
    );
    pyo3::py_run!(py, *ctx, "assert CustomError('oops').args == ('oops',)");
});</code></pre>
<p>When using PyO3 to create an extension module, you can add the new exception to
the module like this, so that it is importable from Python:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::exceptions::PyException;

pyo3::create_exception!(mymodule, CustomError, PyException);

#[pymodule]
fn mymodule(py: Python&lt;'_&gt;, m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    // ... other elements added to module ...
    m.add("CustomError", py.get_type_bound::&lt;CustomError&gt;())?;

    Ok(())
}</code></pre>
<h2 id="raising-an-exception"><a class="header" href="#raising-an-exception">Raising an exception</a></h2>
<p>As described in the <a href="./function/error-handling.html">function error handling</a> chapter, to raise an exception from a <code>#[pyfunction]</code> or <code>#[pymethods]</code>, return an <code>Err(PyErr)</code>. PyO3 will automatically raise this exception for you when returning the result to Python.</p>
<p>You can also manually write and fetch errors in the Python interpreter's global state:</p>
<pre><code class="language-rust">use pyo3::{Python, PyErr};
use pyo3::exceptions::PyTypeError;

Python::with_gil(|py| {
    PyTypeError::new_err("Error").restore(py);
    assert!(PyErr::occurred(py));
    drop(PyErr::fetch(py));
});</code></pre>
<h2 id="checking-exception-types"><a class="header" href="#checking-exception-types">Checking exception types</a></h2>
<p>Python has an <a href="https://docs.python.org/3/library/functions.html#isinstance"><code>isinstance</code></a> method to check an object's type.
In PyO3 every object has the <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyAny.html#method.is_instance"><code>PyAny::is_instance</code></a> and <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyAny.html#method.is_instance_of"><code>PyAny::is_instance_of</code></a> methods which do the same thing.</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::{PyBool, PyList};

Python::with_gil(|py| {
    assert!(PyBool::new_bound(py, true).is_instance_of::&lt;PyBool&gt;());
    let list = PyList::new_bound(py, &amp;[1, 2, 3, 4]);
    assert!(!list.is_instance_of::&lt;PyBool&gt;());
    assert!(list.is_instance_of::&lt;PyList&gt;());
});</code></pre>
<p>To check the type of an exception, you can similarly do:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::exceptions::PyTypeError;
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span><span class="boring">let err = PyTypeError::new_err(());
</span>err.is_instance_of::&lt;PyTypeError&gt;(py);
<span class="boring">});</span></code></pre>
<h2 id="using-exceptions-defined-in-python-code"><a class="header" href="#using-exceptions-defined-in-python-code">Using exceptions defined in Python code</a></h2>
<p>It is possible to use an exception defined in Python code as a native Rust type.
The <code>import_exception!</code> macro allows importing a specific exception class and defines a Rust type
for that exception.</p>
<pre><code class="language-rust">#![allow(dead_code)]
use pyo3::prelude::*;

mod io {
    pyo3::import_exception!(io, UnsupportedOperation);
}

fn tell(file: &amp;Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;u64&gt; {
    match file.call_method0("tell") {
        Err(_) =&gt; Err(io::UnsupportedOperation::new_err("not supported: tell")),
        Ok(x) =&gt; x.extract::&lt;u64&gt;(),
    }
}</code></pre>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/exceptions/index.html"><code>pyo3::exceptions</code></a>
defines exceptions for several standard library modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-python-functions"><a class="header" href="#calling-python-functions">Calling Python functions</a></h1>
<p>The <code>Bound&lt;'py, T&gt;</code> smart pointer (such as <code>Bound&lt;'py, PyAny&gt;</code>, <code>Bound&lt;'py, PyList&gt;</code>, or <code>Bound&lt;'py, MyClass&gt;</code>) can be used to call Python functions.</p>
<p>PyO3 offers two APIs to make function calls:</p>
<ul>
<li><a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.call"><code>call</code></a> - call any callable Python object.</li>
<li><a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.call_method"><code>call_method</code></a> - call a method on the Python object.</li>
</ul>
<p>Both of these APIs take <code>args</code> and <code>kwargs</code> arguments (for positional and keyword arguments respectively). There are variants for less complex calls:</p>
<ul>
<li><a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.call1"><code>call1</code></a> and <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.call_method1"><code>call_method1</code></a> to call only with positional <code>args</code>.</li>
<li><a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.call0"><code>call0</code></a> and <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.call_method0"><code>call_method0</code></a> to call with no arguments.</li>
</ul>
<p>For convenience the <a href="python-from-rust/../types.html#pyt-and-pyobject"><code>Py&lt;T&gt;</code></a> smart pointer also exposes these same six API methods, but needs a <code>Python</code> token as an additional first argument to prove the GIL is held.</p>
<p>The example below calls a Python function behind a <code>PyObject</code> (aka <code>Py&lt;PyAny&gt;</code>) reference:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyTuple;

fn main() -&gt; PyResult&lt;()&gt; {
    let arg1 = "arg1";
    let arg2 = "arg2";
    let arg3 = "arg3";

    Python::with_gil(|py| {
        let fun: Py&lt;PyAny&gt; = PyModule::from_code_bound(
            py,
            "def example(*args, **kwargs):
                if args != ():
                    print('called with args', args)
                if kwargs != {}:
                    print('called with kwargs', kwargs)
                if args == () and kwargs == {}:
                    print('called with no arguments')",
            "",
            "",
        )?
        .getattr("example")?
        .into();

        // call object without any arguments
        fun.call0(py)?;

        // pass object with Rust tuple of positional arguments
        let args = (arg1, arg2, arg3);
        fun.call1(py, args)?;

        // call object with Python tuple of positional arguments
        let args = PyTuple::new_bound(py, &amp;[arg1, arg2, arg3]);
        fun.call1(py, args)?;
        Ok(())
    })
}</code></pre>
<h2 id="creating-keyword-arguments"><a class="header" href="#creating-keyword-arguments">Creating keyword arguments</a></h2>
<p>For the <code>call</code> and <code>call_method</code> APIs, <code>kwargs</code> are <code>Option&lt;&amp;Bound&lt;'py, PyDict&gt;&gt;</code>, so can either be <code>None</code> or <code>Some(&amp;dict)</code>. You can use the <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.IntoPyDict.html"><code>IntoPyDict</code></a> trait to convert other dict-like containers, e.g. <code>HashMap</code> or <code>BTreeMap</code>, as well as tuples with up to 10 elements and <code>Vec</code>s where each element is a two-element tuple.</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::IntoPyDict;
use std::collections::HashMap;

fn main() -&gt; PyResult&lt;()&gt; {
    let key1 = "key1";
    let val1 = 1;
    let key2 = "key2";
    let val2 = 2;

    Python::with_gil(|py| {
        let fun: Py&lt;PyAny&gt; = PyModule::from_code_bound(
            py,
            "def example(*args, **kwargs):
                if args != ():
                    print('called with args', args)
                if kwargs != {}:
                    print('called with kwargs', kwargs)
                if args == () and kwargs == {}:
                    print('called with no arguments')",
            "",
            "",
        )?
        .getattr("example")?
        .into();

        // call object with PyDict
        let kwargs = [(key1, val1)].into_py_dict_bound(py);
        fun.call_bound(py, (), Some(&amp;kwargs))?;

        // pass arguments as Vec
        let kwargs = vec![(key1, val1), (key2, val2)];
        fun.call_bound(py, (), Some(&amp;kwargs.into_py_dict_bound(py)))?;

        // pass arguments as HashMap
        let mut kwargs = HashMap::&lt;&amp;str, i32&gt;::new();
        kwargs.insert(key1, 1);
        fun.call_bound(py, (), Some(&amp;kwargs.into_py_dict_bound(py)))?;

        Ok(())
    })
}</code></pre>
<div class="warning">
<p>During PyO3's <a href="python-from-rust/../migration.html#migrating-from-the-gil-refs-api-to-boundt">migration from "GIL Refs" to the <code>Bound&lt;T&gt;</code> smart pointer</a>, <a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.Py.html#method.call"><code>Py&lt;T&gt;::call</code></a> is temporarily named <code>call_bound</code> (and <code>call_method</code> is temporarily <code>call_method_bound</code>).</p>
<p>(This temporary naming is only the case for the <code>Py&lt;T&gt;</code> smart pointer. The methods on the <code>&amp;PyAny</code> GIL Ref such as <code>call</code> have not been given replacements, and the methods on the <code>Bound&lt;PyAny&gt;</code> smart pointer such as <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/trait.PyAnyMethods.html#tymethod.call"><code>Bound&lt;PyAny&gt;::call</code></a> already use follow the newest API conventions.)</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executing-existing-python-code"><a class="header" href="#executing-existing-python-code">Executing existing Python code</a></h1>
<p>If you already have some existing Python code that you need to execute from Rust, the following FAQs can help you select the right PyO3 functionality for your situation:</p>
<h2 id="want-to-access-python-apis-then-use-pymoduleimport"><a class="header" href="#want-to-access-python-apis-then-use-pymoduleimport">Want to access Python APIs? Then use <code>PyModule::import</code>.</a></h2>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyModule.html#method.import"><code>Pymodule::import</code></a> can
be used to get handle to a Python module from Rust. You can use this to import and use any Python
module available in your environment.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

fn main() -&gt; PyResult&lt;()&gt; {
    Python::with_gil(|py| {
        let builtins = PyModule::import_bound(py, "builtins")?;
        let total: i32 = builtins
            .getattr("sum")?
            .call1((vec![1, 2, 3],))?
            .extract()?;
        assert_eq!(total, 6);
        Ok(())
    })
}</code></pre>
<h2 id="want-to-run-just-an-expression-then-use-eval"><a class="header" href="#want-to-run-just-an-expression-then-use-eval">Want to run just an expression? Then use <code>eval</code>.</a></h2>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.eval"><code>Python::eval</code></a> is
a method to execute a <a href="https://docs.python.org/3.7/reference/expressions.html">Python expression</a>
and return the evaluated value as a <code>Bound&lt;'py, PyAny&gt;</code> object.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

<span class="boring">fn main() -&gt; Result&lt;(), ()&gt; {
</span>Python::with_gil(|py| {
    let result = py
        .eval_bound("[i * 10 for i in range(5)]", None, None)
        .map_err(|e| {
            e.print_and_set_sys_last_vars(py);
        })?;
    let res: Vec&lt;i64&gt; = result.extract().unwrap();
    assert_eq!(res, vec![0, 10, 20, 30, 40]);
    Ok(())
})
<span class="boring">}</span></code></pre>
<h2 id="want-to-run-statements-then-use-run"><a class="header" href="#want-to-run-statements-then-use-run">Want to run statements? Then use <code>run</code>.</a></h2>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.run"><code>Python::run</code></a> is a method to execute one or more
<a href="https://docs.python.org/3.7/reference/simple_stmts.html">Python statements</a>.
This method returns nothing (like any Python statement), but you can get
access to manipulated objects via the <code>locals</code> dict.</p>
<p>You can also use the <a href="https://docs.rs/pyo3/0.21.2/pyo3/macro.py_run.html"><code>py_run!</code></a> macro, which is a shorthand for <a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.run"><code>Python::run</code></a>.
Since <a href="https://docs.rs/pyo3/0.21.2/pyo3/macro.py_run.html"><code>py_run!</code></a> panics on exceptions, we recommend you use this macro only for
quickly testing your Python extensions.</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::py_run;

<span class="boring">fn main() {
</span>#[pyclass]
struct UserData {
    id: u32,
    name: String,
}

#[pymethods]
impl UserData {
    fn as_tuple(&amp;self) -&gt; (u32, String) {
        (self.id, self.name.clone())
    }

    fn __repr__(&amp;self) -&gt; PyResult&lt;String&gt; {
        Ok(format!("User {}(id: {})", self.name, self.id))
    }
}

Python::with_gil(|py| {
    let userdata = UserData {
        id: 34,
        name: "Yu".to_string(),
    };
    let userdata = Py::new(py, userdata).unwrap();
    let userdata_as_tuple = (34, "Yu");
    py_run!(py, userdata userdata_as_tuple, r#"
assert repr(userdata) == "User Yu(id: 34)"
assert userdata.as_tuple() == userdata_as_tuple
    "#);
})
<span class="boring">}</span></code></pre>
<h2 id="you-have-a-python-file-or-code-snippet-then-use-pymodulefrom_code"><a class="header" href="#you-have-a-python-file-or-code-snippet-then-use-pymodulefrom_code">You have a Python file or code snippet? Then use <code>PyModule::from_code</code>.</a></h2>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyModule.html#method.from_code"><code>PyModule::from_code</code></a>
can be used to generate a Python module which can then be used just as if it was imported with
<code>PyModule::import</code>.</p>
<p><strong>Warning</strong>: This will compile and execute code. <strong>Never</strong> pass untrusted code
to this function!</p>
<pre><code class="language-rust">use pyo3::{prelude::*, types::IntoPyDict};

<span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| {
    let activators = PyModule::from_code_bound(
        py,
        r#"
def relu(x):
    """see https://en.wikipedia.org/wiki/Rectifier_(neural_networks)"""
    return max(0.0, x)

def leaky_relu(x, slope=0.01):
    return x if x &gt;= 0 else x * slope
    "#,
        "activators.py",
        "activators",
    )?;

    let relu_result: f64 = activators.getattr("relu")?.call1((-1.0,))?.extract()?;
    assert_eq!(relu_result, 0.0);

    let kwargs = [("slope", 0.2)].into_py_dict_bound(py);
    let lrelu_result: f64 = activators
        .getattr("leaky_relu")?
        .call((-1.0,), Some(&amp;kwargs))?
        .extract()?;
    assert_eq!(lrelu_result, -0.2);
<span class="boring">   Ok(())
</span>})
<span class="boring">}</span></code></pre>
<h2 id="want-to-embed-python-in-rust-with-additional-modules"><a class="header" href="#want-to-embed-python-in-rust-with-additional-modules">Want to embed Python in Rust with additional modules?</a></h2>
<p>Python maintains the <code>sys.modules</code> dict as a cache of all imported modules.
An import in Python will first attempt to lookup the module from this dict,
and if not present will use various strategies to attempt to locate and load
the module.</p>
<p>The <a href="https://docs.rs/pyo3/0.21.2/pyo3/macro.append_to_inittab.html"><code>append_to_inittab</code></a>
macro can be used to add additional <code>#[pymodule]</code> modules to an embedded
Python interpreter. The macro <strong>must</strong> be invoked <em>before</em> initializing Python.</p>
<p>As an example, the below adds the module <code>foo</code> to the embedded interpreter:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyfunction]
fn add_one(x: i64) -&gt; i64 {
    x + 1
}

#[pymodule]
fn foo(foo_module: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    foo_module.add_function(wrap_pyfunction!(add_one, foo_module)?)?;
    Ok(())
}

fn main() -&gt; PyResult&lt;()&gt; {
    pyo3::append_to_inittab!(foo);
    Python::with_gil(|py| Python::run_bound(py, "import foo; foo.add_one(6)", None, None))
}</code></pre>
<p>If <code>append_to_inittab</code> cannot be used due to constraints in the program,
an alternative is to create a module using <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyModule.html#method.new"><code>PyModule::new</code></a>
and insert it manually into <code>sys.modules</code>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::types::PyDict;

#[pyfunction]
pub fn add_one(x: i64) -&gt; i64 {
    x + 1
}

fn main() -&gt; PyResult&lt;()&gt; {
    Python::with_gil(|py| {
        // Create new module
        let foo_module = PyModule::new_bound(py, "foo")?;
        foo_module.add_function(wrap_pyfunction!(add_one, &amp;foo_module)?)?;

        // Import and get sys.modules
        let sys = PyModule::import_bound(py, "sys")?;
        let py_modules: Bound&lt;'_, PyDict&gt; = sys.getattr("modules")?.downcast_into()?;

        // Insert foo into sys.modules
        py_modules.set_item("foo", foo_module)?;

        // Now we can import + run our python code
        Python::run_bound(py, "import foo; foo.add_one(6)", None, None)
    })
}</code></pre>
<h2 id="include-multiple-python-files"><a class="header" href="#include-multiple-python-files">Include multiple Python files</a></h2>
<p>You can include a file at compile time by using
<a href="https://doc.rust-lang.org/std/macro.include_str.html"><code>std::include_str</code></a> macro.</p>
<p>Or you can load a file at runtime by using
<a href="https://doc.rust-lang.org/std/fs/fn.read_to_string.html"><code>std::fs::read_to_string</code></a> function.</p>
<p>Many Python files can be included and loaded as modules. If one file depends on
another you must preserve correct order while declaring <code>PyModule</code>.</p>
<p>Example directory structure:</p>
<pre><code class="language-text">.
├── Cargo.lock
├── Cargo.toml
├── python_app
│   ├── app.py
│   └── utils
│       └── foo.py
└── src
    └── main.rs
</code></pre>
<p><code>python_app/app.py</code>:</p>
<pre><code class="language-python">from utils.foo import bar


def run():
    return bar()
</code></pre>
<p><code>python_app/utils/foo.py</code>:</p>
<pre><code class="language-python">def bar():
    return "baz"
</code></pre>
<p>The example below shows:</p>
<ul>
<li>how to include content of <code>app.py</code> and <code>utils/foo.py</code> into your rust binary</li>
<li>how to call function <code>run()</code> (declared in <code>app.py</code>) that needs function
imported from <code>utils/foo.py</code></li>
</ul>
<p><code>src/main.rs</code>:</p>
<pre><code class="language-rust ignore">use pyo3::prelude::*;

fn main() -&gt; PyResult&lt;()&gt; {
    let py_foo = include_str!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/python_app/utils/foo.py"
    ));
    let py_app = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/python_app/app.py"));
    let from_python = Python::with_gil(|py| -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {
        PyModule::from_code_bound(py, py_foo, "utils.foo", "utils.foo")?;
        let app: Py&lt;PyAny&gt; = PyModule::from_code_bound(py, py_app, "", "")?
            .getattr("run")?
            .into();
        app.call0(py)
    });

    println!("py: {}", from_python?);
    Ok(())
}</code></pre>
<p>The example below shows:</p>
<ul>
<li>how to load content of <code>app.py</code> at runtime so that it sees its dependencies
automatically</li>
<li>how to call function <code>run()</code> (declared in <code>app.py</code>) that needs function
imported from <code>utils/foo.py</code></li>
</ul>
<p>It is recommended to use absolute paths because then your binary can be run
from anywhere as long as your <code>app.py</code> is in the expected directory (in this example
that directory is <code>/usr/share/python_app</code>).</p>
<p><code>src/main.rs</code>:</p>
<pre><code class="language-rust no_run">use pyo3::prelude::*;
use pyo3::types::PyList;
use std::fs;
use std::path::Path;

fn main() -&gt; PyResult&lt;()&gt; {
    let path = Path::new("/usr/share/python_app");
    let py_app = fs::read_to_string(path.join("app.py"))?;
    let from_python = Python::with_gil(|py| -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {
        let syspath = py
            .import_bound("sys")?
            .getattr("path")?
            .downcast_into::&lt;PyList&gt;()?;
        syspath.insert(0, &amp;path)?;
        let app: Py&lt;PyAny&gt; = PyModule::from_code_bound(py, &amp;py_app, "", "")?
            .getattr("run")?
            .into();
        app.call0(py)
    });

    println!("py: {}", from_python?);
    Ok(())
}</code></pre>
<h2 id="need-to-use-a-context-manager-from-rust"><a class="header" href="#need-to-use-a-context-manager-from-rust">Need to use a context manager from Rust?</a></h2>
<p>Use context managers by directly invoking <code>__enter__</code> and <code>__exit__</code>.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

fn main() {
    Python::with_gil(|py| {
        let custom_manager = PyModule::from_code_bound(
            py,
            r#"
class House(object):
    def __init__(self, address):
        self.address = address
    def __enter__(self):
        print(f"Welcome to {self.address}!")
    def __exit__(self, type, value, traceback):
        if type:
            print(f"Sorry you had {type} trouble at {self.address}")
        else:
            print(f"Thank you for visiting {self.address}, come again soon!")

        "#,
            "house.py",
            "house",
        )
        .unwrap();

        let house_class = custom_manager.getattr("House").unwrap();
        let house = house_class.call1(("123 Main Street",)).unwrap();

        house.call_method0("__enter__").unwrap();

        let result = py.eval_bound("undefined_variable + 1", None, None);

        // If the eval threw an exception we'll pass it through to the context manager.
        // Otherwise, __exit__  is called with empty arguments (Python "None").
        match result {
            Ok(_) =&gt; {
                let none = py.None();
                house
                    .call_method1("__exit__", (&amp;none, &amp;none, &amp;none))
                    .unwrap();
            }
            Err(e) =&gt; {
                house
                    .call_method1(
                        "__exit__",
                        (
                            e.get_type_bound(py),
                            e.value_bound(py),
                            e.traceback_bound(py),
                        ),
                    )
                    .unwrap();
            }
        }
    })
}</code></pre>
<h2 id="handling-system-signalsinterrupts-ctrl-c"><a class="header" href="#handling-system-signalsinterrupts-ctrl-c">Handling system signals/interrupts (Ctrl-C)</a></h2>
<p>The best way to handle system signals when running Rust code is to periodically call <code>Python::check_signals</code> to handle any signals captured by Python's signal handler. See also <a href="python-from-rust/../faq.html#ctrl-c-doesnt-do-anything-while-my-rust-code-is-executing">the FAQ entry</a>.</p>
<p>Alternatively, set Python's <code>signal</code> module to take the default action for a signal:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

<span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    let signal = py.import_bound("signal")?;
    // Set SIGINT to have the default action
    signal
        .getattr("signal")?
        .call1((signal.getattr("SIGINT")?, signal.getattr("SIG_DFL")?))?;
    Ok(())
})
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type conversions</a></h1>
<p>In this portion of the guide we'll talk about the mapping of Python types to Rust types offered by PyO3, as well as the traits available to perform conversions between them.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mapping-of-rust-types-to-python-types"><a class="header" href="#mapping-of-rust-types-to-python-types">Mapping of Rust types to Python types</a></h2>
<p>When writing functions callable from Python (such as a <code>#[pyfunction]</code> or in a <code>#[pymethods]</code> block), the trait <code>FromPyObject</code> is required for function arguments, and <code>IntoPy&lt;PyObject&gt;</code> is required for function return values.</p>
<p>Consult the tables in the following section to find the Rust types provided by PyO3 which implement these traits.</p>
<h3 id="argument-types"><a class="header" href="#argument-types">Argument Types</a></h3>
<p>When accepting a function argument, it is possible to either use Rust library types or PyO3's Python-native types. (See the next section for discussion on when to use each.)</p>
<p>The table below contains the Python type and the corresponding function argument types that will accept them:</p>
<div class="table-wrapper"><table><thead><tr><th>Python</th><th style="text-align: center">Rust</th><th style="text-align: center">Rust (Python-native)</th></tr></thead><tbody>
<tr><td><code>object</code></td><td style="text-align: center">-</td><td style="text-align: center"><code>PyAny</code></td></tr>
<tr><td><code>str</code></td><td style="text-align: center"><code>String</code>, <code>Cow&lt;str&gt;</code>, <code>&amp;str</code>, <code>char</code>, <code>OsString</code>, <code>PathBuf</code>, <code>Path</code></td><td style="text-align: center"><code>PyString</code>, <code>PyUnicode</code></td></tr>
<tr><td><code>bytes</code></td><td style="text-align: center"><code>Vec&lt;u8&gt;</code>, <code>&amp;[u8]</code>, <code>Cow&lt;[u8]&gt;</code></td><td style="text-align: center"><code>PyBytes</code></td></tr>
<tr><td><code>bool</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center"><code>PyBool</code></td></tr>
<tr><td><code>int</code></td><td style="text-align: center"><code>i8</code>, <code>u8</code>, <code>i16</code>, <code>u16</code>, <code>i32</code>, <code>u32</code>, <code>i64</code>, <code>u64</code>, <code>i128</code>, <code>u128</code>, <code>isize</code>, <code>usize</code>, <code>num_bigint::BigInt</code><sup class="footnote-reference"><a href="#1">1</a></sup>, <code>num_bigint::BigUint</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td style="text-align: center"><code>PyLong</code></td></tr>
<tr><td><code>float</code></td><td style="text-align: center"><code>f32</code>, <code>f64</code></td><td style="text-align: center"><code>PyFloat</code></td></tr>
<tr><td><code>complex</code></td><td style="text-align: center"><code>num_complex::Complex</code><sup class="footnote-reference"><a href="#2">2</a></sup></td><td style="text-align: center"><code>PyComplex</code></td></tr>
<tr><td><code>list[T]</code></td><td style="text-align: center"><code>Vec&lt;T&gt;</code></td><td style="text-align: center"><code>PyList</code></td></tr>
<tr><td><code>dict[K, V]</code></td><td style="text-align: center"><code>HashMap&lt;K, V&gt;</code>, <code>BTreeMap&lt;K, V&gt;</code>, <code>hashbrown::HashMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#3">3</a></sup>, <code>indexmap::IndexMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#4">4</a></sup></td><td style="text-align: center"><code>PyDict</code></td></tr>
<tr><td><code>tuple[T, U]</code></td><td style="text-align: center"><code>(T, U)</code>, <code>Vec&lt;T&gt;</code></td><td style="text-align: center"><code>PyTuple</code></td></tr>
<tr><td><code>set[T]</code></td><td style="text-align: center"><code>HashSet&lt;T&gt;</code>, <code>BTreeSet&lt;T&gt;</code>, <code>hashbrown::HashSet&lt;T&gt;</code><sup class="footnote-reference"><a href="#3">3</a></sup></td><td style="text-align: center"><code>PySet</code></td></tr>
<tr><td><code>frozenset[T]</code></td><td style="text-align: center"><code>HashSet&lt;T&gt;</code>, <code>BTreeSet&lt;T&gt;</code>, <code>hashbrown::HashSet&lt;T&gt;</code><sup class="footnote-reference"><a href="#3">3</a></sup></td><td style="text-align: center"><code>PyFrozenSet</code></td></tr>
<tr><td><code>bytearray</code></td><td style="text-align: center"><code>Vec&lt;u8&gt;</code>, <code>Cow&lt;[u8]&gt;</code></td><td style="text-align: center"><code>PyByteArray</code></td></tr>
<tr><td><code>slice</code></td><td style="text-align: center">-</td><td style="text-align: center"><code>PySlice</code></td></tr>
<tr><td><code>type</code></td><td style="text-align: center">-</td><td style="text-align: center"><code>PyType</code></td></tr>
<tr><td><code>module</code></td><td style="text-align: center">-</td><td style="text-align: center"><code>PyModule</code></td></tr>
<tr><td><code>collections.abc.Buffer</code></td><td style="text-align: center">-</td><td style="text-align: center"><code>PyBuffer&lt;T&gt;</code></td></tr>
<tr><td><code>datetime.datetime</code></td><td style="text-align: center"><code>SystemTime</code>, <code>chrono::DateTime&lt;Tz&gt;</code><sup class="footnote-reference"><a href="#5">5</a></sup>, <code>chrono::NaiveDateTime</code><sup class="footnote-reference"><a href="#5">5</a></sup></td><td style="text-align: center"><code>PyDateTime</code></td></tr>
<tr><td><code>datetime.date</code></td><td style="text-align: center"><code>chrono::NaiveDate</code><sup class="footnote-reference"><a href="#5">5</a></sup></td><td style="text-align: center"><code>PyDate</code></td></tr>
<tr><td><code>datetime.time</code></td><td style="text-align: center"><code>chrono::NaiveTime</code><sup class="footnote-reference"><a href="#5">5</a></sup></td><td style="text-align: center"><code>PyTime</code></td></tr>
<tr><td><code>datetime.tzinfo</code></td><td style="text-align: center"><code>chrono::FixedOffset</code><sup class="footnote-reference"><a href="#5">5</a></sup>, <code>chrono::Utc</code><sup class="footnote-reference"><a href="#5">5</a></sup>, <code>chrono_tz::TimeZone</code><sup class="footnote-reference"><a href="#6">6</a></sup></td><td style="text-align: center"><code>PyTzInfo</code></td></tr>
<tr><td><code>datetime.timedelta</code></td><td style="text-align: center"><code>Duration</code>, <code>chrono::Duration</code><sup class="footnote-reference"><a href="#5">5</a></sup></td><td style="text-align: center"><code>PyDelta</code></td></tr>
<tr><td><code>decimal.Decimal</code></td><td style="text-align: center"><code>rust_decimal::Decimal</code><sup class="footnote-reference"><a href="#7">7</a></sup></td><td style="text-align: center">-</td></tr>
<tr><td><code>ipaddress.IPv4Address</code></td><td style="text-align: center"><code>std::net::IpAddr</code>, <code>std::net::IpV4Addr</code></td><td style="text-align: center">-</td></tr>
<tr><td><code>ipaddress.IPv6Address</code></td><td style="text-align: center"><code>std::net::IpAddr</code>, <code>std::net::IpV6Addr</code></td><td style="text-align: center">-</td></tr>
<tr><td><code>os.PathLike </code></td><td style="text-align: center"><code>PathBuf</code>, <code>Path</code></td><td style="text-align: center"><code>PyString</code>, <code>PyUnicode</code></td></tr>
<tr><td><code>pathlib.Path</code></td><td style="text-align: center"><code>PathBuf</code>, <code>Path</code></td><td style="text-align: center"><code>PyString</code>, <code>PyUnicode</code></td></tr>
<tr><td><code>typing.Optional[T]</code></td><td style="text-align: center"><code>Option&lt;T&gt;</code></td><td style="text-align: center">-</td></tr>
<tr><td><code>typing.Sequence[T]</code></td><td style="text-align: center"><code>Vec&lt;T&gt;</code></td><td style="text-align: center"><code>PySequence</code></td></tr>
<tr><td><code>typing.Mapping[K, V]</code></td><td style="text-align: center"><code>HashMap&lt;K, V&gt;</code>, <code>BTreeMap&lt;K, V&gt;</code>, <code>hashbrown::HashMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#3">3</a></sup>, <code>indexmap::IndexMap&lt;K, V&gt;</code><sup class="footnote-reference"><a href="#4">4</a></sup></td><td style="text-align: center"><code>&amp;PyMapping</code></td></tr>
<tr><td><code>typing.Iterator[Any]</code></td><td style="text-align: center">-</td><td style="text-align: center"><code>PyIterator</code></td></tr>
<tr><td><code>typing.Union[...]</code></td><td style="text-align: center">See <a href="conversions/traits.html#deriving-frompyobject-for-enums"><code>#[derive(FromPyObject)]</code></a></td><td style="text-align: center">-</td></tr>
</tbody></table>
</div>
<p>It is also worth remembering the following special types:</p>
<div class="table-wrapper"><table><thead><tr><th>What</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Python&lt;'py&gt;</code></td><td>A GIL token, used to pass to PyO3 constructors to prove ownership of the GIL.</td></tr>
<tr><td><code>Bound&lt;'py, T&gt;</code></td><td>A Python object connected to the GIL lifetime. This provides access to most of PyO3's APIs.</td></tr>
<tr><td><code>Py&lt;T&gt;</code></td><td>A Python object isolated from the GIL lifetime. This can be sent to other threads.</td></tr>
<tr><td><code>PyObject</code></td><td>An alias for <code>Py&lt;PyAny&gt;</code></td></tr>
<tr><td><code>PyRef&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> borrowed immutably.</td></tr>
<tr><td><code>PyRefMut&lt;T&gt;</code></td><td>A <code>#[pyclass]</code> borrowed mutably.</td></tr>
</tbody></table>
</div>
<p>For more detail on accepting <code>#[pyclass]</code> values as function arguments, see <a href="conversions/../class.html">the section of this guide on Python Classes</a>.</p>
<h4 id="using-rust-library-types-vs-python-native-types"><a class="header" href="#using-rust-library-types-vs-python-native-types">Using Rust library types vs Python-native types</a></h4>
<p>Using Rust library types as function arguments will incur a conversion cost compared to using the Python-native types. Using the Python-native types is almost zero-cost (they just require a type check similar to the Python builtin function <code>isinstance()</code>).</p>
<p>However, once that conversion cost has been paid, the Rust standard library types offer a number of benefits:</p>
<ul>
<li>You can write functionality in native-speed Rust code (free of Python's runtime costs).</li>
<li>You get better interoperability with the rest of the Rust ecosystem.</li>
<li>You can use <code>Python::allow_threads</code> to release the Python GIL and let other Python threads make progress while your Rust code is executing.</li>
<li>You also benefit from stricter type checking. For example you can specify <code>Vec&lt;i32&gt;</code>, which will only accept a Python <code>list</code> containing integers. The Python-native equivalent, <code>&amp;PyList</code>, would accept a Python <code>list</code> containing Python objects of any type.</li>
</ul>
<p>For most PyO3 usage the conversion cost is worth paying to get these benefits. As always, if you're not sure it's worth it in your case, benchmark it!</p>
<h3 id="returning-rust-values-to-python"><a class="header" href="#returning-rust-values-to-python">Returning Rust values to Python</a></h3>
<p>When returning values from functions callable from Python, <a href="conversions/../types.html#pyo3s-smart-pointers">PyO3's smart pointers</a> (<code>Py&lt;T&gt;</code>, <code>Bound&lt;'py, T&gt;</code>, and <code>Borrowed&lt;'a, 'py, T&gt;</code>) can be used with zero cost.</p>
<p>Because <code>Bound&lt;'py, T&gt;</code> and <code>Borrowed&lt;'a, 'py, T&gt;</code> have lifetime parameters, the Rust compiler may ask for lifetime annotations to be added to your function. See the <a href="conversions/../types.html#function-argument-lifetimes">section of the guide dedicated to this</a>.</p>
<p>If your function is fallible, it should return <code>PyResult&lt;T&gt;</code> or <code>Result&lt;T, E&gt;</code> where <code>E</code> implements <code>From&lt;E&gt; for PyErr</code>. This will raise a <code>Python</code> exception if the <code>Err</code> variant is returned.</p>
<p>Finally, the following Rust types are also able to convert to Python as return values:</p>
<div class="table-wrapper"><table><thead><tr><th>Rust type</th><th style="text-align: center">Resulting Python Type</th></tr></thead><tbody>
<tr><td><code>String</code></td><td style="text-align: center"><code>str</code></td></tr>
<tr><td><code>&amp;str</code></td><td style="text-align: center"><code>str</code></td></tr>
<tr><td><code>bool</code></td><td style="text-align: center"><code>bool</code></td></tr>
<tr><td>Any integer type (<code>i32</code>, <code>u32</code>, <code>usize</code>, etc)</td><td style="text-align: center"><code>int</code></td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td style="text-align: center"><code>float</code></td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td style="text-align: center"><code>Optional[T]</code></td></tr>
<tr><td><code>(T, U)</code></td><td style="text-align: center"><code>Tuple[T, U]</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td style="text-align: center"><code>List[T]</code></td></tr>
<tr><td><code>Cow&lt;[u8]&gt;</code></td><td style="text-align: center"><code>bytes</code></td></tr>
<tr><td><code>HashMap&lt;K, V&gt;</code></td><td style="text-align: center"><code>Dict[K, V]</code></td></tr>
<tr><td><code>BTreeMap&lt;K, V&gt;</code></td><td style="text-align: center"><code>Dict[K, V]</code></td></tr>
<tr><td><code>HashSet&lt;T&gt;</code></td><td style="text-align: center"><code>Set[T]</code></td></tr>
<tr><td><code>BTreeSet&lt;T&gt;</code></td><td style="text-align: center"><code>Set[T]</code></td></tr>
<tr><td><code>Py&lt;T&gt;</code></td><td style="text-align: center"><code>T</code></td></tr>
<tr><td><code>Bound&lt;T&gt;</code></td><td style="text-align: center"><code>T</code></td></tr>
<tr><td><code>PyRef&lt;T: PyClass&gt;</code></td><td style="text-align: center"><code>T</code></td></tr>
<tr><td><code>PyRefMut&lt;T: PyClass&gt;</code></td><td style="text-align: center"><code>T</code></td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Requires the <code>num-bigint</code> optional feature.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Requires the <code>num-complex</code> optional feature.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Requires the <code>hashbrown</code> optional feature.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>Requires the <code>indexmap</code> optional feature.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>Requires the <code>chrono</code> optional feature.</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p>Requires the <code>chrono-tz</code> optional feature.</p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p>Requires the <code>rust_decimal</code> optional feature.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conversion-traits"><a class="header" href="#conversion-traits">Conversion traits</a></h2>
<p>PyO3 provides some handy traits to convert between Python types and Rust types.</p>
<h3 id="extract-and-the-frompyobject-trait"><a class="header" href="#extract-and-the-frompyobject-trait"><code>.extract()</code> and the <code>FromPyObject</code> trait</a></h3>
<p>The easiest way to convert a Python object to a Rust value is using
<code>.extract()</code>.  It returns a <code>PyResult</code> with a type error if the conversion
fails, so usually you will use something like</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let list = PyList::new_bound(py, b"foo");
</span>let v: Vec&lt;i32&gt; = list.extract()?;
<span class="boring">        assert_eq!(&amp;v, &amp;[102, 111, 111]);
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>This method is available for many Python object types, and can produce a wide
variety of Rust types, which you can check out in the implementor list of
<a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a>.</p>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> is also implemented for your own Rust types wrapped as Python
objects (see <a href="conversions/../class.html">the chapter about classes</a>).  There, in order to both be
able to operate on mutable references <em>and</em> satisfy Rust's rules of non-aliasing
mutable references, you have to extract the PyO3 reference wrappers <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a>
and <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyRefMut.html"><code>PyRefMut</code></a>.  They work like the reference wrappers of
<code>std::cell::RefCell</code> and ensure (at runtime) that Rust borrows are allowed.</p>
<h4 id="deriving-frompyobject"><a class="header" href="#deriving-frompyobject">Deriving <a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a></a></h4>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> can be automatically derived for many kinds of structs and enums
if the member types themselves implement <code>FromPyObject</code>. This even includes members
with a generic type <code>T: FromPyObject</code>. Derivation for empty enums, enum variants and
structs is not supported.</p>
<h4 id="deriving-frompyobject-for-structs"><a class="header" href="#deriving-frompyobject-for-structs">Deriving <a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for structs</a></h4>
<p>The derivation generates code that will attempt to access the attribute  <code>my_string</code> on
the Python object, i.e. <code>obj.getattr("my_string")</code>, and call <code>extract()</code> on the attribute.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    my_string: String,
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let module = PyModule::from_code_bound(
</span><span class="boring">            py,
</span><span class="boring">            "class Foo:
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.my_string = 'test'",
</span><span class="boring">            "",
</span><span class="boring">            "",
</span><span class="boring">        )?;
</span><span class="boring">
</span><span class="boring">        let class = module.getattr("Foo")?;
</span><span class="boring">        let instance = class.call0()?;
</span><span class="boring">        let rustystruct: RustyStruct = instance.extract()?;
</span><span class="boring">        assert_eq!(rustystruct.my_string, "test");
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>By setting the <code>#[pyo3(item)]</code> attribute on the field, PyO3 will attempt to extract the value by calling the <code>get_item</code> method on the Python object.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    #[pyo3(item)]
    my_string: String,
}
<span class="boring">
</span><span class="boring">use pyo3::types::PyDict;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let dict = PyDict::new_bound(py);
</span><span class="boring">        dict.set_item("my_string", "test")?;
</span><span class="boring">
</span><span class="boring">        let rustystruct: RustyStruct = dict.extract()?;
</span><span class="boring">        assert_eq!(rustystruct.my_string, "test");
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>The argument passed to <code>getattr</code> and <code>get_item</code> can also be configured:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyStruct {
    #[pyo3(item("key"))]
    string_in_mapping: String,
    #[pyo3(attribute("name"))]
    string_attr: String,
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let module = PyModule::from_code_bound(
</span><span class="boring">            py,
</span><span class="boring">            "class Foo(dict):
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.name = 'test'
</span><span class="boring">                self['key'] = 'test2'",
</span><span class="boring">            "",
</span><span class="boring">            "",
</span><span class="boring">        )?;
</span><span class="boring">
</span><span class="boring">        let class = module.getattr("Foo")?;
</span><span class="boring">        let instance = class.call0()?;
</span><span class="boring">        let rustystruct: RustyStruct = instance.extract()?;
</span><span class="boring">		assert_eq!(rustystruct.string_attr, "test");
</span><span class="boring">        assert_eq!(rustystruct.string_in_mapping, "test2");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>This tries to extract <code>string_attr</code> from the attribute <code>name</code> and <code>string_in_mapping</code>
from a mapping with the key <code>"key"</code>. The arguments for <code>attribute</code> are restricted to
non-empty string literals while <code>item</code> can take any valid literal that implements
<code>ToBorrowedObject</code>.</p>
<p>You can use <code>#[pyo3(from_item_all)]</code> on a struct to extract every field with <code>get_item</code> method.
In this case, you can't use <code>#[pyo3(attribute)]</code> or barely use <code>#[pyo3(item)]</code> on any field.
However, using <code>#[pyo3(item("key"))]</code> to specify the key for a field is still allowed.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
#[pyo3(from_item_all)]
struct RustyStruct {
    foo: String,
    bar: String,
    #[pyo3(item("foobar"))]
    baz: String,
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let py_dict = py.eval_bound("{'foo': 'foo', 'bar': 'bar', 'foobar': 'foobar'}", None, None)?;
</span><span class="boring">        let rustystruct: RustyStruct = py_dict.extract()?;
</span><span class="boring">		  assert_eq!(rustystruct.foo, "foo");
</span><span class="boring">        assert_eq!(rustystruct.bar, "bar");
</span><span class="boring">        assert_eq!(rustystruct.baz, "foobar");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h4 id="deriving-frompyobject-for-tuple-structs"><a class="header" href="#deriving-frompyobject-for-tuple-structs">Deriving <a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for tuple structs</a></h4>
<p>Tuple structs are also supported but do not allow customizing the extraction. The input is
always assumed to be a Python tuple with the same length as the Rust type, the <code>n</code>th field
is extracted from the <code>n</code>th item in the Python tuple.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTuple(String, String);

<span class="boring">use pyo3::types::PyTuple;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let tuple = PyTuple::new_bound(py, vec!["test", "test2"]);
</span><span class="boring">
</span><span class="boring">        let rustytuple: RustyTuple = tuple.extract()?;
</span><span class="boring">        assert_eq!(rustytuple.0, "test");
</span><span class="boring">        assert_eq!(rustytuple.1, "test2");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>Tuple structs with a single field are treated as wrapper types which are described in the
following section. To override this behaviour and ensure that the input is in fact a tuple,
specify the struct as</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTuple((String,));

<span class="boring">use pyo3::types::PyTuple;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let tuple = PyTuple::new_bound(py, vec!["test"]);
</span><span class="boring">
</span><span class="boring">        let rustytuple: RustyTuple = tuple.extract()?;
</span><span class="boring">        assert_eq!((rustytuple.0).0, "test");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h4 id="deriving-frompyobject-for-wrapper-types"><a class="header" href="#deriving-frompyobject-for-wrapper-types">Deriving <a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for wrapper types</a></h4>
<p>The <code>pyo3(transparent)</code> attribute can be used on structs with exactly one field. This results
in extracting directly from the input object, i.e. <code>obj.extract()</code>, rather than trying to access
an item or attribute. This behaviour is enabled per default for newtype structs and tuple-variants
with a single field.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
struct RustyTransparentTupleStruct(String);

#[derive(FromPyObject)]
#[pyo3(transparent)]
struct RustyTransparentStruct {
    inner: String,
}

<span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        let s = PyString::new_bound(py, "test");
</span><span class="boring">
</span><span class="boring">        let tup: RustyTransparentTupleStruct = s.extract()?;
</span><span class="boring">        assert_eq!(tup.0, "test");
</span><span class="boring">
</span><span class="boring">        let stru: RustyTransparentStruct = s.extract()?;
</span><span class="boring">        assert_eq!(stru.inner, "test");
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<h4 id="deriving-frompyobject-for-enums"><a class="header" href="#deriving-frompyobject-for-enums">Deriving <a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> for enums</a></h4>
<p>The <code>FromPyObject</code> derivation for enums generates code that tries to extract the variants in the
order of the fields. As soon as a variant can be extracted successfully, that variant is returned.
This makes it possible to extract Python union types like <code>str | int</code>.</p>
<p>The same customizations and restrictions described for struct derivations apply to enum variants,
i.e. a tuple variant assumes that the input is a Python tuple, and a struct variant defaults to
extracting fields as attributes but can be configured in the same manner. The <code>transparent</code>
attribute can be applied to single-field-variants.</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
<span class="boring">#[derive(Debug)]
</span>enum RustyEnum&lt;'a&gt; {
    Int(usize),                    // input is a positive int
    String(String),                // input is a string
    IntTuple(usize, usize),        // input is a 2-tuple with positive ints
    StringIntTuple(String, usize), // input is a 2-tuple with String and int
    Coordinates3d {
        // needs to be in front of 2d
        x: usize,
        y: usize,
        z: usize,
    },
    Coordinates2d {
        // only gets checked if the input did not have `z`
        #[pyo3(attribute("x"))]
        a: usize,
        #[pyo3(attribute("y"))]
        b: usize,
    },
    #[pyo3(transparent)]
    CatchAll(&amp;'a PyAny), // This extraction never fails
}
<span class="boring">
</span><span class="boring">use pyo3::types::{PyBytes, PyString};
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        {
</span><span class="boring">            let thing = 42_u8.to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                42,
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Int(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let thing = PyString::new_bound(py, "text");
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                "text",
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::String(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let thing = (32_u8, 73_u8).to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (32, 73),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::IntTuple(i, j) =&gt; (i, j),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let thing = ("foo", 73_u8).to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (String::from("foo"), 73),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::StringIntTuple(i, j) =&gt; (i, j),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let module = PyModule::from_code_bound(
</span><span class="boring">                py,
</span><span class="boring">                "class Foo(dict):
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.x = 0
</span><span class="boring">                self.y = 1
</span><span class="boring">                self.z = 2",
</span><span class="boring">                "",
</span><span class="boring">                "",
</span><span class="boring">            )?;
</span><span class="boring">
</span><span class="boring">            let class = module.getattr("Foo")?;
</span><span class="boring">            let instance = class.call0()?;
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = instance.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (0, 1, 2),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Coordinates3d { x, y, z } =&gt; (x, y, z),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let module = PyModule::from_code_bound(
</span><span class="boring">                py,
</span><span class="boring">                "class Foo(dict):
</span><span class="boring">            def __init__(self):
</span><span class="boring">                self.x = 3
</span><span class="boring">                self.y = 4",
</span><span class="boring">                "",
</span><span class="boring">                "",
</span><span class="boring">            )?;
</span><span class="boring">
</span><span class="boring">            let class = module.getattr("Foo")?;
</span><span class="boring">            let instance = class.call0()?;
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = instance.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                (3, 4),
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Coordinates2d { a, b } =&gt; (a, b),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let thing = PyBytes::new_bound(py, b"text");
</span><span class="boring">            let rust_thing: RustyEnum&lt;'_&gt; = thing.extract()?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                b"text",
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::CatchAll(i) =&gt; i.downcast::&lt;PyBytes&gt;()?.as_bytes(),
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>If none of the enum variants match, a <code>PyTypeError</code> containing the names of the
tested variants is returned. The names reported in the error message can be customized
through the <code>#[pyo3(annotation = "name")]</code> attribute, e.g. to use conventional Python type
names:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[derive(FromPyObject)]
<span class="boring">#[derive(Debug)]
</span>enum RustyEnum {
    #[pyo3(transparent, annotation = "str")]
    String(String),
    #[pyo3(transparent, annotation = "int")]
    Int(isize),
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span><span class="boring">        {
</span><span class="boring">            let thing = 42_u8.to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                42,
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::Int(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let thing = "foo".to_object(py);
</span><span class="boring">            let rust_thing: RustyEnum = thing.extract(py)?;
</span><span class="boring">
</span><span class="boring">            assert_eq!(
</span><span class="boring">                "foo",
</span><span class="boring">                match rust_thing {
</span><span class="boring">                    RustyEnum::String(i) =&gt; i,
</span><span class="boring">                    other =&gt; unreachable!("Error extracting: {:?}", other),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let thing = b"foo".to_object(py);
</span><span class="boring">            let error = thing.extract::&lt;RustyEnum&gt;(py).unwrap_err();
</span><span class="boring">            assert!(error.is_instance_of::&lt;pyo3::exceptions::PyTypeError&gt;(py));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>If the input is neither a string nor an integer, the error message will be:
<code>"'&lt;INPUT_TYPE&gt;' cannot be converted to 'str | int'"</code>.</p>
<h4 id="derivefrompyobject-container-attributes"><a class="header" href="#derivefrompyobject-container-attributes"><code>#[derive(FromPyObject)]</code> Container Attributes</a></h4>
<ul>
<li><code>pyo3(transparent)</code>
<ul>
<li>extract the field directly from the object as <code>obj.extract()</code> instead of <code>get_item()</code> or
<code>getattr()</code></li>
<li>Newtype structs and tuple-variants are treated as transparent per default.</li>
<li>only supported for single-field structs and enum variants</li>
</ul>
</li>
<li><code>pyo3(annotation = "name")</code>
<ul>
<li>changes the name of the failed variant in the generated error message in case of failure.</li>
<li>e.g. <code>pyo3("int")</code> reports the variant's type as <code>int</code>.</li>
<li>only supported for enum variants</li>
</ul>
</li>
</ul>
<h4 id="derivefrompyobject-field-attributes"><a class="header" href="#derivefrompyobject-field-attributes"><code>#[derive(FromPyObject)]</code> Field Attributes</a></h4>
<ul>
<li><code>pyo3(attribute)</code>, <code>pyo3(attribute("name"))</code>
<ul>
<li>retrieve the field from an attribute, possibly with a custom name specified as an argument</li>
<li>argument must be a string-literal.</li>
</ul>
</li>
<li><code>pyo3(item)</code>, <code>pyo3(item("key"))</code>
<ul>
<li>retrieve the field from a mapping, possibly with the custom key specified as an argument.</li>
<li>can be any literal that implements <code>ToBorrowedObject</code></li>
</ul>
</li>
<li><code>pyo3(from_py_with = "...")</code>
<ul>
<li>apply a custom function to convert the field from Python the desired Rust type.</li>
<li>the argument must be the name of the function as a string.</li>
<li>the function signature must be <code>fn(&amp;Bound&lt;PyAny&gt;) -&gt; PyResult&lt;T&gt;</code> where <code>T</code> is the Rust type of the argument.</li>
</ul>
</li>
</ul>
<h3 id="intopyt"><a class="header" href="#intopyt"><code>IntoPy&lt;T&gt;</code></a></h3>
<p>This trait defines the to-python conversion for a Rust type. It is usually implemented as
<code>IntoPy&lt;PyObject&gt;</code>, which is the trait needed for returning a value from <code>#[pyfunction]</code> and
<code>#[pymethods]</code>.</p>
<p>All types in PyO3 implement this trait, as does a <code>#[pyclass]</code> which doesn't use <code>extends</code>.</p>
<p>Occasionally you may choose to implement this for custom types which are mapped to Python types
<em>without</em> having a unique python type.</p>
<pre><code class="language-rust">use pyo3::prelude::*;
<span class="boring">#[allow(dead_code)]
</span>struct MyPyObjectWrapper(PyObject);

impl IntoPy&lt;PyObject&gt; for MyPyObjectWrapper {
    fn into_py(self, py: Python&lt;'_&gt;) -&gt; PyObject {
        self.0
    }
}</code></pre>
<h3 id="the-topyobject-trait"><a class="header" href="#the-topyobject-trait">The <code>ToPyObject</code> trait</a></h3>
<p><a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.ToPyObject.html"><code>ToPyObject</code></a> is a conversion trait that allows various objects to be
converted into <a href="https://docs.rs/pyo3/0.21.2/pyo3/type.PyObject.html"><code>PyObject</code></a>. <code>IntoPy&lt;PyObject&gt;</code> serves the
same purpose, except that it consumes <code>self</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-async-and-await"><a class="header" href="#using-async-and-await">Using <code>async</code> and <code>await</code></a></h1>
<p><em>This feature is still in active development. See <a href="https://github.com/PyO3/pyo3/issues/1632">the related issue</a>.</em></p>
<p><code>#[pyfunction]</code> and <code>#[pymethods]</code> attributes also support <code>async fn</code>.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">#[cfg(feature = "experimental-async")] {
</span>use std::{thread, time::Duration};
use futures::channel::oneshot;
use pyo3::prelude::*;

#[pyfunction]
async fn sleep(seconds: f64, result: Option&lt;PyObject&gt;) -&gt; Option&lt;PyObject&gt; {
    let (tx, rx) = oneshot::channel();
    thread::spawn(move || {
        thread::sleep(Duration::from_secs_f64(seconds));
        tx.send(()).unwrap();
    });
    rx.await.unwrap();
    result
}
<span class="boring">}</span></code></pre>
<p><em>Python awaitables instantiated with this method can only be awaited in <em>asyncio</em> context. Other Python async runtime may be supported in the future.</em></p>
<h2 id="send--static-constraint"><a class="header" href="#send--static-constraint"><code>Send + 'static</code> constraint</a></h2>
<p>Resulting future of an <code>async fn</code> decorated by <code>#[pyfunction]</code> must be <code>Send + 'static</code> to be embedded in a Python object.</p>
<p>As a consequence, <code>async fn</code> parameters and return types must also be <code>Send + 'static</code>, so it is not possible to have a signature like <code>async fn does_not_compile&lt;'py&gt;(arg: Bound&lt;'py, PyAny&gt;) -&gt; Bound&lt;'py, PyAny&gt;</code>.</p>
<p>However, there is an exception for method receivers, so async methods can accept <code>&amp;self</code>/<code>&amp;mut self</code>. Note that this means that the class instance is borrowed for as long as the returned future is not completed, even across yield points and while waiting for I/O operations to complete. Hence, other methods cannot obtain exclusive borrows while the future is still being polled. This is the same as how async methods in Rust generally work but it is more problematic for Rust code interfacing with Python code due to pervasive shared mutability. This strongly suggests to prefer shared borrows <code>&amp;self</code> over exclusive ones <code>&amp;mut self</code> to avoid racy borrow check failures at runtime.</p>
<h2 id="implicit-gil-holding"><a class="header" href="#implicit-gil-holding">Implicit GIL holding</a></h2>
<p>Even if it is not possible to pass a <code>py: Python&lt;'py&gt;</code> parameter to <code>async fn</code>, the GIL is still held during the execution of the future – it's also the case for regular <code>fn</code> without <code>Python&lt;'py&gt;</code>/<code>Bound&lt;'py, PyAny&gt;</code> parameter, yet the GIL is held.</p>
<p>It is still possible to get a <code>Python</code> marker using <a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.with_gil"><code>Python::with_gil</code></a>; because <code>with_gil</code> is reentrant and optimized, the cost will be negligible.</p>
<h2 id="release-the-gil-across-await"><a class="header" href="#release-the-gil-across-await">Release the GIL across <code>.await</code></a></h2>
<p>There is currently no simple way to release the GIL when awaiting a future, <em>but solutions are currently in development</em>.</p>
<p>Here is the advised workaround for now:</p>
<pre><code class="language-rust ignore">use std::{
    future::Future,
    pin::{Pin, pin},
    task::{Context, Poll},
};
use pyo3::prelude::*;

struct AllowThreads&lt;F&gt;(F);

impl&lt;F&gt; Future for AllowThreads&lt;F&gt;
where
    F: Future + Unpin + Send,
    F::Output: Send,
{
    type Output = F::Output;

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let waker = cx.waker();
        Python::with_gil(|gil| {
            gil.allow_threads(|| pin!(&amp;mut self.0).poll(&amp;mut Context::from_waker(waker)))
        })
    }
}</code></pre>
<h2 id="cancellation"><a class="header" href="#cancellation">Cancellation</a></h2>
<p>Cancellation on the Python side can be caught using <a href="https://docs.rs/pyo3/0.21.2/pyo3/coroutine/struct.CancelHandle.html"><code>CancelHandle</code></a> type, by annotating a function parameter with <code>#[pyo3(cancel_handle)]</code>.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">#[cfg(feature = "experimental-async")] {
</span>use futures::FutureExt;
use pyo3::prelude::*;
use pyo3::coroutine::CancelHandle;

#[pyfunction]
async fn cancellable(#[pyo3(cancel_handle)] mut cancel: CancelHandle) {
    futures::select! {
        /* _ = ... =&gt; println!("done"), */
        _ = cancel.cancelled().fuse() =&gt; println!("cancelled"),
    }
}
<span class="boring">}</span></code></pre>
<h2 id="the-coroutine-type"><a class="header" href="#the-coroutine-type">The <code>Coroutine</code> type</a></h2>
<p>To make a Rust future awaitable in Python, PyO3 defines a <a href="https://docs.rs/pyo3/0.21.2/pyo3/coroutine/struct.Coroutine.html"><code>Coroutine</code></a> type, which implements the Python <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Coroutine">coroutine protocol</a>.</p>
<p>Each <code>coroutine.send</code> call is translated to a <code>Future::poll</code> call. If a <a href="https://docs.rs/pyo3/0.21.2/pyo3/coroutine/struct.CancelHandle.html"><code>CancelHandle</code></a> parameter is declared, the exception passed to <code>coroutine.throw</code> call is stored in it and can be retrieved with <a href="https://docs.rs/pyo3/0.21.2/pyo3/coroutine/struct.CancelHandle.html#method.cancelled"><code>CancelHandle::cancelled</code></a>; otherwise, it cancels the Rust future, and the exception is reraised;</p>
<p><em>The type does not yet have a public constructor until the design is finalized.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h1>
<p>CPython has the infamous <a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock">Global Interpreter Lock</a>, which prevents several threads from executing Python bytecode in parallel. This makes threading in Python a bad fit for <a href="https://stackoverflow.com/questions/868568/">CPU-bound</a> tasks and often forces developers to accept the overhead of multiprocessing.</p>
<p>In PyO3 parallelism can be easily achieved in Rust-only code. Let's take a look at our <a href="https://github.com/PyO3/pyo3/blob/main/examples/word-count/src/lib.rs">word-count</a> example, where we have a <code>search</code> function that utilizes the <a href="https://github.com/rayon-rs/rayon">rayon</a> crate to count words in parallel.</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

// These traits let us use `par_lines` and `map`.
use rayon::str::ParallelString;
use rayon::iter::ParallelIterator;

/// Count the occurrences of needle in line, case insensitive
fn count_line(line: &amp;str, needle: &amp;str) -&gt; usize {
    let mut total = 0;
    for word in line.split(' ') {
        if word == needle {
            total += 1;
        }
    }
    total
}

#[pyfunction]
fn search(contents: &amp;str, needle: &amp;str) -&gt; usize {
    contents
        .par_lines()
        .map(|line| count_line(line, needle))
        .sum()
}</code></pre>
<p>But let's assume you have a long running Rust function which you would like to execute several times in parallel. For the sake of example let's take a sequential version of the word count:</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn count_line(line: &amp;str, needle: &amp;str) -&gt; usize {
</span><span class="boring">    let mut total = 0;
</span><span class="boring">    for word in line.split(' ') {
</span><span class="boring">        if word == needle {
</span><span class="boring">            total += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    total
</span><span class="boring">}
</span><span class="boring">
</span>fn search_sequential(contents: &amp;str, needle: &amp;str) -&gt; usize {
    contents.lines().map(|line| count_line(line, needle)).sum()
}</code></pre>
<p>To enable parallel execution of this function, the <a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> method can be used to temporarily release the GIL, thus allowing other Python threads to run. We then have a function exposed to the Python runtime which calls <code>search_sequential</code> inside a closure passed to <a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.allow_threads"><code>Python::allow_threads</code></a> to enable true parallelism:</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">fn count_line(line: &amp;str, needle: &amp;str) -&gt; usize {
</span><span class="boring">    let mut total = 0;
</span><span class="boring">    for word in line.split(' ') {
</span><span class="boring">        if word == needle {
</span><span class="boring">            total += 1;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    total
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn search_sequential(contents: &amp;str, needle: &amp;str) -&gt; usize {
</span><span class="boring">   contents.lines().map(|line| count_line(line, needle)).sum()
</span><span class="boring">}
</span>#[pyfunction]
fn search_sequential_allow_threads(py: Python&lt;'_&gt;, contents: &amp;str, needle: &amp;str) -&gt; usize {
    py.allow_threads(|| search_sequential(contents, needle))
}</code></pre>
<p>Now Python threads can use more than one CPU core, resolving the limitation which usually makes multi-threading in Python only good for IO-bound tasks:</p>
<pre><code class="language-Python">from concurrent.futures import ThreadPoolExecutor
from word_count import search_sequential_allow_threads

executor = ThreadPoolExecutor(max_workers=2)

future_1 = executor.submit(
    word_count.search_sequential_allow_threads, contents, needle
)
future_2 = executor.submit(
    word_count.search_sequential_allow_threads, contents, needle
)
result_1 = future_1.result()
result_2 = future_2.result()
</code></pre>
<h2 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h2>
<p>Let's benchmark the <code>word-count</code> example to verify that we really did unlock parallelism with PyO3.</p>
<p>We are using <code>pytest-benchmark</code> to benchmark four word count functions:</p>
<ol>
<li>Pure Python version</li>
<li>Rust parallel version</li>
<li>Rust sequential version</li>
<li>Rust sequential version executed twice with two Python threads</li>
</ol>
<p>The benchmark script can be found <a href="https://github.com/PyO3/pyo3/blob/main/examples/word-count/tests/test_word_count.py">here</a>, and we can run <code>nox</code> in the <code>word-count</code> folder to benchmark these functions.</p>
<p>While the results of the benchmark of course depend on your machine, the relative results should be similar to this (mid 2020):</p>
<pre><code class="language-text">-------------------------------------------------------------------------------------------------- benchmark: 4 tests -------------------------------------------------------------------------------------------------
Name (time in ms)                                          Min                Max               Mean            StdDev             Median               IQR            Outliers       OPS            Rounds  Iterations
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
test_word_count_rust_parallel                           1.7315 (1.0)       4.6495 (1.0)       1.9972 (1.0)      0.4299 (1.0)       1.8142 (1.0)      0.2049 (1.0)         40;46  500.6943 (1.0)         375           1
test_word_count_rust_sequential                         7.3348 (4.24)     10.3556 (2.23)      8.0035 (4.01)     0.7785 (1.81)      7.5597 (4.17)     0.8641 (4.22)         26;5  124.9457 (0.25)        121           1
test_word_count_rust_sequential_twice_with_threads      7.9839 (4.61)     10.3065 (2.22)      8.4511 (4.23)     0.4709 (1.10)      8.2457 (4.55)     0.3927 (1.92)        17;17  118.3274 (0.24)        114           1
test_word_count_python_sequential                      27.3985 (15.82)    45.4527 (9.78)     28.9604 (14.50)    4.1449 (9.64)     27.5781 (15.20)    0.4638 (2.26)          3;5   34.5299 (0.07)         35           1
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre>
<p>You can see that the Python threaded version is not much slower than the Rust sequential version, which means compared to an execution on a single CPU core the speed has doubled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>PyO3's attributes (<code>#[pyclass]</code>, <code>#[pymodule]</code>, etc.) are <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macros</a>, which means that they rewrite the source of the annotated item. You can view the generated source with the following command, which also expands a few other things:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>(You might need to install <a href="https://github.com/rust-lang-nursery/rustfmt">rustfmt</a> if you don't already have it.)</p>
<p>You can also debug classic <code>!</code>-macros by adding <code>-Z trace-macros</code>:</p>
<pre><code class="language-bash">cargo rustc --profile=check -- -Z unstable-options --pretty=expanded -Z trace-macros &gt; expanded.rs; rustfmt expanded.rs
</code></pre>
<p>Note that those commands require using the nightly build of rust and may occasionally have bugs. See <a href="https://github.com/dtolnay/cargo-expand">cargo expand</a> for a more elaborate and stable version of those commands.</p>
<h2 id="running-with-valgrind"><a class="header" href="#running-with-valgrind">Running with Valgrind</a></h2>
<p>Valgrind is a tool to detect memory management bugs such as memory leaks.</p>
<p>You first need to install a debug build of Python, otherwise Valgrind won't produce usable results. In Ubuntu there's e.g. a <code>python3-dbg</code> package.</p>
<p>Activate an environment with the debug interpreter and recompile. If you're on Linux, use <code>ldd</code> with the name of your binary and check that you're linking e.g. <code>libpython3.7d.so.1.0</code> instead of <code>libpython3.7.so.1.0</code>.</p>
<p><a href="https://raw.githubusercontent.com/python/cpython/master/Misc/valgrind-python.supp">Download the suppressions file for CPython</a>.</p>
<p>Run Valgrind with <code>valgrind --suppressions=valgrind-python.supp ./my-command --with-options</code></p>
<h2 id="getting-a-stacktrace"><a class="header" href="#getting-a-stacktrace">Getting a stacktrace</a></h2>
<p>The best start to investigate a crash such as an segmentation fault is a backtrace. You can set <code>RUST_BACKTRACE=1</code> as an environment variable to get the stack trace on a <code>panic!</code>. Alternatively you can use a debugger such as <code>gdb</code> to explore the issue. Rust provides a wrapper, <code>rust-gdb</code>, which has pretty-printers for inspecting Rust variables. Since PyO3 uses <code>cdylib</code> for Python shared objects, it does not receive the pretty-print debug hooks in <code>rust-gdb</code> (<a href="https://github.com/rust-lang/rust/issues/96365">rust-lang/rust#96365</a>). The mentioned issue contains a workaround for enabling pretty-printers in this case.</p>
<ul>
<li>Link against a debug build of python as described in the previous chapter</li>
<li>Run <code>rust-gdb &lt;my-binary&gt;</code></li>
<li>Set a breakpoint (<code>b</code>) on <code>rust_panic</code> if you are investigating a <code>panic!</code></li>
<li>Enter <code>r</code> to run</li>
<li>After the crash occurred, enter <code>bt</code> or <code>bt full</code> to print the stacktrace</li>
</ul>
<p>Often it is helpful to run a small piece of Python code to exercise a section of Rust.</p>
<pre><code class="language-console">rust-gdb --args python -c "import my_package; my_package.sum_to_string(1, 2)"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-reference"><a class="header" href="#features-reference">Features reference</a></h1>
<p>PyO3 provides a number of Cargo features to customize functionality. This chapter of the guide provides detail on each of them.</p>
<p>By default, only the <code>macros</code> feature is enabled.</p>
<h2 id="features-for-extension-module-authors"><a class="header" href="#features-for-extension-module-authors">Features for extension module authors</a></h2>
<h3 id="extension-module"><a class="header" href="#extension-module"><code>extension-module</code></a></h3>
<p>This feature is required when building a Python extension module using PyO3.</p>
<p>It tells PyO3's build script to skip linking against <code>libpython.so</code> on Unix platforms, where this must not be done.</p>
<p>See the <a href="building-and-distribution.html#the-extension-module-feature">building and distribution</a> section for further detail.</p>
<h3 id="abi3"><a class="header" href="#abi3"><code>abi3</code></a></h3>
<p>This feature is used when building Python extension modules to create wheels which are compatible with multiple Python versions.</p>
<p>It restricts PyO3's API to a subset of the full Python API which is guaranteed by <a href="https://www.python.org/dev/peps/pep-0384/">PEP 384</a> to be forwards-compatible with future Python versions.</p>
<p>See the <a href="building-and-distribution.html#py_limited_apiabi3">building and distribution</a> section for further detail.</p>
<h3 id="the-abi3-pyxy-features"><a class="header" href="#the-abi3-pyxy-features">The <code>abi3-pyXY</code> features</a></h3>
<p>(<code>abi3-py37</code>, <code>abi3-py38</code>, <code>abi3-py39</code>, <code>abi3-py310</code> and <code>abi3-py311</code>)</p>
<p>These features are extensions of the <code>abi3</code> feature to specify the exact minimum Python version which the multiple-version-wheel will support.</p>
<p>See the <a href="building-and-distribution.html#minimum-python-version-for-abi3">building and distribution</a> section for further detail.</p>
<h3 id="generate-import-lib"><a class="header" href="#generate-import-lib"><code>generate-import-lib</code></a></h3>
<p>This experimental feature is used to generate import libraries for Python DLL
for MinGW-w64 and MSVC (cross-)compile targets.</p>
<p>Enabling it allows to (cross-)compile extension modules to any Windows targets
without having to install the Windows Python distribution files for the target.</p>
<p>See the <a href="building-and-distribution.html#building-abi3-extensions-without-a-python-interpreter">building and distribution</a>
section for further detail.</p>
<h2 id="features-for-embedding-python-in-rust"><a class="header" href="#features-for-embedding-python-in-rust">Features for embedding Python in Rust</a></h2>
<h3 id="auto-initialize"><a class="header" href="#auto-initialize"><code>auto-initialize</code></a></h3>
<p>This feature changes <a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.with_gil"><code>Python::with_gil</code></a> to automatically initialize a Python interpreter (by calling <a href="https://docs.rs/pyo3/0.21.2/pyo3/fn.prepare_freethreaded_python.html"><code>prepare_freethreaded_python</code></a>) if needed.</p>
<p>If you do not enable this feature, you should call <code>pyo3::prepare_freethreaded_python()</code> before attempting to call any other Python APIs.</p>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="experimental-async"><a class="header" href="#experimental-async"><code>experimental-async</code></a></h3>
<p>This feature adds support for <code>async fn</code> in <code>#[pyfunction]</code> and <code>#[pymethods]</code>.</p>
<p>The feature has some unfinished refinements and performance improvements. To help finish this off, see <a href="https://github.com/PyO3/pyo3/issues/1632">issue #1632</a> and its associated draft PRs.</p>
<h3 id="experimental-declarative-modules"><a class="header" href="#experimental-declarative-modules"><code>experimental-declarative-modules</code></a></h3>
<p>This feature allows to declare Python modules using <code>#[pymodule] mod my_module { ... }</code> syntax.</p>
<p>The feature has some unfinished refinements and edge cases. To help finish this off, see <a href="https://github.com/PyO3/pyo3/issues/3900">issue #3900</a>.</p>
<h3 id="experimental-inspect"><a class="header" href="#experimental-inspect"><code>experimental-inspect</code></a></h3>
<p>This feature adds the <code>pyo3::inspect</code> module, as well as <code>IntoPy::type_output</code> and <code>FromPyObject::type_input</code> APIs to produce Python type "annotations" for Rust types.</p>
<p>This is a first step towards adding first-class support for generating type annotations automatically in PyO3, however work is needed to finish this off. All feedback and offers of help welcome on <a href="https://github.com/PyO3/pyo3/issues/2454">issue #2454</a>.</p>
<h3 id="gil-refs"><a class="header" href="#gil-refs"><code>gil-refs</code></a></h3>
<p>This feature is a backwards-compatibility feature to allow continued use of the "GIL Refs" APIs deprecated in PyO3 0.21. These APIs have performance drawbacks and soundness edge cases which the newer <code>Bound&lt;T&gt;</code> smart pointer and accompanying APIs resolve.</p>
<p>This feature and the APIs it enables is expected to be removed in a future PyO3 version.</p>
<h3 id="macros-1"><a class="header" href="#macros-1"><code>macros</code></a></h3>
<p>This feature enables a dependency on the <code>pyo3-macros</code> crate, which provides the procedural macros portion of PyO3's API:</p>
<ul>
<li><code>#[pymodule]</code></li>
<li><code>#[pyfunction]</code></li>
<li><code>#[pyclass]</code></li>
<li><code>#[pymethods]</code></li>
<li><code>#[derive(FromPyObject)]</code></li>
</ul>
<p>It also provides the <code>py_run!</code> macro.</p>
<p>These macros require a number of dependencies which may not be needed by users who just need PyO3 for Python FFI. Disabling this feature enables faster builds for those users, as these dependencies will not be built if this feature is disabled.</p>
<blockquote>
<p>This feature is enabled by default. To disable it, set <code>default-features = false</code> for the <code>pyo3</code> entry in your Cargo.toml.</p>
</blockquote>
<h3 id="multiple-pymethods"><a class="header" href="#multiple-pymethods"><code>multiple-pymethods</code></a></h3>
<p>This feature enables a dependency on <code>inventory</code>, which enables each <code>#[pyclass]</code> to have more than one <code>#[pymethods]</code> block. This feature also requires a minimum Rust version of 1.62 due to limitations in the <code>inventory</code> crate.</p>
<p>Most users should only need a single <code>#[pymethods]</code> per <code>#[pyclass]</code>. In addition, not all platforms (e.g. Wasm) are supported by <code>inventory</code>. For this reason this feature is not enabled by default, meaning fewer dependencies and faster compilation for the majority of users.</p>
<p>See <a href="class.html#implementation-details">the <code>#[pyclass]</code> implementation details</a> for more information.</p>
<h3 id="nightly"><a class="header" href="#nightly"><code>nightly</code></a></h3>
<p>The <code>nightly</code> feature needs the nightly Rust compiler. This allows PyO3 to use the <code>auto_traits</code> and <code>negative_impls</code> features to fix the <code>Python::allow_threads</code> function.</p>
<h3 id="resolve-config"><a class="header" href="#resolve-config"><code>resolve-config</code></a></h3>
<p>The <code>resolve-config</code> feature of the <code>pyo3-build-config</code> crate controls whether that crate's
build script automatically resolves a Python interpreter / build configuration. This feature is primarily useful when building PyO3
itself. By default this feature is not enabled, meaning you can freely use <code>pyo3-build-config</code> as a standalone library to read or write PyO3 build configuration files or resolve metadata about a Python interpreter.</p>
<h2 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional Dependencies</a></h2>
<p>These features enable conversions between Python types and types from other Rust crates, enabling easy access to the rest of the Rust ecosystem.</p>
<h3 id="anyhow"><a class="header" href="#anyhow"><code>anyhow</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/anyhow">anyhow</a>. Enables a conversion from <a href="https://docs.rs/anyhow">anyhow</a>’s <a href="https://docs.rs/anyhow/latest/anyhow/struct.Error.html"><code>Error</code></a> type to <a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.PyErr.html"><code>PyErr</code></a>, for easy error handling.</p>
<h3 id="chrono"><a class="header" href="#chrono"><code>chrono</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/chrono">chrono</a>. Enables a conversion from <a href="https://docs.rs/chrono">chrono</a>'s types to python:</p>
<ul>
<li><a href="https://docs.rs/chrono/latest/chrono/struct.TimeDelta.html">TimeDelta</a> -&gt; <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyDelta.html"><code>PyDelta</code></a></li>
<li><a href="https://docs.rs/chrono/latest/chrono/offset/struct.FixedOffset.html">FixedOffset</a> -&gt; <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyDelta.html"><code>PyDelta</code></a></li>
<li><a href="https://docs.rs/chrono/latest/chrono/offset/struct.Utc.html">Utc</a> -&gt; <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyTzInfo.html"><code>PyTzInfo</code></a></li>
<li><a href="https://docs.rs/chrono/latest/chrono/naive/struct.NaiveDate.html">NaiveDate</a> -&gt; <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyDate.html"><code>PyDate</code></a></li>
<li><a href="https://docs.rs/chrono/latest/chrono/naive/struct.NaiveTime.html">NaiveTime</a> -&gt; <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyTime.html"><code>PyTime</code></a></li>
<li><a href="https://docs.rs/chrono/latest/chrono/struct.DateTime.html">DateTime</a> -&gt; <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyDateTime.html"><code>PyDateTime</code></a></li>
</ul>
<h3 id="chrono-tz"><a class="header" href="#chrono-tz"><code>chrono-tz</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/chrono-tz">chrono-tz</a>.
Enables conversion from and to <a href="https://docs.rs/chrono-tz/latest/chrono_tz/enum.Tz.html"><code>Tz</code></a>.
It requires at least Python 3.9.</p>
<h3 id="either"><a class="header" href="#either"><code>either</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/either">either</a>. Enables a conversions into <a href="https://docs.rs/either">either</a>’s <a href="https://docs.rs/either/latest/either/enum.Either.html"><code>Either</code></a> type.</p>
<h3 id="eyre"><a class="header" href="#eyre"><code>eyre</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/eyre">eyre</a>. Enables a conversion from <a href="https://docs.rs/eyre">eyre</a>’s <a href="https://docs.rs/eyre/latest/eyre/struct.Report.html"><code>Report</code></a> type to <a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.PyErr.html"><code>PyErr</code></a>, for easy error handling.</p>
<h3 id="hashbrown"><a class="header" href="#hashbrown"><code>hashbrown</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/hashbrown">hashbrown</a> and enables conversions into its <a href="https://docs.rs/hashbrown/latest/hashbrown/struct.HashMap.html"><code>HashMap</code></a> and <a href="https://docs.rs/hashbrown/latest/hashbrown/struct.HashSet.html"><code>HashSet</code></a> types.</p>
<h3 id="indexmap"><a class="header" href="#indexmap"><code>indexmap</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/indexmap">indexmap</a> and enables conversions into its <a href="https://docs.rs/indexmap/latest/indexmap/map/struct.IndexMap.html"><code>IndexMap</code></a> type.</p>
<h3 id="num-bigint"><a class="header" href="#num-bigint"><code>num-bigint</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/num-bigint">num-bigint</a> and enables conversions into its <a href="https://docs.rs/num-bigint/latest/num_bigint/struct.BigInt.html"><code>BigInt</code></a> and <a href="https://docs.rs/num-bigint/latest/num_bigint/struct.BigUint.html"><code>BigUint</code></a> types.</p>
<h3 id="num-complex"><a class="header" href="#num-complex"><code>num-complex</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/num-complex">num-complex</a> and enables conversions into its <a href="https://docs.rs/num-complex/latest/num_complex/struct.Complex.html"><code>Complex</code></a> type.</p>
<h3 id="rust_decimal"><a class="header" href="#rust_decimal"><code>rust_decimal</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/rust_decimal">rust_decimal</a> and enables conversions into its <a href="https://docs.rs/rust_decimal/latest/rust_decimal/struct.Decimal.html"><code>Decimal</code></a> type.</p>
<h3 id="serde"><a class="header" href="#serde"><code>serde</code></a></h3>
<p>Enables (de)serialization of <code>Py&lt;T&gt;</code> objects via <a href="https://serde.rs/">serde</a>.
This allows to use <a href="https://serde.rs/derive.html"><code>#[derive(Serialize, Deserialize)</code></a> on structs that hold references to <code>#[pyclass]</code> instances</p>
<pre><code class="language-rust"><span class="boring">#[cfg(feature = "serde")]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">mod serde_only {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span>
#[pyclass]
#[derive(Serialize, Deserialize)]
struct Permission {
    name: String,
}

#[pyclass]
#[derive(Serialize, Deserialize)]
struct User {
    username: String,
    permissions: Vec&lt;Py&lt;Permission&gt;&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="smallvec"><a class="header" href="#smallvec"><code>smallvec</code></a></h3>
<p>Adds a dependency on <a href="https://docs.rs/smallvec">smallvec</a> and enables conversions into its <a href="https://docs.rs/smallvec/latest/smallvec/struct.SmallVec.html"><code>SmallVec</code></a> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory management</a></h1>
<div class="warning">
<p>⚠️ Warning: API update in progress 🛠️</p>
<p>PyO3 0.21 has introduced a significant new API, termed the "Bound" API after the new smart pointer <code>Bound&lt;T&gt;</code>.</p>
<p>This section on memory management is heavily weighted towards the now-deprecated "GIL Refs" API, which suffered from the drawbacks detailed here as well as CPU overheads.</p>
<p>See <a href="./types.html#pyo3s-smart-pointers">the smart pointer types</a> for description on the new, simplified, memory model of the Bound API, which is built as a thin wrapper on Python reference counting.</p>
</div>
<p>Rust and Python have very different notions of memory management.  Rust has
a strict memory model with concepts of ownership, borrowing, and lifetimes,
where memory is freed at predictable points in program execution.  Python has
a looser memory model in which variables are reference-counted with shared,
mutable state by default. A global interpreter lock (GIL) is needed to prevent
race conditions, and a garbage collector is needed to break reference cycles.
Memory in Python is freed eventually by the garbage collector, but not usually
in a predictable way.</p>
<p>PyO3 bridges the Rust and Python memory models with two different strategies for
accessing memory allocated on Python's heap from inside Rust. These are
GIL Refs such as <code>&amp;'py PyAny</code>, and GIL-independent <code>Py&lt;Any&gt;</code> smart pointers.</p>
<h2 id="gil-bound-memory"><a class="header" href="#gil-bound-memory">GIL-bound memory</a></h2>
<p>PyO3's GIL Refs such as <code>&amp;'py PyAny</code> make PyO3 more ergonomic to
use by ensuring that their lifetime can never be longer than the duration the
Python GIL is held.  This means that most of PyO3's API can assume the GIL is
held. (If PyO3 could not assume this, every PyO3 API would need to take a
<code>Python</code> GIL token to prove that the GIL is held.)  This allows us to write
very simple and easy-to-understand programs like this:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    #[allow(deprecated)] // py.eval() is part of the GIL Refs API
    let hello = py
        .eval("\"Hello World!\"", None, None)?
        .downcast::&lt;PyString&gt;()?;
    println!("Python says: {}", hello);
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>Internally, calling <code>Python::with_gil()</code> creates a <code>GILPool</code> which owns the
memory pointed to by the reference.  In the example above, the lifetime of the
reference <code>hello</code> is bound to the <code>GILPool</code>.  When the <code>with_gil()</code> closure ends
the <code>GILPool</code> is also dropped and the Python reference counts of the variables
it owns are decreased, releasing them to the Python garbage collector.  Most
of the time we don't have to think about this, but consider the following:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    for _ in 0..10 {
        #[allow(deprecated)] // py.eval() is part of the GIL Refs API
        let hello = py
            .eval("\"Hello World!\"", None, None)?
            .downcast::&lt;PyString&gt;()?;
        println!("Python says: {}", hello);
    }
    // There are 10 copies of `hello` on Python's heap here.
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>We might assume that the <code>hello</code> variable's memory is freed at the end of each
loop iteration, but in fact we create 10 copies of <code>hello</code> on Python's heap.
This may seem surprising at first, but it is completely consistent with Rust's
memory model.  The <code>hello</code> variable is dropped at the end of each loop, but it
is only a reference to the memory owned by the <code>GILPool</code>, and its lifetime is
bound to the <code>GILPool</code>, not the for loop.  The <code>GILPool</code> isn't dropped until
the end of the <code>with_gil()</code> closure, at which point the 10 copies of <code>hello</code>
are finally released to the Python garbage collector.</p>
<div class="warning">
<p>⚠️ Warning: <code>GILPool</code> is no longer the preferred way to manage memory with PyO3 🛠️</p>
<p>PyO3 0.21 has introduced a new API known as the Bound API, which doesn't have the same surprising results. Instead, each <code>Bound&lt;T&gt;</code> smart pointer releases the Python reference immediately on drop. See <a href="./types.html#pyo3s-smart-pointers">the smart pointer types</a> for more details.</p>
</div>
<p>In general we don't want unbounded memory growth during loops!  One workaround
is to acquire and release the GIL with each iteration of the loop.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>for _ in 0..10 {
    Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
        #[allow(deprecated)] // py.eval() is part of the GIL Refs API
        let hello = py
            .eval("\"Hello World!\"", None, None)?
            .downcast::&lt;PyString&gt;()?;
        println!("Python says: {}", hello);
        Ok(())
    })?; // only one copy of `hello` at a time
}
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>It might not be practical or performant to acquire and release the GIL so many
times.  Another workaround is to work with the <code>GILPool</code> object directly, but
this is unsafe.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    for _ in 0..10 {
        #[allow(deprecated)] // `new_pool` is not needed in code not using the GIL Refs API
        let pool = unsafe { py.new_pool() };
        let py = pool.python();
        #[allow(deprecated)] // py.eval() is part of the GIL Refs API
        let hello = py
            .eval("\"Hello World!\"", None, None)?
            .downcast::&lt;PyString&gt;()?;
        println!("Python says: {}", hello);
    }
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>The unsafe method <code>Python::new_pool</code> allows you to create a nested <code>GILPool</code>
from which you can retrieve a new <code>py: Python</code> GIL token.  Variables created
with this new GIL token are bound to the nested <code>GILPool</code> and will be released
when the nested <code>GILPool</code> is dropped.  Here, the nested <code>GILPool</code> is dropped
at the end of each loop iteration, before the <code>with_gil()</code> closure ends.</p>
<p>When doing this, you must be very careful to ensure that once the <code>GILPool</code> is
dropped you do not retain access to any owned references created after the
<code>GILPool</code> was created.  Read the
<a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.new_pool">documentation for <code>Python::new_pool()</code></a>
for more information on safety.</p>
<p>This memory management can also be applicable when writing extension modules.
<code>#[pyfunction]</code> and <code>#[pymethods]</code> will create a <code>GILPool</code> which lasts the entire
function call, releasing objects when the function returns. Most functions only create
a few objects, meaning this doesn't have a significant impact. Occasionally functions
with long complex loops may need to use <code>Python::new_pool</code> as shown above.</p>
<div class="warning">
<p>⚠️ Warning: <code>GILPool</code> is no longer the preferred way to manage memory with PyO3 🛠️</p>
<p>PyO3 0.21 has introduced a new API known as the Bound API, which doesn't have the same surprising results. Instead, each <code>Bound&lt;T&gt;</code> smart pointer releases the Python reference immediately on drop. See <a href="./types.html#pyo3s-smart-pointers">the smart pointer types</a> for more details.</p>
</div>
<h2 id="gil-independent-memory"><a class="header" href="#gil-independent-memory">GIL-independent memory</a></h2>
<p>Sometimes we need a reference to memory on Python's heap that can outlive the
GIL.  Python's <code>Py&lt;PyAny&gt;</code> is analogous to <code>Arc&lt;T&gt;</code>, but for variables whose
memory is allocated on Python's heap.  Cloning a <code>Py&lt;PyAny&gt;</code> increases its
internal reference count just like cloning <code>Arc&lt;T&gt;</code>.  The smart pointer can
outlive the "GIL is held" period in which it was created.  It isn't magic,
though.  We need to reacquire the GIL to access the memory pointed to by the
<code>Py&lt;PyAny&gt;</code>.</p>
<p>What happens to the memory when the last <code>Py&lt;PyAny&gt;</code> is dropped and its
reference count reaches zero?  It depends whether or not we are holding the GIL.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    #[allow(deprecated)] // py.eval() is part of the GIL Refs API
    let hello: Py&lt;PyString&gt; = py.eval("\"Hello World!\"", None, None)?.extract()?;
    #[allow(deprecated)] // as_ref is part of the GIL Refs API
    {
        println!("Python says: {}", hello.as_ref(py));
    }
    Ok(())
})?;
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>At the end of the <code>Python::with_gil()</code> closure <code>hello</code> is dropped, and then the
GIL is dropped.  Since <code>hello</code> is dropped while the GIL is still held by the
current thread, its memory is released to the Python garbage collector
immediately.</p>
<p>This example wasn't very interesting.  We could have just used a GIL-bound
<code>&amp;PyString</code> reference.  What happens when the last <code>Py&lt;Any&gt;</code> is dropped while
we are <em>not</em> holding the GIL?</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>let hello: Py&lt;PyString&gt; = Python::with_gil(|py| {
    #[allow(deprecated)] // py.eval() is part of the GIL Refs API
    py.eval("\"Hello World!\"", None, None)?.extract()
})?;
// Do some stuff...
// Now sometime later in the program we want to access `hello`.
Python::with_gil(|py| {
    #[allow(deprecated)]  // as_ref is part of the deprecated "GIL Refs" API.
    let hello = hello.as_ref(py);
    println!("Python says: {}", hello);
});
// Now we're done with `hello`.
drop(hello); // Memory *not* released here.
// Sometime later we need the GIL again for something...
Python::with_gil(|py|
    // Memory for `hello` is released here.
<span class="boring">()
</span>);
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>When <code>hello</code> is dropped <em>nothing</em> happens to the pointed-to memory on Python's
heap because nothing <em>can</em> happen if we're not holding the GIL.  Fortunately,
the memory isn't leaked.  PyO3 keeps track of the memory internally and will
release it the next time we acquire the GIL.</p>
<p>We can avoid the delay in releasing memory if we are careful to drop the
<code>Py&lt;Any&gt;</code> while the GIL is held.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // py.eval() is part of the GIL Refs API
let hello: Py&lt;PyString&gt; =
    Python::with_gil(|py| py.eval("\"Hello World!\"", None, None)?.extract())?;
// Do some stuff...
// Now sometime later in the program:
Python::with_gil(|py| {
    #[allow(deprecated)] // as_ref is part of the GIL Refs API
    {
        println!("Python says: {}", hello.as_ref(py));
    }
    drop(hello); // Memory released here.
});
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<p>We could also have used <code>Py::into_ref()</code>, which consumes <code>self</code>, instead of
<code>Py::as_ref()</code>.  But note that in addition to being slower than <code>as_ref()</code>,
<code>into_ref()</code> binds the memory to the lifetime of the <code>GILPool</code>, which means
that rather than being released immediately, the memory will not be released
until the GIL is dropped.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyString;
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // py.eval() is part of the GIL Refs API
let hello: Py&lt;PyString&gt; =
    Python::with_gil(|py| py.eval("\"Hello World!\"", None, None)?.extract())?;
// Do some stuff...
// Now sometime later in the program:
Python::with_gil(|py| {
    #[allow(deprecated)] // into_ref is part of the GIL Refs API
    {
        println!("Python says: {}", hello.into_ref(py));
    }
    // Memory not released yet.
    // Do more stuff...
    // Memory released here at end of `with_gil()` closure.
});
<span class="boring">Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<p>To achieve the best possible performance, it is useful to be aware of several tricks and sharp edges concerning PyO3's API.</p>
<h2 id="extract-versus-downcast"><a class="header" href="#extract-versus-downcast"><code>extract</code> versus <code>downcast</code></a></h2>
<p>Pythonic API implemented using PyO3 are often polymorphic, i.e. they will accept <code>&amp;Bound&lt;'_, PyAny&gt;</code> and try to turn this into multiple more concrete types to which the requested operation is applied. This often leads to chains of calls to <code>extract</code>, e.g.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::{exceptions::PyTypeError, types::PyList};
</span>
fn frobnicate_list&lt;'py&gt;(list: &amp;Bound&lt;'_, PyList&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; {
    todo!()
}

fn frobnicate_vec&lt;'py&gt;(vec: Vec&lt;Bound&lt;'py, PyAny&gt;&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; {
    todo!()
}

#[pyfunction]
fn frobnicate&lt;'py&gt;(value: &amp;Bound&lt;'py, PyAny&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; {
    if let Ok(list) = value.extract::&lt;Bound&lt;'_, PyList&gt;&gt;() {
        frobnicate_list(&amp;list)
    } else if let Ok(vec) = value.extract::&lt;Vec&lt;Bound&lt;'_, PyAny&gt;&gt;&gt;() {
        frobnicate_vec(vec)
    } else {
        Err(PyTypeError::new_err("Cannot frobnicate that type."))
    }
}</code></pre>
<p>This suboptimal as the <code>FromPyObject&lt;T&gt;</code> trait requires <code>extract</code> to have a <code>Result&lt;T, PyErr&gt;</code> return type. For native types like <code>PyList</code>, it faster to use <code>downcast</code> (which <code>extract</code> calls internally) when the error value is ignored. This avoids the costly conversion of a <code>PyDowncastError</code> to a <code>PyErr</code> required to fulfil the <code>FromPyObject</code> contract, i.e.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::{exceptions::PyTypeError, types::PyList};
</span><span class="boring">fn frobnicate_list&lt;'py&gt;(list: &amp;Bound&lt;'_, PyList&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; { todo!() }
</span><span class="boring">fn frobnicate_vec&lt;'py&gt;(vec: Vec&lt;Bound&lt;'py, PyAny&gt;&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; { todo!() }
</span><span class="boring">
</span>#[pyfunction]
fn frobnicate&lt;'py&gt;(value: &amp;Bound&lt;'py, PyAny&gt;) -&gt; PyResult&lt;Bound&lt;'py, PyAny&gt;&gt; {
    // Use `downcast` instead of `extract` as turning `PyDowncastError` into `PyErr` is quite costly.
    if let Ok(list) = value.downcast::&lt;PyList&gt;() {
        frobnicate_list(list)
    } else if let Ok(vec) = value.extract::&lt;Vec&lt;Bound&lt;'_, PyAny&gt;&gt;&gt;() {
        frobnicate_vec(vec)
    } else {
        Err(PyTypeError::new_err("Cannot frobnicate that type."))
    }
}</code></pre>
<h2 id="access-to-bound-implies-access-to-gil-token"><a class="header" href="#access-to-bound-implies-access-to-gil-token">Access to Bound implies access to GIL token</a></h2>
<p>Calling <code>Python::with_gil</code> is effectively a no-op when the GIL is already held, but checking that this is the case still has a cost. If an existing GIL token can not be accessed, for example when implementing a pre-existing trait, but a GIL-bound reference is available, this cost can be avoided by exploiting that access to GIL-bound reference gives zero-cost access to a GIL token via <code>Bound::py</code>.</p>
<p>For example, instead of writing</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span>
struct Foo(Py&lt;PyList&gt;);

struct FooBound&lt;'py&gt;(Bound&lt;'py, PyList&gt;);

impl PartialEq&lt;Foo&gt; for FooBound&lt;'_&gt; {
    fn eq(&amp;self, other: &amp;Foo) -&gt; bool {
        Python::with_gil(|py| {
            let len = other.0.bind(py).len();
            self.0.len() == len
        })
    }
}</code></pre>
<p>use the more efficient</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">struct Foo(Py&lt;PyList&gt;);
</span><span class="boring">struct FooBound&lt;'py&gt;(Bound&lt;'py, PyList&gt;);
</span><span class="boring">
</span>impl PartialEq&lt;Foo&gt; for FooBound&lt;'_&gt; {
    fn eq(&amp;self, other: &amp;Foo) -&gt; bool {
        // Access to `&amp;Bound&lt;'py, PyAny&gt;` implies access to `Python&lt;'py&gt;`.
        let py = self.0.py();
        let len = other.0.bind(py).len();
        self.0.len() == len
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced topics</a></h1>
<h2 id="ffi"><a class="header" href="#ffi">FFI</a></h2>
<p>PyO3 exposes much of Python's C API through the <code>ffi</code> module.</p>
<p>The C API is naturally unsafe and requires you to manage reference counts, errors and specific invariants yourself. Please refer to the <a href="https://docs.python.org/3/c-api/">C API Reference Manual</a> and <a href="https://doc.rust-lang.org/nightly/nomicon/ffi.html">The Rustonomicon</a> before using any function from that API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-and-distribution"><a class="header" href="#building-and-distribution">Building and distribution</a></h1>
<p>This chapter of the guide goes into detail on how to build and distribute projects using PyO3. The way to achieve this is very different depending on whether the project is a Python module implemented in Rust, or a Rust binary embedding Python. For both types of project there are also common problems such as the Python version to build for and the <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linker</a> arguments to use.</p>
<p>The material in this chapter is intended for users who have already read the PyO3 <a href="./index.html">README</a>. It covers in turn the choices that can be made for Python modules and for Rust binaries. There is also a section at the end about cross-compiling projects using PyO3.</p>
<p>There is an additional sub-chapter dedicated to <a href="./building-and-distribution/multiple-python-versions.html">supporting multiple Python versions</a>.</p>
<h2 id="configuring-the-python-version"><a class="header" href="#configuring-the-python-version">Configuring the Python version</a></h2>
<p>PyO3 uses a build script (backed by the <a href="https://github.com/PyO3/pyo3/tree/main/pyo3-build-config"><code>pyo3-build-config</code></a> crate) to determine the Python version and set the correct linker arguments. By default it will attempt to use the following in order:</p>
<ul>
<li>Any active Python virtualenv.</li>
<li>The <code>python</code> executable (if it's a Python 3 interpreter).</li>
<li>The <code>python3</code> executable.</li>
</ul>
<p>You can override the Python interpreter by setting the <code>PYO3_PYTHON</code> environment variable, e.g. <code>PYO3_PYTHON=python3.7</code>, <code>PYO3_PYTHON=/usr/bin/python3.9</code>, or even a PyPy interpreter <code>PYO3_PYTHON=pypy3</code>.</p>
<p>Once the Python interpreter is located, <code>pyo3-build-config</code> executes it to query the information in the <code>sysconfig</code> module which is needed to configure the rest of the compilation.</p>
<p>To validate the configuration which PyO3 will use, you can run a compilation with the environment variable <code>PYO3_PRINT_CONFIG=1</code> set. An example output of doing this is shown below:</p>
<pre><code class="language-console">$ PYO3_PRINT_CONFIG=1 cargo build
   Compiling pyo3 v0.14.1 (/home/david/dev/pyo3)
error: failed to run custom build command for `pyo3 v0.14.1 (/home/david/dev/pyo3)`

Caused by:
  process didn't exit successfully: `/home/david/dev/pyo3/target/debug/build/pyo3-7a8cf4fe22e959b7/build-script-build` (exit status: 101)
  --- stdout
  cargo:rerun-if-env-changed=PYO3_CROSS
  cargo:rerun-if-env-changed=PYO3_CROSS_LIB_DIR
  cargo:rerun-if-env-changed=PYO3_CROSS_PYTHON_VERSION
  cargo:rerun-if-env-changed=PYO3_PRINT_CONFIG

  -- PYO3_PRINT_CONFIG=1 is set, printing configuration and halting compile --
  implementation=CPython
  version=3.8
  shared=true
  abi3=false
  lib_name=python3.8
  lib_dir=/usr/lib
  executable=/usr/bin/python
  pointer_width=64
  build_flags=
  suppress_build_script_link_lines=false
</code></pre>
<p>The <code>PYO3_ENVIRONMENT_SIGNATURE</code> environment variable can be used to trigger rebuilds when its value changes, it has no other effect.</p>
<h3 id="advanced-config-files"><a class="header" href="#advanced-config-files">Advanced: config files</a></h3>
<p>If you save the above output config from <code>PYO3_PRINT_CONFIG</code> to a file, it is possible to manually override the contents and feed it back into PyO3 using the <code>PYO3_CONFIG_FILE</code> env var.</p>
<p>If your build environment is unusual enough that PyO3's regular configuration detection doesn't work, using a config file like this will give you the flexibility to make PyO3 work for you. To see the full set of options supported, see the documentation for the <a href="https://docs.rs/pyo3-build-config/0.21.2/pyo3_build_config/struct.InterpreterConfig.html"><code>InterpreterConfig</code> struct</a>.</p>
<h2 id="building-python-extension-modules"><a class="header" href="#building-python-extension-modules">Building Python extension modules</a></h2>
<p>Python extension modules need to be compiled differently depending on the OS (and architecture) that they are being compiled for. As well as multiple OSes (and architectures), there are also many different Python versions which are actively supported. Packages uploaded to <a href="https://pypi.org/">PyPI</a> usually want to upload prebuilt "wheels" covering many OS/arch/version combinations so that users on all these different platforms don't have to compile the package themselves. Package vendors can opt-in to the "abi3" limited Python API which allows their wheels to be used on multiple Python versions, reducing the number of wheels they need to compile, but restricts the functionality they can use.</p>
<p>There are many ways to go about this: it is possible to use <code>cargo</code> to build the extension module (along with some manual work, which varies with OS). The PyO3 ecosystem has two packaging tools, <a href="https://github.com/PyO3/maturin"><code>maturin</code></a> and <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a>, which abstract over the OS difference and also support building wheels for PyPI upload.</p>
<p>PyO3 has some Cargo features to configure projects for building Python extension modules:</p>
<ul>
<li>The <code>extension-module</code> feature, which must be enabled when building Python extension modules.</li>
<li>The <code>abi3</code> feature and its version-specific <code>abi3-pyXY</code> companions, which are used to opt-in to the limited Python API in order to support multiple Python versions in a single wheel.</li>
</ul>
<p>This section describes each of these packaging tools before describing how to build manually without them. It then proceeds with an explanation of the <code>extension-module</code> feature. Finally, there is a section describing PyO3's <code>abi3</code> features.</p>
<h3 id="packaging-tools"><a class="header" href="#packaging-tools">Packaging tools</a></h3>
<p>The PyO3 ecosystem has two main choices to abstract the process of developing Python extension modules:</p>
<ul>
<li><a href="https://github.com/PyO3/maturin"><code>maturin</code></a> is a command-line tool to build, package and upload Python modules. It makes opinionated choices about project layout meaning it needs very little configuration. This makes it a great choice for users who are building a Python extension from scratch and don't need flexibility.</li>
<li><a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> is an add-on for <code>setuptools</code> which adds extra keyword arguments to the <code>setup.py</code> configuration file. It requires more configuration than <code>maturin</code>, however this gives additional flexibility for users adding Rust to an existing Python package that can't satisfy <code>maturin</code>'s constraints.</li>
</ul>
<p>Consult each project's documentation for full details on how to get started using them and how to upload wheels to PyPI. It should be noted that while <code>maturin</code> is able to build <a href="https://github.com/pypa/manylinux">manylinux</a>-compliant wheels out-of-the-box, <code>setuptools-rust</code> requires a bit more effort, <a href="https://setuptools-rust.readthedocs.io/en/latest/building_wheels.html">relying on Docker</a> for this purpose.</p>
<p>There are also <a href="https://github.com/PyO3/pyo3/tree/main/examples/maturin-starter"><code>maturin-starter</code></a> and <a href="https://github.com/PyO3/pyo3/tree/main/examples/setuptools-rust-starter"><code>setuptools-rust-starter</code></a> examples in the PyO3 repository.</p>
<h3 id="manual-builds"><a class="header" href="#manual-builds">Manual builds</a></h3>
<p>To build a PyO3-based Python extension manually, start by running <code>cargo build</code> as normal in a library project which uses PyO3's <code>extension-module</code> feature and has the <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-crate-type-field"><code>cdylib</code> crate type</a>.</p>
<p>Once built, symlink (or copy) and rename the shared library from Cargo's <code>target/</code> directory to your desired output directory:</p>
<ul>
<li>on macOS, rename <code>libyour_module.dylib</code> to <code>your_module.so</code>.</li>
<li>on Windows, rename  <code>libyour_module.dll</code> to <code>your_module.pyd</code>.</li>
<li>on Linux, rename <code>libyour_module.so</code> to <code>your_module.so</code>.</li>
</ul>
<p>You can then open a Python shell in the output directory and you'll be able to run <code>import your_module</code>.</p>
<p>If you're packaging your library for redistribution, you should indicated the Python interpreter your library is compiled for by including the <a href="building-and-distribution.html#platform-tags">platform tag</a> in its name. This prevents incompatible interpreters from trying to import your library. If you're compiling for PyPy you <em>must</em> include the platform tag, or PyPy will ignore the module.</p>
<h4 id="bazel-builds"><a class="header" href="#bazel-builds">Bazel builds</a></h4>
<p>To use PyO3 with bazel one needs to manually configure PyO3, PyO3-ffi and PyO3-macros. In particular, one needs to make sure that it is compiled with the right python flags for the version you intend to use.
For example see:</p>
<ol>
<li>https://github.com/OliverFM/pytorch_with_gazelle -- for a minimal example of a repo that can use PyO3, PyTorch and Gazelle to generate python Build files.</li>
<li>https://github.com/TheButlah/rules_pyo3 -- which has more extensive support, but is outdated.</li>
</ol>
<h4 id="platform-tags"><a class="header" href="#platform-tags">Platform tags</a></h4>
<p>Rather than using just the <code>.so</code> or <code>.pyd</code> extension suggested above (depending on OS), you can prefix the shared library extension with a platform tag to indicate the interpreter it is compatible with. You can query your interpreter's platform tag from the <code>sysconfig</code> module. Some example outputs of this are seen below:</p>
<pre><code class="language-bash"># CPython 3.10 on macOS
.cpython-310-darwin.so

# PyPy 7.3 (Python 3.8) on Linux
$ python -c 'import sysconfig; print(sysconfig.get_config_var("EXT_SUFFIX"))'
.pypy38-pp73-x86_64-linux-gnu.so
</code></pre>
<p>So, for example, a valid module library name on CPython 3.10 for macOS is <code>your_module.cpython-310-darwin.so</code>, and its equivalent when compiled for PyPy 7.3 on Linux would be <code>your_module.pypy38-pp73-x86_64-linux-gnu.so</code>.</p>
<p>See <a href="https://peps.python.org/pep-3149/">PEP 3149</a> for more background on platform tags.</p>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>On macOS, because the <code>extension-module</code> feature disables linking to <code>libpython</code> (<a href="building-and-distribution.html#the-extension-module-feature">see the next section</a>), some additional linker arguments need to be set. <code>maturin</code> and <code>setuptools-rust</code> both pass these arguments for PyO3 automatically, but projects using manual builds will need to set these directly in order to support macOS.</p>
<p>The easiest way to set the correct linker arguments is to add a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> with the following content:</p>
<pre><code class="language-rust ignore">fn main() {
    pyo3_build_config::add_extension_module_link_args();
}</code></pre>
<p>Remember to also add <code>pyo3-build-config</code> to the <code>build-dependencies</code> section in <code>Cargo.toml</code>.</p>
<p>An alternative to using <code>pyo3-build-config</code> is add the following to a cargo configuration file (e.g. <code>.cargo/config.toml</code>):</p>
<pre><code class="language-toml">[target.x86_64-apple-darwin]
rustflags = [
  "-C", "link-arg=-undefined",
  "-C", "link-arg=dynamic_lookup",
]

[target.aarch64-apple-darwin]
rustflags = [
  "-C", "link-arg=-undefined",
  "-C", "link-arg=dynamic_lookup",
]
</code></pre>
<p>Using the MacOS system python3 (<code>/usr/bin/python3</code>, as opposed to python installed via homebrew, pyenv, nix, etc.) may result in runtime errors such as <code>Library not loaded: @rpath/Python3.framework/Versions/3.8/Python3</code>. These can be resolved with another addition to <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[build]
rustflags = [
  "-C", "link-args=-Wl,-rpath,/Library/Developer/CommandLineTools/Library/Frameworks",
]
</code></pre>
<p>Alternatively, on rust &gt;= 1.56, one can include in <code>build.rs</code>:</p>
<pre><code class="language-rust">fn main() {
    println!(
        "cargo:rustc-link-arg=-Wl,-rpath,/Library/Developer/CommandLineTools/Library/Frameworks"
    );
}</code></pre>
<p>For more discussion on and workarounds for MacOS linking problems <a href="https://github.com/PyO3/pyo3/issues/1800#issuecomment-906786649">see this issue</a>.</p>
<p>Finally, don't forget that on MacOS the <code>extension-module</code> feature will cause <code>cargo test</code> to fail without the <code>--no-default-features</code> flag (see <a href="https://pyo3.rs/main/faq.html#i-cant-run-cargo-test-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror">the FAQ</a>).</p>
<h3 id="the-extension-module-feature"><a class="header" href="#the-extension-module-feature">The <code>extension-module</code> feature</a></h3>
<p>PyO3's <code>extension-module</code> feature is used to disable <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linking</a> to <code>libpython</code> on Unix targets.</p>
<p>This is necessary because by default PyO3 links to <code>libpython</code>. This makes binaries, tests, and examples "just work". However, Python extensions on Unix must not link to libpython for <a href="https://www.python.org/dev/peps/pep-0513/">manylinux</a> compliance.</p>
<p>The downside of not linking to <code>libpython</code> is that binaries, tests, and examples (which usually embed Python) will fail to build. If you have an extension module as well as other outputs in a single project, you need to use optional Cargo features to disable the <code>extension-module</code> when you're not building the extension module. See <a href="faq.html#i-cant-run-cargo-test-or-i-cant-build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror">the FAQ</a> for an example workaround.</p>
<h3 id="py_limited_apiabi3"><a class="header" href="#py_limited_apiabi3"><code>Py_LIMITED_API</code>/<code>abi3</code></a></h3>
<p>By default, Python extension modules can only be used with the same Python version they were compiled against. For example, an extension module built for Python 3.5 can't be imported in Python 3.8. <a href="https://www.python.org/dev/peps/pep-0384/">PEP 384</a> introduced the idea of the limited Python API, which would have a stable ABI enabling extension modules built with it to be used against multiple Python versions. This is also known as <code>abi3</code>.</p>
<p>The advantage of building extension modules using the limited Python API is that package vendors only need to build and distribute a single copy (for each OS / architecture), and users can install it on all Python versions from the <a href="building-and-distribution.html#minimum-python-version-for-abi3">minimum version</a> and up. The downside of this is that PyO3 can't use optimizations which rely on being compiled against a known exact Python version. It's up to you to decide whether this matters for your extension module. It's also possible to design your extension module such that you can distribute <code>abi3</code> wheels but allow users compiling from source to benefit from additional optimizations - see the <a href="./building-and-distribution/multiple-python-versions.html">support for multiple python versions</a> section of this guide, in particular the <code>#[cfg(Py_LIMITED_API)]</code> flag.</p>
<p>There are three steps involved in making use of <code>abi3</code> when building Python packages as wheels:</p>
<ol>
<li>Enable the <code>abi3</code> feature in <code>pyo3</code>. This ensures <code>pyo3</code> only calls Python C-API functions which are part of the stable API, and on Windows also ensures that the project links against the correct shared object (no special behavior is required on other platforms):</li>
</ol>
<pre><code class="language-toml">[dependencies]
pyo3 = { version = "0.21.2", features = ["abi3"] }
</code></pre>
<ol start="2">
<li>
<p>Ensure that the built shared objects are correctly marked as <code>abi3</code>. This is accomplished by telling your build system that you're using the limited API. <a href="https://github.com/PyO3/maturin"><code>maturin</code></a> &gt;= 0.9.0 and <a href="https://github.com/PyO3/setuptools-rust"><code>setuptools-rust</code></a> &gt;= 0.11.4 support <code>abi3</code> wheels.
See the <a href="https://github.com/PyO3/maturin/pull/353">corresponding</a> <a href="https://github.com/PyO3/setuptools-rust/pull/82">PRs</a> for more.</p>
</li>
<li>
<p>Ensure that the <code>.whl</code> is correctly marked as <code>abi3</code>. For projects using <code>setuptools</code>, this is accomplished by passing <code>--py-limited-api=cp3x</code> (where <code>x</code> is the minimum Python version supported by the wheel, e.g. <code>--py-limited-api=cp35</code> for Python 3.5) to <code>setup.py bdist_wheel</code>.</p>
</li>
</ol>
<h4 id="minimum-python-version-for-abi3"><a class="header" href="#minimum-python-version-for-abi3">Minimum Python version for <code>abi3</code></a></h4>
<p>Because a single <code>abi3</code> wheel can be used with many different Python versions, PyO3 has feature flags <code>abi3-py37</code>, <code>abi3-py38</code>, <code>abi3-py39</code> etc. to set the minimum required Python version for your <code>abi3</code> wheel.
For example, if you set the <code>abi3-py37</code> feature, your extension wheel can be used on all Python 3 versions from Python 3.7 and up. <code>maturin</code> and <code>setuptools-rust</code> will give the wheel a name like <code>my-extension-1.0-cp37-abi3-manylinux2020_x86_64.whl</code>.</p>
<p>As your extension module may be run with multiple different Python versions you may occasionally find you need to check the Python version at runtime to customize behavior. See <a href="./building-and-distribution/multiple-python-versions.html#checking-the-python-version-at-runtime">the relevant section of this guide</a> on supporting multiple Python versions at runtime.</p>
<p>PyO3 is only able to link your extension module to abi3 version up to and including your host Python version. E.g., if you set <code>abi3-py38</code> and try to compile the crate with a host of Python 3.7, the build will fail.</p>
<blockquote>
<p>Note: If you set more that one of these <code>abi3</code> version feature flags the lowest version always wins. For example, with both <code>abi3-py37</code> and <code>abi3-py38</code> set, PyO3 would build a wheel which supports Python 3.7 and up.</p>
</blockquote>
<h4 id="building-abi3-extensions-without-a-python-interpreter"><a class="header" href="#building-abi3-extensions-without-a-python-interpreter">Building <code>abi3</code> extensions without a Python interpreter</a></h4>
<p>As an advanced feature, you can build PyO3 wheel without calling Python interpreter with the environment variable <code>PYO3_NO_PYTHON</code> set.
Also, if the build host Python interpreter is not found or is too old or otherwise unusable,
PyO3 will still attempt to compile <code>abi3</code> extension modules after displaying a warning message.
On Unix-like systems this works unconditionally; on Windows you must also set the <code>RUSTFLAGS</code> environment variable
to contain <code>-L native=/path/to/python/libs</code> so that the linker can find <code>python3.lib</code>.</p>
<p>If the <code>python3.dll</code> import library is not available, an experimental <code>generate-import-lib</code> crate
feature may be enabled, and the required library will be created and used by PyO3 automatically.</p>
<p><em>Note</em>: MSVC targets require LLVM binutils (<code>llvm-dlltool</code>) to be available in <code>PATH</code> for
the automatic import library generation feature to work.</p>
<h4 id="missing-features"><a class="header" href="#missing-features">Missing features</a></h4>
<p>Due to limitations in the Python API, there are a few <code>pyo3</code> features that do
not work when compiling for <code>abi3</code>. These are:</p>
<ul>
<li><code>#[pyo3(text_signature = "...")]</code> does not work on classes until Python 3.10 or greater.</li>
<li>The <code>dict</code> and <code>weakref</code> options on classes are not supported until Python 3.9 or greater.</li>
<li>The buffer API is not supported until Python 3.11 or greater.</li>
<li>Optimizations which rely on knowledge of the exact Python version compiled against.</li>
</ul>
<h2 id="embedding-python-in-rust"><a class="header" href="#embedding-python-in-rust">Embedding Python in Rust</a></h2>
<p>If you want to embed the Python interpreter inside a Rust program, there are two modes in which this can be done: dynamically and statically. We'll cover each of these modes in the following sections. Each of them affect how you must distribute your program. Instead of learning how to do this yourself, you might want to consider using a project like <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> to ship your application and all of its dependencies in a single file.</p>
<p>PyO3 automatically switches between the two linking modes depending on whether the Python distribution you have configured PyO3 to use (<a href="building-and-distribution.html#configuring-the-python-version">see above</a>) contains a shared library or a static library. The static library is most often seen in Python distributions compiled from source without the <code>--enable-shared</code> configuration option. For example, this is the default for <code>pyenv</code> on macOS.</p>
<h3 id="dynamically-embedding-the-python-interpreter"><a class="header" href="#dynamically-embedding-the-python-interpreter">Dynamically embedding the Python interpreter</a></h3>
<p>Embedding the Python interpreter dynamically is much easier than doing so statically. This is done by linking your program against a Python shared library (such as <code>libpython.3.9.so</code> on UNIX, or <code>python39.dll</code> on Windows). The implementation of the Python interpreter resides inside the shared library. This means that when the OS runs your Rust program it also needs to be able to find the Python shared library.</p>
<p>This mode of embedding works well for Rust tests which need access to the Python interpreter. It is also great for Rust software which is installed inside a Python virtualenv, because the virtualenv sets up appropriate environment variables to locate the correct Python shared library.</p>
<p>For distributing your program to non-technical users, you will have to consider including the Python shared library in your distribution as well as setting up wrapper scripts to set the right environment variables (such as <code>LD_LIBRARY_PATH</code> on UNIX, or <code>PATH</code> on Windows).</p>
<p>Note that PyPy cannot be embedded in Rust (or any other software). Support for this is tracked on the <a href="https://github.com/pypy/pypy/issues/3836">PyPy issue tracker</a>.</p>
<h3 id="statically-embedding-the-python-interpreter"><a class="header" href="#statically-embedding-the-python-interpreter">Statically embedding the Python interpreter</a></h3>
<p>Embedding the Python interpreter statically means including the contents of a Python static library directly inside your Rust binary. This means that to distribute your program you only need to ship your binary file: it contains the Python interpreter inside the binary!</p>
<p>On Windows static linking is almost never done, so Python distributions don't usually include a static library. The information below applies only to UNIX.</p>
<p>The Python static library is usually called <code>libpython.a</code>.</p>
<p>Static linking has a lot of complications, listed below. For these reasons PyO3 does not yet have first-class support for this embedding mode. See <a href="https://github.com/PyO3/pyo3/issues/416">issue 416 on PyO3's GitHub</a> for more information and to discuss any issues you encounter.</p>
<p>The <a href="features.html#auto-initialize"><code>auto-initialize</code></a> feature is deliberately disabled when embedding the interpreter statically because this is often unintentionally done by new users to PyO3 running test programs. Trying out PyO3 is much easier using dynamic embedding.</p>
<p>The known complications are:</p>
<ul>
<li>
<p>To import compiled extension modules (such as other Rust extension modules, or those written in C), your binary must have the correct linker flags set during compilation to export the original contents of <code>libpython.a</code> so that extensions can use them (e.g. <code>-Wl,--export-dynamic</code>).</p>
</li>
<li>
<p>The C compiler and flags which were used to create <code>libpython.a</code> must be compatible with your Rust compiler and flags, else you will experience compilation failures.</p>
<p>Significantly different compiler versions may see errors like this:</p>
<pre><code class="language-text">lto1: fatal error: bytecode stream in file 'rust-numpy/target/release/deps/libpyo3-6a7fb2ed970dbf26.rlib' generated with LTO version 6.0 instead of the expected 6.2
</code></pre>
<p>Mismatching flags may lead to errors like this:</p>
<pre><code class="language-text">/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/libpython3.9.a(zlibmodule.o): relocation R_X86_64_32 against `.data' can not be used when making a PIE object; recompile with -fPIE
</code></pre>
</li>
</ul>
<p>If you encounter these or other complications when linking the interpreter statically, discuss them on <a href="https://github.com/PyO3/pyo3/issues/416">issue 416 on PyO3's GitHub</a>. It is hoped that eventually that discussion will contain enough information and solutions that PyO3 can offer first-class support for static embedding.</p>
<h3 id="import-your-module-when-embedding-the-python-interpreter"><a class="header" href="#import-your-module-when-embedding-the-python-interpreter">Import your module when embedding the Python interpreter</a></h3>
<p>When you run your Rust binary with an embedded interpreter, any <code>#[pymodule]</code> created modules won't be accessible to import unless added to a table called <code>PyImport_Inittab</code> before the embedded interpreter is initialized. This will cause Python statements in your embedded interpreter such as <code>import your_new_module</code> to fail. You can call the macro <a href="https://docs.rs/pyo3/0.21.2/pyo3/macro.append_to_inittab.html"><code>append_to_inittab</code></a> with your module before initializing the Python interpreter to add the module function into that table. (The Python interpreter will be initialized by calling <code>prepare_freethreaded_python</code>, <code>with_embedded_python_interpreter</code>, or <code>Python::with_gil</code> with the <a href="features.html#auto-initialize"><code>auto-initialize</code></a> feature enabled.)</p>
<h2 id="cross-compiling"><a class="header" href="#cross-compiling">Cross Compiling</a></h2>
<p>Thanks to Rust's great cross-compilation support, cross-compiling using PyO3 is relatively straightforward. To get started, you'll need a few pieces of software:</p>
<ul>
<li>A toolchain for your target.</li>
<li>The appropriate options in your Cargo <code>.config</code> for the platform you're targeting and the toolchain you are using.</li>
<li>A Python interpreter that's already been compiled for your target (optional when building "abi3" extension modules).</li>
<li>A Python interpreter that is built for your host and available through the <code>PATH</code> or setting the <a href="building-and-distribution.html#configuring-the-python-version"><code>PYO3_PYTHON</code></a> variable (optional when building "abi3" extension modules).</li>
</ul>
<p>After you've obtained the above, you can build a cross-compiled PyO3 module by using Cargo's <code>--target</code> flag. PyO3's build script will detect that you are attempting a cross-compile based on your host machine and the desired target.</p>
<p>When cross-compiling, PyO3's build script cannot execute the target Python interpreter to query the configuration, so there are a few additional environment variables you may need to set:</p>
<ul>
<li><code>PYO3_CROSS</code>: If present this variable forces PyO3 to configure as a cross-compilation.</li>
<li><code>PYO3_CROSS_LIB_DIR</code>: This variable can be set to the directory containing the target's libpython DSO and the associated <code>_sysconfigdata*.py</code> file for Unix-like targets, or the Python DLL import libraries for the Windows target. This variable is only needed when the output binary must link to libpython explicitly (e.g. when targeting Windows and Android or embedding a Python interpreter), or when it is absolutely required to get the interpreter configuration from <code>_sysconfigdata*.py</code>.</li>
<li><code>PYO3_CROSS_PYTHON_VERSION</code>: Major and minor version (e.g. 3.9) of the target Python installation. This variable is only needed if PyO3 cannot determine the version to target from <code>abi3-py3*</code> features, or if <code>PYO3_CROSS_LIB_DIR</code> is not set, or if there are multiple versions of Python present in <code>PYO3_CROSS_LIB_DIR</code>.</li>
<li><code>PYO3_CROSS_PYTHON_IMPLEMENTATION</code>: Python implementation name ("CPython" or "PyPy") of the target Python installation. CPython is assumed by default when this variable is not set, unless <code>PYO3_CROSS_LIB_DIR</code> is set for a Unix-like target and PyO3 can get the interpreter configuration from <code>_sysconfigdata*.py</code>.</li>
</ul>
<p>An experimental <code>pyo3</code> crate feature <code>generate-import-lib</code> enables the user to cross-compile
extension modules for Windows targets without setting the <code>PYO3_CROSS_LIB_DIR</code> environment
variable or providing any Windows Python library files. It uses an external <a href="https://docs.rs/python3-dll-a/latest/python3_dll_a/"><code>python3-dll-a</code></a> crate
to generate import libraries for the Python DLL for MinGW-w64 and MSVC compile targets.
<code>python3-dll-a</code> uses the binutils <code>dlltool</code> program to generate DLL import libraries for MinGW-w64 targets.
It is possible to override the default <code>dlltool</code> command name for the cross target
by setting <code>PYO3_MINGW_DLLTOOL</code> environment variable.
<em>Note</em>: MSVC targets require LLVM binutils or MSVC build tools to be available on the host system.
More specifically, <code>python3-dll-a</code> requires <code>llvm-dlltool</code> or <code>lib.exe</code> executable to be present in <code>PATH</code> when
targeting <code>*-pc-windows-msvc</code>. The Zig compiler executable can be used in place of <code>llvm-dlltool</code> when the <code>ZIG_COMMAND</code>
environment variable is set to the installed Zig program name (<code>"zig"</code> or <code>"python -m ziglang"</code>).</p>
<p>An example might look like the following (assuming your target's sysroot is at <code>/home/pyo3/cross/sysroot</code> and that your target is <code>armv7</code>):</p>
<pre><code class="language-sh">export PYO3_CROSS_LIB_DIR="/home/pyo3/cross/sysroot/usr/lib"

cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<p>If there are multiple python versions at the cross lib directory and you cannot set a more precise location to include both the <code>libpython</code> DSO and <code>_sysconfigdata*.py</code> files, you can set the required version:</p>
<pre><code class="language-sh">export PYO3_CROSS_PYTHON_VERSION=3.8
export PYO3_CROSS_LIB_DIR="/home/pyo3/cross/sysroot/usr/lib"

cargo build --target armv7-unknown-linux-gnueabihf
</code></pre>
<p>Or another example with the same sys root but building for Windows:</p>
<pre><code class="language-sh">export PYO3_CROSS_PYTHON_VERSION=3.9
export PYO3_CROSS_LIB_DIR="/home/pyo3/cross/sysroot/usr/lib"

cargo build --target x86_64-pc-windows-gnu
</code></pre>
<p>Any of the <code>abi3-py3*</code> features can be enabled instead of setting <code>PYO3_CROSS_PYTHON_VERSION</code> in the above examples.</p>
<p><code>PYO3_CROSS_LIB_DIR</code> can often be omitted when cross compiling extension modules for Unix and macOS targets,
or when cross compiling extension modules for Windows and the experimental <code>generate-import-lib</code>
crate feature is enabled.</p>
<p>The following resources may also be useful for cross-compiling:</p>
<ul>
<li><a href="https://github.com/japaric/rust-cross">github.com/japaric/rust-cross</a> is a primer on cross compiling Rust.</li>
<li><a href="https://github.com/rust-embedded/cross">github.com/rust-embedded/cross</a> uses Docker to make Rust cross-compilation easier.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supporting-multiple-python-versions"><a class="header" href="#supporting-multiple-python-versions">Supporting multiple Python versions</a></h1>
<p>PyO3 supports all actively-supported Python 3 and PyPy versions. As much as possible, this is done internally to PyO3 so that your crate's code does not need to adapt to the differences between each version. However, as Python features grow and change between versions, PyO3 cannot a completely identical API for every Python version. This may require you to add conditional compilation to your crate or runtime checks for the Python version.</p>
<p>This section of the guide first introduces the <code>pyo3-build-config</code> crate, which you can use as a <code>build-dependency</code> to add additional <code>#[cfg]</code> flags which allow you to support multiple Python versions at compile-time.</p>
<p>Second, we'll show how to check the Python version at runtime. This can be useful when building for multiple versions with the <code>abi3</code> feature, where the Python API compiled against is not always the same as the one in use.</p>
<h2 id="conditional-compilation-for-different-python-versions"><a class="header" href="#conditional-compilation-for-different-python-versions">Conditional compilation for different Python versions</a></h2>
<p>The <code>pyo3-build-config</code> exposes multiple <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html"><code>#[cfg]</code> flags</a> which can be used to conditionally compile code for a given Python version. PyO3 itself depends on this crate, so by using it you can be sure that you are configured correctly for the Python version PyO3 is building against.</p>
<p>This allows us to write code like the following</p>
<pre><code class="language-rust ignore">#[cfg(Py_3_7)]
fn function_only_supported_on_python_3_7_and_up() {}

#[cfg(not(Py_3_8))]
fn function_only_supported_before_python_3_8() {}

#[cfg(not(Py_LIMITED_API))]
fn function_incompatible_with_abi3_feature() {}</code></pre>
<p>The following sections first show how to add these <code>#[cfg]</code> flags to your build process, and then cover some common patterns flags in a little more detail.</p>
<p>To see a full reference of all the <code>#[cfg]</code> flags provided, see the <a href="https://docs.rs/pyo3-build-config"><code>pyo3-build-cfg</code> docs</a>.</p>
<h3 id="using-pyo3-build-config"><a class="header" href="#using-pyo3-build-config">Using <code>pyo3-build-config</code></a></h3>
<p>You can use the <code>#[cfg]</code> flags in just two steps:</p>
<ol>
<li>
<p>Add <code>pyo3-build-config</code> with the <a href="building-and-distribution/../features.html#resolve-config"><code>resolve-config</code></a> feature enabled to your crate's build dependencies in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
pyo3-build-config = { version = "0.21.2", features = ["resolve-config"] }
</code></pre>
</li>
<li>
<p>Add a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> file to your crate with the following contents:</p>
<pre><code class="language-rust ignore">fn main() {
    // If you have an existing build.rs file, just add this line to it.
    pyo3_build_config::use_pyo3_cfgs();
}</code></pre>
</li>
</ol>
<p>After these steps you are ready to annotate your code!</p>
<h3 id="common-usages-of-pyo3-build-cfg-flags"><a class="header" href="#common-usages-of-pyo3-build-cfg-flags">Common usages of <code>pyo3-build-cfg</code> flags</a></h3>
<p>The <code>#[cfg]</code> flags added by <code>pyo3-build-cfg</code> can be combined with all of Rust's logic in the <code>#[cfg]</code> attribute to create very precise conditional code generation. The following are some common patterns implemented using these flags:</p>
<pre><code class="language-text">#[cfg(Py_3_7)]
</code></pre>
<p>This <code>#[cfg]</code> marks code that will only be present on Python 3.7 and upwards. There are similar options <code>Py_3_8</code>, <code>Py_3_9</code>, <code>Py_3_10</code> and so on for each minor version.</p>
<pre><code class="language-text">#[cfg(not(Py_3_7))]
</code></pre>
<p>This <code>#[cfg]</code> marks code that will only be present on Python versions before (but not including) Python 3.7.</p>
<pre><code class="language-text">#[cfg(not(Py_LIMITED_API))]
</code></pre>
<p>This <code>#[cfg]</code> marks code that is only available when building for the unlimited Python API (i.e. PyO3's <code>abi3</code> feature is not enabled). This might be useful if you want to ship your extension module as an <code>abi3</code> wheel and also allow users to compile it from source to make use of optimizations only possible with the unlimited API.</p>
<pre><code class="language-text">#[cfg(any(Py_3_9, not(Py_LIMITED_API)))]
</code></pre>
<p>This <code>#[cfg]</code> marks code which is available when running Python 3.9 or newer, or when using the unlimited API with an older Python version. Patterns like this are commonly seen on Python APIs which were added to the limited Python API in a specific minor version.</p>
<pre><code class="language-text">#[cfg(PyPy)]
</code></pre>
<p>This <code>#[cfg]</code> marks code which is running on PyPy.</p>
<h2 id="checking-the-python-version-at-runtime"><a class="header" href="#checking-the-python-version-at-runtime">Checking the Python version at runtime</a></h2>
<p>When building with PyO3's <code>abi3</code> feature, your extension module will be compiled against a specific <a href="building-and-distribution/../building-and-distribution.html#minimum-python-version-for-abi3">minimum version</a> of Python, but may be running on newer Python versions.</p>
<p>For example with PyO3's <code>abi3-py38</code> feature, your extension will be compiled as if it were for Python 3.8. If you were using <code>pyo3-build-config</code>, <code>#[cfg(Py_3_8)]</code> would be present. Your user could freely install and run your abi3 extension on Python 3.9.</p>
<p>There's no way to detect your user doing that at compile time, so instead you need to fall back to runtime checks.</p>
<p>PyO3 provides the APIs <a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.version"><code>Python::version()</code></a> and <a href="https://docs.rs/pyo3/0.21.2/pyo3/marker/struct.Python.html#method.version_info"><code>Python::version_info()</code></a> to query the running Python version. This allows you to do the following, for example:</p>
<pre><code class="language-rust">use pyo3::Python;

Python::with_gil(|py| {
    // PyO3 supports Python 3.7 and up.
    assert!(py.version_info() &gt;= (3, 7));
    assert!(py.version_info() &gt;= (3, 7, 0));
});</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-pyo3-ecosystem"><a class="header" href="#the-pyo3-ecosystem">The PyO3 ecosystem</a></h1>
<p>This portion of the guide is dedicated to crates which are external to the main PyO3 project and provide additional functionality you might find useful.</p>
<p>Because these projects evolve independently of the PyO3 repository the content of these articles may fall out of date over time; please file issues on the PyO3 GitHub to alert maintainers when this is the case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>It is desirable if both the Python and Rust parts of the application end up
logging using the same configuration into the same place.</p>
<p>This section of the guide briefly discusses how to connect the two languages'
logging ecosystems together. The recommended way for Python extension modules is
to configure Rust's logger to send log messages to Python using the <code>pyo3-log</code>
crate. For users who want to do the opposite and send Python log messages to
Rust, see the note at the end of this guide.</p>
<h2 id="using-pyo3-log-to-send-rust-log-messages-to-python"><a class="header" href="#using-pyo3-log-to-send-rust-log-messages-to-python">Using <code>pyo3-log</code> to send Rust log messages to Python</a></h2>
<p>The <a href="https://crates.io/crates/pyo3-log">pyo3-log</a> crate allows sending the messages from the Rust side to Python's
<a href="https://docs.python.org/3/library/logging.html">logging</a> system. This is mostly suitable for writing native extensions for
Python programs.</p>
<p>Use <a href="https://docs.rs/pyo3-log/*/pyo3_log/fn.init.html"><code>pyo3_log::init</code></a> to install the logger in its default configuration.
It's also possible to tweak its configuration (mostly to tune its performance).</p>
<pre><code class="language-rust">use log::info;
use pyo3::prelude::*;

#[pyfunction]
fn log_something() {
    // This will use the logger installed in `my_module` to send the `info`
    // message to the Python logging facilities.
    info!("Something!");
}

#[pymodule]
fn my_module(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    // A good place to install the Rust -&gt; Python logger.
    pyo3_log::init();

    m.add_function(wrap_pyfunction!(log_something, m)?)?;
    Ok(())
}</code></pre>
<p>Then it is up to the Python side to actually output the messages somewhere.</p>
<pre><code class="language-python">import logging
import my_module

FORMAT = '%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s'
logging.basicConfig(format=FORMAT)
logging.getLogger().setLevel(logging.INFO)
my_module.log_something()
</code></pre>
<p>It is important to initialize the Python loggers first, before calling any Rust
functions that may log. This limitation can be worked around if it is not
possible to satisfy, read the documentation about <a href="https://docs.rs/pyo3-log/*/pyo3_log/#performance-filtering-and-caching">caching</a>.</p>
<h2 id="the-python-to-rust-direction"><a class="header" href="#the-python-to-rust-direction">The Python to Rust direction</a></h2>
<p>To have python logs be handled by Rust, one need only register a rust function to handle logs emitted from the core python logging module.</p>
<p>This has been implemented within the <a href="https://crates.io/crates/pyo3-pylogger">pyo3-pylogger</a> crate.</p>
<pre><code class="language-rust">use log::{info, warn};
use pyo3::prelude::*;

fn main() -&gt; PyResult&lt;()&gt; {
    // register the host handler with python logger, providing a logger target
    // set the name here to something appropriate for your application
    pyo3_pylogger::register("example_application_py_logger");

    // initialize up a logger
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("trace")).init();

    // Log some messages from Rust.
    info!("Just some normal information!");
    warn!("Something spooky happened!");

    // Log some messages from Python
    Python::with_gil(|py| {
        py.run(
            "
import logging
logging.error('Something bad happened')
",
            None,
            None,
        )
    })
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-async-and-await-1"><a class="header" href="#using-async-and-await-1">Using <code>async</code> and <code>await</code></a></h1>
<p><em><code>async</code>/<code>await</code> support is currently being integrated in PyO3. See the <a href="ecosystem/../async-await.html">dedicated documentation</a></em></p>
<p>If you are working with a Python library that makes use of async functions or wish to provide
Python bindings for an async Rust library, <a href="https://github.com/awestlake87/pyo3-asyncio"><code>pyo3-asyncio</code></a>
likely has the tools you need. It provides conversions between async functions in both Python and
Rust and was designed with first-class support for popular Rust runtimes such as
<a href="https://tokio.rs/"><code>tokio</code></a> and <a href="https://async.rs/"><code>async-std</code></a>. In addition, all async Python
code runs on the default <code>asyncio</code> event loop, so <code>pyo3-asyncio</code> should work just fine with existing
Python libraries.</p>
<p>In the following sections, we'll give a general overview of <code>pyo3-asyncio</code> explaining how to call
async Python functions with PyO3, how to call async Rust functions from Python, and how to configure
your codebase to manage the runtimes of both.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Here are some examples to get you started right away! A more detailed breakdown
of the concepts in these examples can be found in the following sections.</p>
<h3 id="rust-applications"><a class="header" href="#rust-applications">Rust Applications</a></h3>
<p>Here we initialize the runtime, import Python's <code>asyncio</code> library and run the given future to completion using Python's default <code>EventLoop</code> and <code>async-std</code>. Inside the future, we convert <code>asyncio</code> sleep into a Rust future and await it.</p>
<pre><code class="language-toml"># Cargo.toml dependencies
[dependencies]
pyo3 = { version = "0.14" }
pyo3-asyncio = { version = "0.14", features = ["attributes", "async-std-runtime"] }
async-std = "1.9"
</code></pre>
<pre><code class="language-rust">//! main.rs

use pyo3::prelude::*;

#[pyo3_asyncio::async_std::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    let fut = Python::with_gil(|py| {
        let asyncio = py.import("asyncio")?;
        // convert asyncio.sleep into a Rust Future
        pyo3_asyncio::async_std::into_future(asyncio.call_method1("sleep", (1.into_py(py),))?)
    })?;

    fut.await?;

    Ok(())
}</code></pre>
<p>The same application can be written to use <code>tokio</code> instead using the <code>#[pyo3_asyncio::tokio::main]</code>
attribute.</p>
<pre><code class="language-toml"># Cargo.toml dependencies
[dependencies]
pyo3 = { version = "0.14" }
pyo3-asyncio = { version = "0.14", features = ["attributes", "tokio-runtime"] }
tokio = "1.4"
</code></pre>
<pre><code class="language-rust">//! main.rs

use pyo3::prelude::*;

#[pyo3_asyncio::tokio::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    let fut = Python::with_gil(|py| {
        let asyncio = py.import("asyncio")?;
        // convert asyncio.sleep into a Rust Future
        pyo3_asyncio::tokio::into_future(asyncio.call_method1("sleep", (1.into_py(py),))?)
    })?;

    fut.await?;

    Ok(())
}</code></pre>
<p>More details on the usage of this library can be found in the <a href="https://awestlake87.github.io/pyo3-asyncio/master/doc">API docs</a> and the primer below.</p>
<h3 id="pyo3-native-rust-modules"><a class="header" href="#pyo3-native-rust-modules">PyO3 Native Rust Modules</a></h3>
<p>PyO3 Asyncio can also be used to write native modules with async functions.</p>
<p>Add the <code>[lib]</code> section to <code>Cargo.toml</code> to make your library a <code>cdylib</code> that Python can import.</p>
<pre><code class="language-toml">[lib]
name = "my_async_module"
crate-type = ["cdylib"]
</code></pre>
<p>Make your project depend on <code>pyo3</code> with the <code>extension-module</code> feature enabled and select your
<code>pyo3-asyncio</code> runtime:</p>
<p>For <code>async-std</code>:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = { version = "0.14", features = ["extension-module"] }
pyo3-asyncio = { version = "0.14", features = ["async-std-runtime"] }
async-std = "1.9"
</code></pre>
<p>For <code>tokio</code>:</p>
<pre><code class="language-toml">[dependencies]
pyo3 = { version = "0.14", features = ["extension-module"] }
pyo3-asyncio = { version = "0.14", features = ["tokio-runtime"] }
tokio = "1.4"
</code></pre>
<p>Export an async function that makes use of <code>async-std</code>:</p>
<pre><code class="language-rust">//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python&lt;'_&gt;) -&gt; PyResult&lt;&amp;Bound&lt;'_, PyAny&gt;&gt; {
    pyo3_asyncio::async_std::future_into_py(py, async {
        async_std::task::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;

    Ok(())
}</code></pre>
<p>If you want to use <code>tokio</code> instead, here's what your module should look like:</p>
<pre><code class="language-rust">//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python&lt;'_&gt;) -&gt; PyResult&lt;&amp;Bound&lt;'_, PyAny&gt;&gt;&gt; {
    pyo3_asyncio::tokio::future_into_py(py, async {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;
    Ok(())
}</code></pre>
<p>You can build your module with maturin (see the <a href="https://pyo3.rs/main/#using-rust-from-python">Using Rust in Python</a> section in the PyO3 guide for setup instructions). After that you should be able to run the Python REPL to try it out.</p>
<pre><code class="language-bash">maturin develop &amp;&amp; python3
🔗 Found pyo3 bindings
🐍 Found CPython 3.8 at python3
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
Python 3.8.5 (default, Jan 27 2021, 15:41:15)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt;
&gt;&gt;&gt; from my_async_module import rust_sleep
&gt;&gt;&gt;
&gt;&gt;&gt; async def main():
&gt;&gt;&gt;     await rust_sleep()
&gt;&gt;&gt;
&gt;&gt;&gt; # should sleep for 1s
&gt;&gt;&gt; asyncio.run(main())
&gt;&gt;&gt;
</code></pre>
<h2 id="awaiting-an-async-python-function-in-rust"><a class="header" href="#awaiting-an-async-python-function-in-rust">Awaiting an Async Python Function in Rust</a></h2>
<p>Let's take a look at a dead simple async Python function:</p>
<pre><code class="language-python"># Sleep for 1 second
async def py_sleep():
    await asyncio.sleep(1)
</code></pre>
<p><strong>Async functions in Python are simply functions that return a <code>coroutine</code> object</strong>. For our purposes,
we really don't need to know much about these <code>coroutine</code> objects. The key factor here is that calling
an <code>async</code> function is <em>just like calling a regular function</em>, the only difference is that we have
to do something special with the object that it returns.</p>
<p>Normally in Python, that something special is the <code>await</code> keyword, but in order to await this
coroutine in Rust, we first need to convert it into Rust's version of a <code>coroutine</code>: a <code>Future</code>.
That's where <code>pyo3-asyncio</code> comes in.
<a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.into_future.html"><code>pyo3_asyncio::async_std::into_future</code></a>
performs this conversion for us.</p>
<p>The following example uses <code>into_future</code> to call the <code>py_sleep</code> function shown above and then await the
coroutine object returned from the call:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyo3_asyncio::tokio::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    let future = Python::with_gil(|py| -&gt; PyResult&lt;_&gt; {
        // import the module containing the py_sleep function
        let example = py.import("example")?;

        // calling the py_sleep method like a normal function
        // returns a coroutine
        let coroutine = example.call_method0("py_sleep")?;

        // convert the coroutine into a Rust future using the
        // tokio runtime
        pyo3_asyncio::tokio::into_future(coroutine)
    })?;

    // await the future
    future.await?;

    Ok(())
}</code></pre>
<p>Alternatively, the below example shows how to write a <code>#[pyfunction]</code> which uses <code>into_future</code> to receive and await
a coroutine argument:</p>
<pre><code class="language-rust">#[pyfunction]
fn await_coro(coro: &amp;Bound&lt;'_, PyAny&gt;&gt;) -&gt; PyResult&lt;()&gt; {
    // convert the coroutine into a Rust future using the
    // async_std runtime
    let f = pyo3_asyncio::async_std::into_future(coro)?;

    pyo3_asyncio::async_std::run_until_complete(coro.py(), async move {
        // await the future
        f.await?;
        Ok(())
    })
}</code></pre>
<p>This could be called from Python as:</p>
<pre><code class="language-python">import asyncio

async def py_sleep():
    asyncio.sleep(1)

await_coro(py_sleep())
</code></pre>
<p>If for you wanted to pass a callable function to the <code>#[pyfunction]</code> instead, (i.e. the last line becomes <code>await_coro(py_sleep))</code>, then the above example needs to be tweaked to first call the callable to get the coroutine:</p>
<pre><code class="language-rust">#[pyfunction]
fn await_coro(callable: &amp;Bound&lt;'_, PyAny&gt;&gt;) -&gt; PyResult&lt;()&gt; {
    // get the coroutine by calling the callable
    let coro = callable.call0()?;

    // convert the coroutine into a Rust future using the
    // async_std runtime
    let f = pyo3_asyncio::async_std::into_future(coro)?;

    pyo3_asyncio::async_std::run_until_complete(coro.py(), async move {
        // await the future
        f.await?;
        Ok(())
    })
}</code></pre>
<p>This can be particularly helpful where you need to repeatedly create and await a coroutine. Trying to await the same coroutine multiple times will raise an error:</p>
<pre><code class="language-python">RuntimeError: cannot reuse already awaited coroutine
</code></pre>
<blockquote>
<p>If you're interested in learning more about <code>coroutines</code> and <code>awaitables</code> in general, check out the
<a href="https://docs.python.org/3/library/asyncio-task.html">Python 3 <code>asyncio</code> docs</a> for more information.</p>
</blockquote>
<h2 id="awaiting-a-rust-future-in-python"><a class="header" href="#awaiting-a-rust-future-in-python">Awaiting a Rust Future in Python</a></h2>
<p>Here we have the same async function as before written in Rust using the
<a href="https://async.rs/"><code>async-std</code></a> runtime:</p>
<pre><code class="language-rust">/// Sleep for 1 second
async fn rust_sleep() {
    async_std::task::sleep(std::time::Duration::from_secs(1)).await;
}</code></pre>
<p>Similar to Python, Rust's async functions also return a special object called a
<code>Future</code>:</p>
<pre><code class="language-rust">let future = rust_sleep();</code></pre>
<p>We can convert this <code>Future</code> object into Python to make it <code>awaitable</code>. This tells Python that you
can use the <code>await</code> keyword with it. In order to do this, we'll call
<a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.future_into_py.html"><code>pyo3_asyncio::async_std::future_into_py</code></a>:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

async fn rust_sleep() {
    async_std::task::sleep(std::time::Duration::from_secs(1)).await;
}

#[pyfunction]
fn call_rust_sleep(py: Python&lt;'_&gt;) -&gt; PyResult&lt;&amp;Bound&lt;'_, PyAny&gt;&gt;&gt; {
    pyo3_asyncio::async_std::future_into_py(py, async move {
        rust_sleep().await;
        Ok(Python::with_gil(|py| py.None()))
    })
}</code></pre>
<p>In Python, we can call this pyo3 function just like any other async function:</p>
<pre><code class="language-python">from example import call_rust_sleep

async def rust_sleep():
    await call_rust_sleep()
</code></pre>
<h2 id="managing-event-loops"><a class="header" href="#managing-event-loops">Managing Event Loops</a></h2>
<p>Python's event loop requires some special treatment, especially regarding the main thread. Some of
Python's <code>asyncio</code> features, like proper signal handling, require control over the main thread, which
doesn't always play well with Rust.</p>
<p>Luckily, Rust's event loops are pretty flexible and don't <em>need</em> control over the main thread, so in
<code>pyo3-asyncio</code>, we decided the best way to handle Rust/Python interop was to just surrender the main
thread to Python and run Rust's event loops in the background. Unfortunately, since most event loop
implementations <em>prefer</em> control over the main thread, this can still make some things awkward.</p>
<h3 id="pyo3-asyncio-initialization"><a class="header" href="#pyo3-asyncio-initialization">PyO3 Asyncio Initialization</a></h3>
<p>Because Python needs to control the main thread, we can't use the convenient proc macros from Rust
runtimes to handle the <code>main</code> function or <code>#[test]</code> functions. Instead, the initialization for PyO3 has to be done from the <code>main</code> function and the main
thread must block on <a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/async_std/fn.run_until_complete.html"><code>pyo3_asyncio::async_std::run_until_complete</code></a>.</p>
<p>Because we have to block on one of those functions, we can't use <a href="https://docs.rs/async-std/latest/async_std/attr.main.html"><code>#[async_std::main]</code></a> or <a href="https://docs.rs/tokio/1.1.0/tokio/attr.main.html"><code>#[tokio::main]</code></a>
since it's not a good idea to make long blocking calls during an async function.</p>
<blockquote>
<p>Internally, these <code>#[main]</code> proc macros are expanded to something like this:</p>
<pre><code class="language-rust">fn main() {
    // your async main fn
    async fn _main_impl() { /* ... */ }
    Runtime::new().block_on(_main_impl());
}</code></pre>
<p>Making a long blocking call inside the <code>Future</code> that's being driven by <code>block_on</code> prevents that
thread from doing anything else and can spell trouble for some runtimes (also this will actually
deadlock a single-threaded runtime!). Many runtimes have some sort of <code>spawn_blocking</code> mechanism
that can avoid this problem, but again that's not something we can use here since we need it to
block on the <em>main</em> thread.</p>
</blockquote>
<p>For this reason, <code>pyo3-asyncio</code> provides its own set of proc macros to provide you with this
initialization. These macros are intended to mirror the initialization of <code>async-std</code> and <code>tokio</code>
while also satisfying the Python runtime's needs.</p>
<p>Here's a full example of PyO3 initialization with the <code>async-std</code> runtime:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyo3_asyncio::async_std::main]
async fn main() -&gt; PyResult&lt;()&gt; {
    // PyO3 is initialized - Ready to go

    let fut = Python::with_gil(|py| -&gt; PyResult&lt;_&gt; {
        let asyncio = py.import("asyncio")?;

        // convert asyncio.sleep into a Rust Future
        pyo3_asyncio::async_std::into_future(
            asyncio.call_method1("sleep", (1.into_py(py),))?
        )
    })?;

    fut.await?;

    Ok(())
}</code></pre>
<h3 id="a-note-about-asynciorun"><a class="header" href="#a-note-about-asynciorun">A Note About <code>asyncio.run</code></a></h3>
<p>In Python 3.7+, the recommended way to run a top-level coroutine with <code>asyncio</code>
is with <code>asyncio.run</code>. In <code>v0.13</code> we recommended against using this function due to initialization issues, but in <code>v0.14</code> it's perfectly valid to use this function... with a caveat.</p>
<p>Since our Rust &lt;--&gt; Python conversions require a reference to the Python event loop, this poses a problem. Imagine we have a PyO3 Asyncio module that defines
a <code>rust_sleep</code> function like in previous examples. You might rightfully assume that you can call pass this directly into <code>asyncio.run</code> like this:</p>
<pre><code class="language-python">import asyncio

from my_async_module import rust_sleep

asyncio.run(rust_sleep())
</code></pre>
<p>You might be surprised to find out that this throws an error:</p>
<pre><code class="language-bash">Traceback (most recent call last):
  File "example.py", line 5, in &lt;module&gt;
    asyncio.run(rust_sleep())
RuntimeError: no running event loop
</code></pre>
<p>What's happening here is that we are calling <code>rust_sleep</code> <em>before</em> the future is
actually running on the event loop created by <code>asyncio.run</code>. This is counter-intuitive, but expected behaviour, and unfortunately there doesn't seem to be a good way of solving this problem within PyO3 Asyncio itself.</p>
<p>However, we can make this example work with a simple workaround:</p>
<pre><code class="language-python">import asyncio

from my_async_module import rust_sleep

# Calling main will just construct the coroutine that later calls rust_sleep.
# - This ensures that rust_sleep will be called when the event loop is running,
#   not before.
async def main():
    await rust_sleep()

# Run the main() coroutine at the top-level instead
asyncio.run(main())
</code></pre>
<h3 id="non-standard-python-event-loops"><a class="header" href="#non-standard-python-event-loops">Non-standard Python Event Loops</a></h3>
<p>Python allows you to use alternatives to the default <code>asyncio</code> event loop. One
popular alternative is <code>uvloop</code>. In <code>v0.13</code> using non-standard event loops was
a bit of an ordeal, but in <code>v0.14</code> it's trivial.</p>
<h4 id="using-uvloop-in-a-pyo3-asyncio-native-extensions"><a class="header" href="#using-uvloop-in-a-pyo3-asyncio-native-extensions">Using <code>uvloop</code> in a PyO3 Asyncio Native Extensions</a></h4>
<pre><code class="language-toml"># Cargo.toml

[lib]
name = "my_async_module"
crate-type = ["cdylib"]

[dependencies]
pyo3 = { version = "0.14", features = ["extension-module"] }
pyo3-asyncio = { version = "0.14", features = ["tokio-runtime"] }
async-std = "1.9"
tokio = "1.4"
</code></pre>
<pre><code class="language-rust">//! lib.rs

use pyo3::{prelude::*, wrap_pyfunction};

#[pyfunction]
fn rust_sleep(py: Python&lt;'_&gt;) -&gt; PyResult&lt;&amp;Bound&lt;'_, PyAny&gt;&gt;&gt; {
    pyo3_asyncio::tokio::future_into_py(py, async {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        Ok(Python::with_gil(|py| py.None()))
    })
}

#[pymodule]
fn my_async_module(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_sleep, m)?)?;

    Ok(())
}</code></pre>
<pre><code class="language-bash">$ maturin develop &amp;&amp; python3
🔗 Found pyo3 bindings
🐍 Found CPython 3.8 at python3
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
Python 3.8.8 (default, Apr 13 2021, 19:58:26)
[GCC 7.3.0] :: Anaconda, Inc. on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; import uvloop
&gt;&gt;&gt;
&gt;&gt;&gt; import my_async_module
&gt;&gt;&gt;
&gt;&gt;&gt; uvloop.install()
&gt;&gt;&gt;
&gt;&gt;&gt; async def main():
...     await my_async_module.rust_sleep()
...
&gt;&gt;&gt; asyncio.run(main())
&gt;&gt;&gt;
</code></pre>
<h4 id="using-uvloop-in-rust-applications"><a class="header" href="#using-uvloop-in-rust-applications">Using <code>uvloop</code> in Rust Applications</a></h4>
<p>Using <code>uvloop</code> in Rust applications is a bit trickier, but it's still possible
with relatively few modifications.</p>
<p>Unfortunately, we can't make use of the <code>#[pyo3_asyncio::&lt;runtime&gt;::main]</code> attribute with non-standard event loops. This is because the <code>#[pyo3_asyncio::&lt;runtime&gt;::main]</code> proc macro has to interact with the Python
event loop before we can install the <code>uvloop</code> policy.</p>
<pre><code class="language-toml">[dependencies]
async-std = "1.9"
pyo3 = "0.14"
pyo3-asyncio = { version = "0.14", features = ["async-std-runtime"] }
</code></pre>
<pre><code class="language-rust">//! main.rs

use pyo3::{prelude::*, types::PyType};

fn main() -&gt; PyResult&lt;()&gt; {
    pyo3::prepare_freethreaded_python();

    Python::with_gil(|py| {
        let uvloop = py.import("uvloop")?;
        uvloop.call_method0("install")?;

        // store a reference for the assertion
        let uvloop = PyObject::from(uvloop);

        pyo3_asyncio::async_std::run(py, async move {
            // verify that we are on a uvloop.Loop
            Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
                assert!(pyo3_asyncio::async_std::get_current_loop(py)?.is_instance(
                    uvloop
                        .as_ref(py)
                        .getattr("Loop")?
                )?);
                Ok(())
            })?;

            async_std::task::sleep(std::time::Duration::from_secs(1)).await;

            Ok(())
        })
    })
}</code></pre>
<h2 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h2>
<ul>
<li>Managing event loop references can be tricky with pyo3-asyncio. See <a href="https://docs.rs/pyo3-asyncio/#event-loop-references">Event Loop References</a> in the API docs to get a better intuition for how event loop references are managed in this library.</li>
<li>Testing pyo3-asyncio libraries and applications requires a custom test harness since Python requires control over the main thread. You can find a testing guide in the <a href="https://docs.rs/pyo3-asyncio/latest/pyo3_asyncio/testing">API docs for the <code>testing</code> module</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions-and-troubleshooting"><a class="header" href="#frequently-asked-questions-and-troubleshooting">Frequently Asked Questions and troubleshooting</a></h1>
<p>Sorry that you're having trouble using PyO3. If you can't find the answer to your problem in the list below, you can also reach out for help on <a href="https://github.com/PyO3/pyo3/discussions">GitHub Discussions</a> and on <a href="https://discord.gg/33kcChzH7f">Discord</a>.</p>
<h2 id="im-experiencing-deadlocks-using-pyo3-with-lazy_static-or-once_cell"><a class="header" href="#im-experiencing-deadlocks-using-pyo3-with-lazy_static-or-once_cell">I'm experiencing deadlocks using PyO3 with lazy_static or once_cell!</a></h2>
<p><code>lazy_static</code> and <code>once_cell::sync</code> both use locks to ensure that initialization is performed only by a single thread. Because the Python GIL is an additional lock this can lead to deadlocks in the following way:</p>
<ol>
<li>A thread (thread A) which has acquired the Python GIL starts initialization of a <code>lazy_static</code> value.</li>
<li>The initialization code calls some Python API which temporarily releases the GIL e.g. <code>Python::import</code>.</li>
<li>Another thread (thread B) acquires the Python GIL and attempts to access the same <code>lazy_static</code> value.</li>
<li>Thread B is blocked, because it waits for <code>lazy_static</code>'s initialization to lock to release.</li>
<li>Thread A is blocked, because it waits to re-acquire the GIL which thread B still holds.</li>
<li>Deadlock.</li>
</ol>
<p>PyO3 provides a struct <a href="https://docs.rs/pyo3/0.21.2/pyo3/sync/struct.GILOnceCell.html"><code>GILOnceCell</code></a> which works equivalently to <code>OnceCell</code> but relies solely on the Python GIL for thread safety. This means it can be used in place of <code>lazy_static</code> or <code>once_cell</code> where you are experiencing the deadlock described above. See the documentation for <a href="https://docs.rs/pyo3/0.21.2/pyo3/sync/struct.GILOnceCell.html"><code>GILOnceCell</code></a> for an example how to use it.</p>
<h2 id="i-cant-run-cargo-test-or-i-cant-build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror"><a class="header" href="#i-cant-run-cargo-test-or-i-cant-build-in-a-cargo-workspace-im-having-linker-issues-like-symbol-not-found-or-undefined-reference-to-_pyexc_systemerror">I can't run <code>cargo test</code>; or I can't build in a Cargo workspace: I'm having linker issues like "Symbol not found" or "Undefined reference to _PyExc_SystemError"!</a></h2>
<p>Currently, <a href="https://github.com/PyO3/pyo3/issues/340">#340</a> causes <code>cargo test</code> to fail with linking errors when the <code>extension-module</code> feature is activated. Linking errors can also happen when building in a cargo workspace where a different crate also uses PyO3 (see <a href="https://github.com/PyO3/pyo3/issues/2521">#2521</a>). For now, there are three ways we can work around these issues.</p>
<ol>
<li>Make the <code>extension-module</code> feature optional. Build with <code>maturin develop --features "extension-module"</code></li>
</ol>
<pre><code class="language-toml">[dependencies.pyo3]
version = "0.21.2"

[features]
extension-module = ["pyo3/extension-module"]
</code></pre>
<ol start="2">
<li>Make the <code>extension-module</code> feature optional and default. Run tests with <code>cargo test --no-default-features</code>:</li>
</ol>
<pre><code class="language-toml">[dependencies.pyo3]
version = "0.21.2"

[features]
extension-module = ["pyo3/extension-module"]
default = ["extension-module"]
</code></pre>
<ol start="3">
<li>If you are using a <a href="https://maturin.rs/metadata.html"><code>pyproject.toml</code></a> file to control maturin settings, add the following section:</li>
</ol>
<pre><code class="language-toml">[tool.maturin]
features = ["pyo3/extension-module"]
# Or for maturin 0.12:
# cargo-extra-args = ["--features", "pyo3/extension-module"]
</code></pre>
<h2 id="i-cant-run-cargo-test-my-crate-cannot-be-found-for-tests-in-tests-directory"><a class="header" href="#i-cant-run-cargo-test-my-crate-cannot-be-found-for-tests-in-tests-directory">I can't run <code>cargo test</code>: my crate cannot be found for tests in <code>tests/</code> directory!</a></h2>
<p>The Rust book suggests to <a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#integration-tests">put integration tests inside a <code>tests/</code> directory</a>.</p>
<p>For a PyO3 <code>extension-module</code> project where the <code>crate-type</code> is set to <code>"cdylib"</code> in your <code>Cargo.toml</code>,
the compiler won't be able to find your crate and will display errors such as <code>E0432</code> or <code>E0463</code>:</p>
<pre><code class="language-text">error[E0432]: unresolved import `my_crate`
 --&gt; tests/test_my_crate.rs:1:5
  |
1 | use my_crate;
  |     ^^^^^^^^^^^^ no external crate `my_crate`
</code></pre>
<p>The best solution is to make your crate types include both <code>rlib</code> and <code>cdylib</code>:</p>
<pre><code class="language-toml"># Cargo.toml
[lib]
crate-type = ["cdylib", "rlib"]
</code></pre>
<h2 id="ctrl-c-doesnt-do-anything-while-my-rust-code-is-executing"><a class="header" href="#ctrl-c-doesnt-do-anything-while-my-rust-code-is-executing">Ctrl-C doesn't do anything while my Rust code is executing!</a></h2>
<p>This is because Ctrl-C raises a SIGINT signal, which is handled by the calling Python process by simply setting a flag to action upon later. This flag isn't checked while Rust code called from Python is executing, only once control returns to the Python interpreter.</p>
<p>You can give the Python interpreter a chance to process the signal properly by calling <code>Python::check_signals</code>. It's good practice to call this function regularly if you have a long-running Rust function so that your users can cancel it.</p>
<h2 id="pyo3get-clones-my-field"><a class="header" href="#pyo3get-clones-my-field"><code>#[pyo3(get)]</code> clones my field!</a></h2>
<p>You may have a nested struct similar to this:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
#[derive(Clone)]
struct Inner {/* fields omitted */}

#[pyclass]
struct Outer {
    #[pyo3(get)]
    inner: Inner,
}

#[pymethods]
impl Outer {
    #[new]
    fn __new__() -&gt; Self {
        Self { inner: Inner {} }
    }
}</code></pre>
<p>When Python code accesses <code>Outer</code>'s field, PyO3 will return a new object on every access (note that their addresses are different):</p>
<pre><code class="language-python">outer = Outer()

a = outer.inner
b = outer.inner

assert a is b, f"a: {a}\nb: {b}"
</code></pre>
<pre><code class="language-text">AssertionError: a: &lt;builtins.Inner object at 0x00000238FFB9C7B0&gt;
b: &lt;builtins.Inner object at 0x00000238FFB9C830&gt;
</code></pre>
<p>This can be especially confusing if the field is mutable, as getting the field and then mutating it won't persist - you'll just get a fresh clone of the original on the next access. Unfortunately Python and Rust don't agree about ownership - if PyO3 gave out references to (possibly) temporary Rust objects to Python code, Python code could then keep that reference alive indefinitely. Therefore returning Rust objects requires cloning.</p>
<p>If you don't want that cloning to happen, a workaround is to allocate the field on the Python heap and store a reference to that, by using <a href="https://docs.rs/pyo3/0.21.2/pyo3/struct.Py.html"><code>Py&lt;...&gt;</code></a>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
#[derive(Clone)]
struct Inner {/* fields omitted */}

#[pyclass]
struct Outer {
    #[pyo3(get)]
    inner: Py&lt;Inner&gt;,
}

#[pymethods]
impl Outer {
    #[new]
    fn __new__(py: Python&lt;'_&gt;) -&gt; PyResult&lt;Self&gt; {
        Ok(Self {
            inner: Py::new(py, Inner {})?,
        })
    }
}</code></pre>
<p>This time <code>a</code> and <code>b</code> <em>are</em> the same object:</p>
<pre><code class="language-python">outer = Outer()

a = outer.inner
b = outer.inner

assert a is b, f"a: {a}\nb: {b}"
print(f"a: {a}\nb: {b}")
</code></pre>
<pre><code class="language-text">a: &lt;builtins.Inner object at 0x0000020044FCC670&gt;
b: &lt;builtins.Inner object at 0x0000020044FCC670&gt;
</code></pre>
<p>The downside to this approach is that any Rust code working on the <code>Outer</code> struct now has to acquire the GIL to do anything with its field.</p>
<h2 id="i-want-to-use-the-pyo3-crate-re-exported-from-dependency-but-the-proc-macros-fail"><a class="header" href="#i-want-to-use-the-pyo3-crate-re-exported-from-dependency-but-the-proc-macros-fail">I want to use the <code>pyo3</code> crate re-exported from dependency but the proc-macros fail!</a></h2>
<p>All PyO3 proc-macros (<code>#[pyclass]</code>, <code>#[pyfunction]</code>, <code>#[derive(FromPyObject)]</code>
and so on) expect the <code>pyo3</code> crate to be available under that name in your crate
root, which is the normal situation when <code>pyo3</code> is a direct dependency of your
crate.</p>
<p>However, when the dependency is renamed, or your crate only indirectly depends
on <code>pyo3</code>, you need to let the macro code know where to find the crate.  This is
done with the <code>crate</code> attribute:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">pub extern crate pyo3;
</span><span class="boring">mod reexported { pub use ::pyo3; }
</span>#[pyclass]
#[pyo3(crate = "reexported::pyo3")]
struct MyClass;</code></pre>
<h2 id="im-trying-to-call-python-from-rust-but-i-get-status_dll_not_found-or-status_entrypoint_not_found"><a class="header" href="#im-trying-to-call-python-from-rust-but-i-get-status_dll_not_found-or-status_entrypoint_not_found">I'm trying to call Python from Rust but I get <code>STATUS_DLL_NOT_FOUND</code> or <code>STATUS_ENTRYPOINT_NOT_FOUND</code>!</a></h2>
<p>This happens on Windows when linking to the python DLL fails or the wrong one is linked. The Python DLL on Windows will usually be called something like:</p>
<ul>
<li><code>python3X.dll</code> for Python 3.X, e.g. <code>python310.dll</code> for Python 3.10</li>
<li><code>python3.dll</code> when using PyO3's <code>abi3</code> feature</li>
</ul>
<p>The DLL needs to be locatable using the <a href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order#standard-search-order-for-unpackaged-apps">Windows DLL search order</a>. Some ways to achieve this are:</p>
<ul>
<li>Put the Python DLL in the same folder as your build artifacts</li>
<li>Add the directory containing the Python DLL to your <code>PATH</code> environment variable, for example <code>C:\Users\&lt;You&gt;\AppData\Local\Programs\Python\Python310</code></li>
<li>If this happens when you are <em>distributing</em> your program, consider using <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> to package it with your binary.</li>
</ul>
<p>If the wrong DLL is linked it is possible that this happened because another program added itself and its own Python DLLs to <code>PATH</code>. Rearrange your <code>PATH</code> variables to give the correct DLL priority.</p>
<blockquote>
<p><strong>Note</strong>: Changes to <code>PATH</code> (or any other environment variable) are not visible to existing shells. Restart it for changes to take effect.</p>
</blockquote>
<p>For advanced troubleshooting, <a href="https://www.dependencywalker.com/">Dependency Walker</a> can be used to diagnose linking errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-older-pyo3-versions"><a class="header" href="#migrating-from-older-pyo3-versions">Migrating from older PyO3 versions</a></h1>
<p>This guide can help you upgrade code through breaking changes from one PyO3 version to the next.
For a detailed list of all changes, see the <a href="changelog.html">CHANGELOG</a>.</p>
<h2 id="from-020-to-021"><a class="header" href="#from-020-to-021">from 0.20.* to 0.21</a></h2>
<details open>
<summary><small>Click to expand</small></summary>
<p>PyO3 0.21 introduces a new <code>Bound&lt;'py, T&gt;</code> smart pointer which replaces the existing "GIL Refs" API to interact with Python objects. For example, in PyO3 0.20 the reference <code>&amp;'py PyAny</code> would be used to interact with Python objects. In PyO3 0.21 the updated type is <code>Bound&lt;'py, PyAny&gt;</code>. Making this change moves Rust ownership semantics out of PyO3's internals and into user code. This change fixes <a href="https://github.com/PyO3/pyo3/issues/3668">a known soundness edge case of interaction with gevent</a> as well as improves CPU and <a href="https://github.com/PyO3/pyo3/issues/1056">memory performance</a>. For a full history of discussion see https://github.com/PyO3/pyo3/issues/3382.</p>
<p>The "GIL Ref" <code>&amp;'py PyAny</code> and similar types such as <code>&amp;'py PyDict</code> continue to be available as a deprecated API. Due to the advantages of the new API it is advised that all users make the effort to upgrade as soon as possible.</p>
<p>In addition to the major API type overhaul, PyO3 has needed to make a few small breaking adjustments to other APIs to close correctness and soundness gaps.</p>
<p>The recommended steps to update to PyO3 0.21 is as follows:</p>
<ol>
<li>Enable the <code>gil-refs</code> feature to silence deprecations related to the API change</li>
<li>Fix all other PyO3 0.21 migration steps</li>
<li>Disable the <code>gil-refs</code> feature and migrate off the deprecated APIs</li>
</ol>
<p>The following sections are laid out in this order.</p>
</details>
<h3 id="enable-the-gil-refs-feature"><a class="header" href="#enable-the-gil-refs-feature">Enable the <code>gil-refs</code> feature</a></h3>
<details open>
<summary><small>Click to expand</small></summary>
<p>To make the transition for the PyO3 ecosystem away from the GIL Refs API as smooth as possible, in PyO3 0.21 no APIs consuming or producing GIL Refs have been altered. Instead, variants using <code>Bound&lt;T&gt;</code> smart pointers have been introduced, for example <code>PyTuple::new_bound</code> which returns <code>Bound&lt;PyTuple&gt;</code> is the replacement form of <code>PyTuple::new</code>. The GIL Ref APIs have been deprecated, but to make migration easier it is possible to disable these deprecation warnings by enabling the <code>gil-refs</code> feature.</p>
<blockquote>
<p>The one single exception where an existing API was changed in-place is the <code>pyo3::intern!</code> macro. Almost all uses of this macro did not need to update code to account it changing to return <code>&amp;Bound&lt;PyString&gt;</code> immediately, and adding an <code>intern_bound!</code> replacement was perceived as adding more work for users.</p>
</blockquote>
<p>It is recommended that users do this as a first step of updating to PyO3 0.21 so that the deprecation warnings do not get in the way of resolving the rest of the migration steps.</p>
<p>Before:</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
pyo3 = "0.20"
</code></pre>
<p>After:</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
pyo3 = { version = "0.21", features = ["gil-refs"] }
</code></pre>
</details>
<h3 id="pytypeinfo-and-pytryfrom-have-been-adjusted"><a class="header" href="#pytypeinfo-and-pytryfrom-have-been-adjusted"><code>PyTypeInfo</code> and <code>PyTryFrom</code> have been adjusted</a></h3>
<details open>
<summary><small>Click to expand</small></summary>
<p>The <code>PyTryFrom</code> trait has aged poorly, its <code>try_from</code> method now conflicts with <code>TryFrom::try_from</code> in the 2021 edition prelude. A lot of its functionality was also duplicated with <code>PyTypeInfo</code>.</p>
<p>To tighten up the PyO3 traits as part of the deprecation of the GIL Refs API the <code>PyTypeInfo</code> trait has had a simpler companion <code>PyTypeCheck</code>. The methods <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyAny.html#method.downcast"><code>PyAny::downcast</code></a> and <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyAny.html#method.downcast_exact"><code>PyAny::downcast_exact</code></a> no longer use <code>PyTryFrom</code> as a bound, instead using <code>PyTypeCheck</code> and <code>PyTypeInfo</code> respectively.</p>
<p>To migrate, switch all type casts to use <code>obj.downcast()</code> instead of <code>try_from(obj)</code> (and similar for <code>downcast_exact</code>).</p>
<p>Before:</p>
<pre><code class="language-rust"><span class="boring">#![allow(deprecated)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::{PyInt, PyList};
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| {
    let list = PyList::new(py, 0..5);
    let b = &lt;PyInt as PyTryFrom&gt;::try_from(list.get_item(0).unwrap())?;
    Ok(())
})
<span class="boring">}</span></code></pre>
<p>After:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::{PyInt, PyList};
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span>Python::with_gil(|py| {
    // Note that PyList::new is deprecated for PyList::new_bound as part of the GIL Refs API removal,
    // see the section below on migration to Bound&lt;T&gt;.
    #[allow(deprecated)]
    let list = PyList::new(py, 0..5);
    let b = list.get_item(0).unwrap().downcast::&lt;PyInt&gt;()?;
    Ok(())
})
<span class="boring">}</span></code></pre>
</details>
<h3 id="iteranextoutput-are-deprecated"><a class="header" href="#iteranextoutput-are-deprecated"><code>Iter(A)NextOutput</code> are deprecated</a></h3>
<details open>
<summary><small>Click to expand</small></summary>
<p>The <code>__next__</code> and <code>__anext__</code> magic methods can now return any type convertible into Python objects directly just like all other <code>#[pymethods]</code>. The <code>IterNextOutput</code> used by <code>__next__</code> and <code>IterANextOutput</code> used by <code>__anext__</code> are subsequently deprecated. Most importantly, this change allows returning an awaitable from <code>__anext__</code> without non-sensically wrapping it into <code>Yield</code> or <code>Some</code>. Only the return types <code>Option&lt;T&gt;</code> and <code>Result&lt;Option&lt;T&gt;, E&gt;</code> are still handled in a special manner where <code>Some(val)</code> yields <code>val</code> and <code>None</code> stops iteration.</p>
<p>Starting with an implementation of a Python iterator using <code>IterNextOutput</code>, e.g.</p>
<pre><code class="language-rust">#![allow(deprecated)]
use pyo3::prelude::*;
use pyo3::iter::IterNextOutput;

#[pyclass]
struct PyClassIter {
    count: usize,
}

#[pymethods]
impl PyClassIter {
    fn __next__(&amp;mut self) -&gt; IterNextOutput&lt;usize, &amp;'static str&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            IterNextOutput::Yield(self.count)
        } else {
            IterNextOutput::Return("done")
        }
    }
}</code></pre>
<p>If returning <code>"done"</code> via <code>StopIteration</code> is not really required, this should be written as</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyclass]
struct PyClassIter {
    count: usize,
}

#[pymethods]
impl PyClassIter {
    fn __next__(&amp;mut self) -&gt; Option&lt;usize&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}</code></pre>
<p>This form also has additional benefits: It has already worked in previous PyO3 versions, it matches the signature of Rust's <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html"><code>Iterator</code> trait</a> and it allows using a fast path in CPython which completely avoids the cost of raising a <code>StopIteration</code> exception. Note that using <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.transpose"><code>Option::transpose</code></a> and the <code>Result&lt;Option&lt;T&gt;, E&gt;</code> variant, this form can also be used to wrap fallible iterators.</p>
<p>Alternatively, the implementation can also be done as it would in Python itself, i.e. by "raising" a <code>StopIteration</code> exception</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::exceptions::PyStopIteration;

#[pyclass]
struct PyClassIter {
    count: usize,
}

#[pymethods]
impl PyClassIter {
    fn __next__(&amp;mut self) -&gt; PyResult&lt;usize&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Ok(self.count)
        } else {
            Err(PyStopIteration::new_err("done"))
        }
    }
}</code></pre>
<p>Finally, an asynchronous iterator can directly return an awaitable without confusing wrapping</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyclass]
struct PyClassAwaitable {
    number: usize,
}

#[pymethods]
impl PyClassAwaitable {
    fn __next__(&amp;self) -&gt; usize {
        self.number
    }

    fn __await__(slf: Py&lt;Self&gt;) -&gt; Py&lt;Self&gt; {
        slf
    }
}

#[pyclass]
struct PyClassAsyncIter {
    number: usize,
}

#[pymethods]
impl PyClassAsyncIter {
    fn __anext__(&amp;mut self) -&gt; PyClassAwaitable {
        self.number += 1;
        PyClassAwaitable {
            number: self.number,
        }
    }

    fn __aiter__(slf: Py&lt;Self&gt;) -&gt; Py&lt;Self&gt; {
        slf
    }
}</code></pre>
</details>
<h3 id="pytypename-has-been-renamed-to-pytypequalname"><a class="header" href="#pytypename-has-been-renamed-to-pytypequalname"><code>PyType::name</code> has been renamed to <code>PyType::qualname</code></a></h3>
<details open>
<summary><small>Click to expand</small></summary>
<p><code>PyType::name</code> has been renamed to <code>PyType::qualname</code> to indicate that it does indeed return the <a href="https://docs.python.org/3/glossary.html#term-qualified-name">qualified name</a>, matching the <code>__qualname__</code> attribute. The newly added <code>PyType::name</code> yields the full name including the module name now which corresponds to <code>__module__.__name__</code> on the level of attributes.</p>
</details>
<h3 id="pycell-has-been-deprecated"><a class="header" href="#pycell-has-been-deprecated"><code>PyCell</code> has been deprecated</a></h3>
<details open>
<summary><small>Click to expand</small></summary>
<p>Interactions with Python objects implemented in Rust no longer need to go though <code>PyCell&lt;T&gt;</code>. Instead iteractions with Python object now consistently go through <code>Bound&lt;T&gt;</code> or <code>Py&lt;T&gt;</code> independently of whether <code>T</code> is native Python object or a <code>#[pyclass]</code> implemented in Rust. Use <code>Bound::new</code> or <code>Py::new</code> respectively to create and <code>Bound::borrow(_mut)</code> / <code>Py::borrow(_mut)</code> to borrow the Rust object.</p>
</details>
<h3 id="migrating-from-the-gil-refs-api-to-boundt"><a class="header" href="#migrating-from-the-gil-refs-api-to-boundt">Migrating from the GIL Refs API to <code>Bound&lt;T&gt;</code></a></h3>
<details open>
<summary><small>Click to expand</small></summary>
<p>To minimise breakage of code using the GIL Refs API, the <code>Bound&lt;T&gt;</code> smart pointer has been introduced by adding complements to all functions which accept or return GIL Refs. This allows code to migrate by replacing the deprecated APIs with the new ones.</p>
<p>To identify what to migrate, temporarily switch off the <code>gil-refs</code> feature to see deprecation warnings on <a href="migration.html#cases-where-pyo3-cannot-emit-gil-ref-deprecation-warnings">almost</a> all uses of APIs accepting and producing GIL Refs . Over one or more PRs it should be possible to follow the deprecation hints to update code. Depending on your development environment, switching off the <code>gil-refs</code> feature may introduce <a href="migration.html#deactivating-the-gil-refs-feature">some very targeted breakages</a>, so you may need to fixup those first.</p>
<p>For example, the following APIs have gained updated variants:</p>
<ul>
<li><code>PyList::new</code>, <code>PyTyple::new</code> and similar constructors have replacements <code>PyList::new_bound</code>, <code>PyTuple::new_bound</code> etc.</li>
<li><code>FromPyObject::extract</code> has a new <code>FromPyObject::extract_bound</code> (see the section below)</li>
<li>The <code>PyTypeInfo</code> trait has had new <code>_bound</code> methods added to accept / return <code>Bound&lt;T&gt;</code>.</li>
</ul>
<p>Because the new <code>Bound&lt;T&gt;</code> API brings ownership out of the PyO3 framework and into user code, there are a few places where user code is expected to need to adjust while switching to the new API:</p>
<ul>
<li>Code will need to add the occasional <code>&amp;</code> to borrow the new smart pointer as <code>&amp;Bound&lt;T&gt;</code> to pass these types around (or use <code>.clone()</code> at the very small cost of increasing the Python reference count)</li>
<li><code>Bound&lt;PyList&gt;</code> and <code>Bound&lt;PyTuple&gt;</code> cannot support indexing with <code>list[0]</code>, you should use <code>list.get_item(0)</code> instead.</li>
<li><code>Bound&lt;PyTuple&gt;::iter_borrowed</code> is slightly more efficient than <code>Bound&lt;PyTuple&gt;::iter</code>. The default iteration of <code>Bound&lt;PyTuple&gt;</code> cannot return borrowed references because Rust does not (yet) have "lending iterators". Similarly <code>Bound&lt;PyTuple&gt;::get_borrowed_item</code> is more efficient than <code>Bound&lt;PyTuple&gt;::get_item</code> for the same reason.</li>
<li><code>&amp;Bound&lt;T&gt;</code> does not implement <code>FromPyObject</code> (although it might be possible to do this in the future once the GIL Refs API is completely removed). Use <code>bound_any.downcast::&lt;T&gt;()</code> instead of <code>bound_any.extract::&lt;&amp;Bound&lt;T&gt;&gt;()</code>.</li>
<li><code>Bound&lt;PyString&gt;::to_str</code> now borrows from the <code>Bound&lt;PyString&gt;</code> rather than from the <code>'py</code> lifetime, so code will need to store the smart pointer as a value in some cases where previously <code>&amp;PyString</code> was just used as a temporary. (There are some more details relating to this in <a href="migration.html#deactivating-the-gil-refs-feature">the section below</a>.)</li>
<li><code>.extract::&lt;&amp;str&gt;()</code> now borrows from the source Python object. The simplest way to update is to change to <code>.extract::&lt;PyBackedStr&gt;()</code>, which retains ownership of the Python reference. See more information <a href="migration.html#deactivating-the-gil-refs-feature">in the section on deactivating the <code>gil-refs</code> feature</a>.</li>
</ul>
<p>To convert between <code>&amp;PyAny</code> and <code>&amp;Bound&lt;PyAny&gt;</code> use the <code>as_borrowed()</code> method:</p>
<pre><code class="language-rust ignore">let gil_ref: &amp;PyAny = ...;
let bound: &amp;Bound&lt;PyAny&gt; = &amp;gil_ref.as_borrowed();</code></pre>
<p>To convert between <code>Py&lt;T&gt;</code> and <code>Bound&lt;T&gt;</code> use the <code>bind()</code> / <code>into_bound()</code> methods, and <code>as_unbound()</code> / <code>unbind()</code> to go back from <code>Bound&lt;T&gt;</code> to <code>Py&lt;T&gt;</code>.</p>
<pre><code class="language-rust ignore">let obj: Py&lt;PyList&gt; = ...;
let bound: &amp;Bound&lt;'py, PyList&gt; = obj.bind(py);
let bound: Bound&lt;'py, PyList&gt; = obj.into_bound(py);

let obj: &amp;Py&lt;PyList&gt; = bound.as_unbound();
let obj: Py&lt;PyList&gt; = bound.unbind();</code></pre>
<div class="warning">
<p>⚠️ Warning: dangling pointer trap 💣</p>
<blockquote>
<p>Because of the ownership changes, code which uses <code>.as_ptr()</code> to convert <code>&amp;PyAny</code> and other GIL Refs to a <code>*mut pyo3_ffi::PyObject</code> should take care to avoid creating dangling pointers now that <code>Bound&lt;PyAny&gt;</code> carries ownership.</p>
<p>For example, the following pattern with <code>Option&lt;&amp;PyAny&gt;</code> can easily create a dangling pointer when migrating to the <code>Bound&lt;PyAny&gt;</code> smart pointer:</p>
<pre><code class="language-rust ignore">let opt: Option&lt;&amp;PyAny&gt; = ...;
let p: *mut ffi::PyObject = opt.map_or(std::ptr::null_mut(), |any| any.as_ptr());</code></pre>
<p>The correct way to migrate this code is to use <code>.as_ref()</code> to avoid dropping the <code>Bound&lt;PyAny&gt;</code> in the <code>map_or</code> closure:</p>
<pre><code class="language-rust ignore">let opt: Option&lt;Bound&lt;PyAny&gt;&gt; = ...;
let p: *mut ffi::PyObject = opt.as_ref().map_or(std::ptr::null_mut(), Bound::as_ptr);</code></pre>
</blockquote>
<div>
<h4 id="migrating-frompyobject-implementations"><a class="header" href="#migrating-frompyobject-implementations">Migrating <code>FromPyObject</code> implementations</a></h4>
<p><code>FromPyObject</code> has had a new method <code>extract_bound</code> which takes <code>&amp;Bound&lt;'py, PyAny&gt;</code> as an argument instead of <code>&amp;PyAny</code>. Both <code>extract</code> and <code>extract_bound</code> have been given default implementations in terms of the other, to avoid breaking code immediately on update to 0.21.</p>
<p>All implementations of <code>FromPyObject</code> should be switched from <code>extract</code> to <code>extract_bound</code>.</p>
<p>Before:</p>
<pre><code class="language-rust ignore">impl&lt;'py&gt; FromPyObject&lt;'py&gt; for MyType {
    fn extract(obj: &amp;'py PyAny) -&gt; PyResult&lt;Self&gt; {
        /* ... */
    }
}</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">impl&lt;'py&gt; FromPyObject&lt;'py&gt; for MyType {
    fn extract_bound(obj: &amp;Bound&lt;'py, PyAny&gt;) -&gt; PyResult&lt;Self&gt; {
        /* ... */
    }
}</code></pre>
<p>The expectation is that in 0.22 <code>extract_bound</code> will have the default implementation removed and in 0.23 <code>extract</code> will be removed.</p>
<h4 id="cases-where-pyo3-cannot-emit-gil-ref-deprecation-warnings"><a class="header" href="#cases-where-pyo3-cannot-emit-gil-ref-deprecation-warnings">Cases where PyO3 cannot emit GIL Ref deprecation warnings</a></h4>
<p>Despite a large amount of deprecations warnings produced by PyO3 to aid with the transition from GIL Refs to the Bound API, there are a few cases where PyO3 cannot automatically warn on uses of GIL Refs. It is worth checking for these cases manually after the deprecation warnings have all been addressed:</p>
<ul>
<li>Individual implementations of the <code>FromPyObject</code> trait cannot be deprecated, so PyO3 cannot warn about uses of code patterns like <code>.extract&lt;&amp;PyAny&gt;()</code> which produce a GIL Ref.</li>
<li>GIL Refs in <code>#[pyfunction]</code> arguments emit a warning, but if the GIL Ref is wrapped inside another container such as <code>Vec&lt;&amp;PyAny&gt;</code> then PyO3 cannot warn against this.</li>
<li>The <code>wrap_pyfunction!(function)(py)</code> deferred argument form of the <code>wrap_pyfunction</code> macro taking <code>py: Python&lt;'py&gt;</code> produces a GIL Ref, and due to limitations in type inference PyO3 cannot warn against this specific case.</li>
</ul>
</details>
<h3 id="deactivating-the-gil-refs-feature"><a class="header" href="#deactivating-the-gil-refs-feature">Deactivating the <code>gil-refs</code> feature</a></h3>
<details open>
<summary><small>Click to expand</small></summary>
<p>As a final step of migration, deactivating the <code>gil-refs</code> feature will set up code for best performance and is intended to set up a forward-compatible API for PyO3 0.22.</p>
<p>At this point code that needed to manage GIL Ref memory can safely remove uses of <code>GILPool</code> (which are constructed by calls to <code>Python::new_pool</code> and <code>Python::with_pool</code>). Deprecation warnings will highlight these cases.</p>
<p>There is just one case of code that changes upon disabling these features: <code>FromPyObject</code> trait implementations for types that borrow directly from the input data cannot be implemented by PyO3 without GIL Refs (while the GIL Refs API is in the process of being removed). The main types affected are <code>&amp;str</code>, <code>Cow&lt;'_, str&gt;</code>, <code>&amp;[u8]</code>, <code>Cow&lt;'_, u8&gt;</code>.</p>
<p>To make PyO3's core functionality continue to work while the GIL Refs API is in the process of being removed, disabling the <code>gil-refs</code> feature moves the implementations of <code>FromPyObject</code> for <code>&amp;str</code>, <code>Cow&lt;'_, str&gt;</code>, <code>&amp;[u8]</code>, <code>Cow&lt;'_, u8&gt;</code> to a new temporary trait <code>FromPyObjectBound</code>. This trait is the expected future form of <code>FromPyObject</code> and has an additional lifetime <code>'a</code> to enable these types to borrow data from Python objects.</p>
<p>PyO3 0.21 has introduced the <a href="https://docs.rs/pyo3/0.21.2/pyo3/pybacked/struct.PyBackedStr.html"><code>PyBackedStr</code></a> and <a href="https://docs.rs/pyo3/0.21.2/pyo3/pybacked/struct.PyBackedBytes.html"><code>PyBackedBytes</code></a> types to help with this case. The easiest way to avoid lifetime challenges from extracting <code>&amp;str</code> is to use these. For more complex types like <code>Vec&lt;&amp;str&gt;</code>, is now impossible to extract directly from a Python object and <code>Vec&lt;PyBackedStr&gt;</code> is the recommended upgrade path.</p>
<p>A key thing to note here is because extracting to these types now ties them to the input lifetime, some extremely common patterns may need to be split into multiple Rust lines. For example, the following snippet of calling <code>.extract::&lt;&amp;str&gt;()</code> directly on the result of <code>.getattr()</code> needs to be adjusted when deactivating the <code>gil-refs-migration</code> feature.</p>
<p>Before:</p>
<pre><code class="language-rust"><span class="boring">#[cfg(feature = "gil-refs-migration")] {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::{PyList, PyType};
</span><span class="boring">fn example&lt;'py&gt;(py: Python&lt;'py&gt;) -&gt; PyResult&lt;()&gt; {
</span>#[allow(deprecated)] // GIL Ref API
let obj: &amp;'py PyType = py.get_type::&lt;PyList&gt;();
let name: &amp;'py str = obj.getattr("__name__")?.extract()?;
assert_eq!(name, "list");
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">Python::with_gil(example).unwrap();
</span><span class="boring">}</span></code></pre>
<p>After:</p>
<pre><code class="language-rust"><span class="boring">#[cfg(any(not(Py_LIMITED_API), Py_3_10))] {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::{PyList, PyType};
</span><span class="boring">fn example&lt;'py&gt;(py: Python&lt;'py&gt;) -&gt; PyResult&lt;()&gt; {
</span>let obj: Bound&lt;'py, PyType&gt; = py.get_type_bound::&lt;PyList&gt;();
let name_obj: Bound&lt;'py, PyAny&gt; = obj.getattr("__name__")?;
// the lifetime of the data is no longer `'py` but the much shorter
// lifetime of the `name_obj` smart pointer above
let name: &amp;'_ str = name_obj.extract()?;
assert_eq!(name, "list");
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">Python::with_gil(example).unwrap();
</span><span class="boring">}</span></code></pre>
<p>To avoid needing to worry about lifetimes at all, it is also possible to use the new <code>PyBackedStr</code> type, which stores a reference to the Python <code>str</code> without a lifetime attachment. In particular, <code>PyBackedStr</code> helps for <code>abi3</code> builds for Python older than 3.10. Due to limitations in the <code>abi3</code> CPython API for those older versions, PyO3 cannot offer a <code>FromPyObjectBound</code> implementation for <code>&amp;str</code> on those versions. The easiest way to migrate for older <code>abi3</code> builds is to replace any cases of <code>.extract::&lt;&amp;str&gt;()</code> with <code>.extract::&lt;PyBackedStr&gt;()</code>. Alternatively, use <code>.extract::&lt;Cow&lt;str&gt;&gt;()</code>, <code>.extract::&lt;String&gt;()</code> to copy the data into Rust.</p>
<p>The following example uses the same snippet as those just above, but this time the final extracted type is <code>PyBackedStr</code>:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::{PyList, PyType};
</span><span class="boring">fn example&lt;'py&gt;(py: Python&lt;'py&gt;) -&gt; PyResult&lt;()&gt; {
</span>use pyo3::pybacked::PyBackedStr;
let obj: Bound&lt;'py, PyType&gt; = py.get_type_bound::&lt;PyList&gt;();
let name: PyBackedStr = obj.getattr("__name__")?.extract()?;
assert_eq!(&amp;*name, "list");
<span class="boring">Ok(())
</span><span class="boring">}
</span><span class="boring">Python::with_gil(example).unwrap();</span></code></pre>
<h2 id="from-019-to-020"><a class="header" href="#from-019-to-020">from 0.19.* to 0.20</a></h2>
<h3 id="drop-support-for-older-technologies"><a class="header" href="#drop-support-for-older-technologies">Drop support for older technologies</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>PyO3 0.20 has increased minimum Rust version to 1.56. This enables use of newer language features and simplifies maintenance of the project.</p>
</details>
<h3 id="pydictget_item-now-returns-a-result"><a class="header" href="#pydictget_item-now-returns-a-result"><code>PyDict::get_item</code> now returns a <code>Result</code></a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p><code>PyDict::get_item</code> in PyO3 0.19 and older was implemented using a Python API which would suppress all exceptions and return <code>None</code> in those cases. This included errors in <code>__hash__</code> and <code>__eq__</code> implementations of the key being looked up.</p>
<p>Newer recommendations by the Python core developers advise against using these APIs which suppress exceptions, instead allowing exceptions to bubble upwards. <code>PyDict::get_item_with_error</code> already implemented this recommended behavior, so that API has been renamed to <code>PyDict::get_item</code>.</p>
<p>Before:</p>
<pre><code class="language-rust ignore">use pyo3::prelude::*;
use pyo3::exceptions::PyTypeError;
use pyo3::types::{PyDict, IntoPyDict};

<span class="boring">fn main() {
</span><span class="boring">let _ =
</span>Python::with_gil(|py| {
    let dict: &amp;PyDict = [("a", 1)].into_py_dict(py);
    // `a` is in the dictionary, with value 1
    assert!(dict.get_item("a").map_or(Ok(false), |x| x.eq(1))?);
    // `b` is not in the dictionary
    assert!(dict.get_item("b").is_none());
    // `dict` is not hashable, so this fails with a `TypeError`
    assert!(dict
        .get_item_with_error(dict)
        .unwrap_err()
        .is_instance_of::&lt;PyTypeError&gt;(py));
});
<span class="boring">}</span></code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">use pyo3::prelude::*;
use pyo3::exceptions::PyTypeError;
use pyo3::types::{PyDict, IntoPyDict};

<span class="boring">fn main() {
</span><span class="boring">let _ =
</span>Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
    let dict: &amp;PyDict = [("a", 1)].into_py_dict(py);
    // `a` is in the dictionary, with value 1
    assert!(dict.get_item("a")?.map_or(Ok(false), |x| x.eq(1))?);
    // `b` is not in the dictionary
    assert!(dict.get_item("b")?.is_none());
    // `dict` is not hashable, so this fails with a `TypeError`
    assert!(dict
        .get_item(dict)
        .unwrap_err()
        .is_instance_of::&lt;PyTypeError&gt;(py));

    Ok(())
});
<span class="boring">}</span></code></pre>
</details>
<h3 id="required-arguments-are-no-longer-accepted-after-optional-arguments"><a class="header" href="#required-arguments-are-no-longer-accepted-after-optional-arguments">Required arguments are no longer accepted after optional arguments</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p><a href="./function/signature.html#trailing-optional-arguments">Trailing <code>Option&lt;T&gt;</code> arguments</a> have an automatic default of <code>None</code>. To avoid unwanted changes when modifying function signatures, in PyO3 0.18 it was deprecated to have a required argument after an <code>Option&lt;T&gt;</code> argument without using <code>#[pyo3(signature = (...))]</code> to specify the intended defaults. In PyO3 0.20, this becomes a hard error.</p>
<p>Before:</p>
<pre><code class="language-rust ignore">#[pyfunction]
fn x_or_y(x: Option&lt;u64&gt;, y: u64) -&gt; u64 {
    x.unwrap_or(y)
}</code></pre>
<p>After:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyfunction]
#[pyo3(signature = (x, y))] // both x and y have no defaults and are required
fn x_or_y(x: Option&lt;u64&gt;, y: u64) -&gt; u64 {
    x.unwrap_or(y)
}</code></pre>
</details>
<h3 id="remove-deprecated-function-forms"><a class="header" href="#remove-deprecated-function-forms">Remove deprecated function forms</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>In PyO3 0.18 the <code>#[args]</code> attribute for <code>#[pymethods]</code>, and directly specifying the function signature in <code>#[pyfunction]</code>, was deprecated. This functionality has been removed in PyO3 0.20.</p>
<p>Before:</p>
<pre><code class="language-rust ignore">#[pyfunction]
#[pyo3(a, b = "0", "/")]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}</code></pre>
<p>After:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyfunction]
#[pyo3(signature = (a, b=0, /))]
fn add(a: u64, b: u64) -&gt; u64 {
    a + b
}</code></pre>
</details>
<h3 id="intopypointer-trait-removed"><a class="header" href="#intopypointer-trait-removed"><code>IntoPyPointer</code> trait removed</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>The trait <code>IntoPyPointer</code>, which provided the <code>into_ptr</code> method on many types, has been removed. <code>into_ptr</code> is now available as an inherent method on all types that previously implemented this trait.</p>
</details>
<h3 id="aspypointer-now-unsafe-trait"><a class="header" href="#aspypointer-now-unsafe-trait"><code>AsPyPointer</code> now <code>unsafe</code> trait</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>The trait <code>AsPyPointer</code> is now <code>unsafe trait</code>, meaning any external implementation of it must be marked as <code>unsafe impl</code>, and ensure that they uphold the invariant of returning valid pointers.</p>
</details>
<h2 id="from-018-to-019"><a class="header" href="#from-018-to-019">from 0.18.* to 0.19</a></h2>
<h3 id="access-to-python-inside-__traverse__-implementations-are-now-forbidden"><a class="header" href="#access-to-python-inside-__traverse__-implementations-are-now-forbidden">Access to <code>Python</code> inside <code>__traverse__</code> implementations are now forbidden</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>During <code>__traverse__</code> implementations for Python's Garbage Collection it is forbidden to do anything other than visit the members of the <code>#[pyclass]</code> being traversed. This means making Python function calls or other API calls are forbidden.</p>
<p>Previous versions of PyO3 would allow access to <code>Python</code> (e.g. via <code>Python::with_gil</code>), which could cause the Python interpreter to crash or otherwise confuse the garbage collection algorithm.</p>
<p>Attempts to acquire the GIL will now panic. See <a href="https://github.com/PyO3/pyo3/issues/3165">#3165</a> for more detail.</p>
<pre><code class="language-rust ignore"><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct SomeClass {}

impl SomeClass {
    fn __traverse__(&amp;self, pyo3::class::gc::PyVisit&lt;'_&gt;) -&gt; Result&lt;(), pyo3::class::gc::PyTraverseError&gt;` {
        Python::with_gil(|| { /*...*/ })  // ERROR: this will panic
    }
}</code></pre>
</details>
<h3 id="smarter-anyhowerror--eyrereport-conversion-when-inner-error-is-simple-pyerr"><a class="header" href="#smarter-anyhowerror--eyrereport-conversion-when-inner-error-is-simple-pyerr">Smarter <code>anyhow::Error</code> / <code>eyre::Report</code> conversion when inner error is "simple" <code>PyErr</code></a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>When converting from <code>anyhow::Error</code> or <code>eyre::Report</code> to <code>PyErr</code>, if the inner error is a "simple" <code>PyErr</code> (with no source error), then the inner error will be used directly as the <code>PyErr</code> instead of wrapping it in a new <code>PyRuntimeError</code> with the original information converted into a string.</p>
<pre><code class="language-rust ignore"><span class="boring">#[cfg(feature = "anyhow")]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">mod anyhow_only {
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::exceptions::PyValueError;
</span>#[pyfunction]
fn raise_err() -&gt; anyhow::Result&lt;()&gt; {
    Err(PyValueError::new_err("original error message").into())
}

fn main() {
    Python::with_gil(|py| {
        let rs_func = wrap_pyfunction!(raise_err, py).unwrap();
        pyo3::py_run!(
            py,
            rs_func,
            r"
        try:
            rs_func()
        except Exception as e:
            print(repr(e))
        "
        );
    })
}
<span class="boring">}</span></code></pre>
<p>Before, the above code would have printed <code>RuntimeError('ValueError: original error message')</code>, which might be confusing.</p>
<p>After, the same code will print <code>ValueError: original error message</code>, which is more straightforward.</p>
<p>However, if the <code>anyhow::Error</code> or <code>eyre::Report</code> has a source, then the original exception will still be wrapped in a <code>PyRuntimeError</code>.</p>
</details>
<h3 id="the-deprecated-pythonacquire_gil-was-removed-and-pythonwith_gil-must-be-used-instead"><a class="header" href="#the-deprecated-pythonacquire_gil-was-removed-and-pythonwith_gil-must-be-used-instead">The deprecated <code>Python::acquire_gil</code> was removed and <code>Python::with_gil</code> must be used instead</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>While the API provided by <a href="https://docs.rs/pyo3/0.18.3/pyo3/marker/struct.Python.html#method.acquire_gil"><code>Python::acquire_gil</code></a> seems convenient, it is somewhat brittle as the design of the GIL token <a href="https://docs.rs/pyo3/0.18.3/pyo3/marker/struct.Python.html"><code>Python</code></a> relies on proper nesting and panics if not used correctly, e.g.</p>
<pre><code class="language-rust ignore"><span class="boring">#![allow(dead_code, deprecated)]
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct SomeClass {}

struct ObjectAndGuard {
    object: Py&lt;SomeClass&gt;,
    guard: GILGuard,
}

impl ObjectAndGuard {
    fn new() -&gt; Self {
        let guard = Python::acquire_gil();
        let object = Py::new(guard.python(), SomeClass {}).unwrap();

        Self { object, guard }
    }
}

let first = ObjectAndGuard::new();
let second = ObjectAndGuard::new();
// Panics because the guard within `second` is still alive.
drop(first);
drop(second);</code></pre>
<p>The replacement is <a href="https://docs.rs/pyo3/0.18.3/pyo3/marker/struct.Python.html#method.with_gil"><code>Python::with_gil</code></a> which is more cumbersome but enforces the proper nesting by design, e.g.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct SomeClass {}

struct Object {
    object: Py&lt;SomeClass&gt;,
}

impl Object {
    fn new(py: Python&lt;'_&gt;) -&gt; Self {
        let object = Py::new(py, SomeClass {}).unwrap();

        Self { object }
    }
}

// It either forces us to release the GIL before aquiring it again.
let first = Python::with_gil(|py| Object::new(py));
let second = Python::with_gil(|py| Object::new(py));
drop(first);
drop(second);

// Or it ensure releasing the inner lock before the outer one.
Python::with_gil(|py| {
    let first = Object::new(py);
    let second = Python::with_gil(|py| Object::new(py));
    drop(first);
    drop(second);
});</code></pre>
<p>Furthermore, <code>Python::acquire_gil</code> provides ownership of a <code>GILGuard</code> which can be freely stored and passed around. This is usually not helpful as it may keep the lock held for a long time thereby blocking progress in other parts of the program. Due to the generative lifetime attached to the GIL token supplied by <code>Python::with_gil</code>, the problem is avoided as the GIL token can only be passed down the call chain. Often, this issue can also be avoided entirely as any GIL-bound reference <code>&amp;'py PyAny</code> implies access to a GIL token <code>Python&lt;'py&gt;</code> via the <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html#method.py"><code>PyAny::py</code></a> method.</p>
</details>
<h2 id="from-017-to-018"><a class="header" href="#from-017-to-018">from 0.17.* to 0.18</a></h2>
<h3 id="required-arguments-after-option_-arguments-will-no-longer-be-automatically-inferred"><a class="header" href="#required-arguments-after-option_-arguments-will-no-longer-be-automatically-inferred">Required arguments after <code>Option&lt;_&gt;</code> arguments will no longer be automatically inferred</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>In <code>#[pyfunction]</code> and <code>#[pymethods]</code>, if a "required" function input such as <code>i32</code> came after an <code>Option&lt;_&gt;</code> input, then the <code>Option&lt;_&gt;</code> would be implicitly treated as required. (All trailing <code>Option&lt;_&gt;</code> arguments were treated as optional with a default value of <code>None</code>).</p>
<p>Starting with PyO3 0.18, this is deprecated and a future PyO3 version will require a <a href="./function/signature.html"><code>#[pyo3(signature = (...))]</code> option</a> to explicitly declare the programmer's intention.</p>
<p>Before, x in the below example would be required to be passed from Python code:</p>
<pre><code class="language-rust compile_fail"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyfunction]
fn required_argument_after_option(x: Option&lt;i32&gt;, y: i32) {}</code></pre>
<p>After, specify the intended Python signature explicitly:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>
// If x really was intended to be required
#[pyfunction(signature = (x, y))]
fn required_argument_after_option_a(x: Option&lt;i32&gt;, y: i32) {}

// If x was intended to be optional, y needs a default too
#[pyfunction(signature = (x=None, y=0))]
fn required_argument_after_option_b(x: Option&lt;i32&gt;, y: i32) {}</code></pre>
</details>
<h3 id="__text_signature__-is-now-automatically-generated-for-pyfunction-and-pymethods"><a class="header" href="#__text_signature__-is-now-automatically-generated-for-pyfunction-and-pymethods"><code>__text_signature__</code> is now automatically generated for <code>#[pyfunction]</code> and <code>#[pymethods]</code></a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>The <a href="./function/signature.html#making-the-function-signature-available-to-python"><code>#[pyo3(text_signature = "...")]</code> option</a> was previously the only supported way to set the <code>__text_signature__</code> attribute on generated Python functions.</p>
<p>PyO3 is now able to automatically populate <code>__text_signature__</code> for all functions automatically based on their Rust signature (or the <a href="./function/signature.html">new <code>#[pyo3(signature = (...))]</code> option</a>). These automatically-generated <code>__text_signature__</code> values will currently only render <code>...</code> for all default values. Many <code>#[pyo3(text_signature = "...")]</code> options can be removed from functions when updating to PyO3 0.18, however in cases with default values a manual implementation may still be preferred for now.</p>
<p>As examples:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>
// The `text_signature` option here is no longer necessary, as PyO3 will automatically
// generate exactly the same value.
#[pyfunction(text_signature = "(a, b, c)")]
fn simple_function(a: i32, b: i32, c: i32) {}

// The `text_signature` still provides value here as of PyO3 0.18, because the automatically
// generated signature would be "(a, b=..., c=...)".
#[pyfunction(signature = (a, b = 1, c = 2), text_signature = "(a, b=1, c=2)")]
fn function_with_defaults(a: i32, b: i32, c: i32) {}

<span class="boring">fn main() {
</span><span class="boring">    Python::with_gil(|py| {
</span><span class="boring">        let simple = wrap_pyfunction_bound!(simple_function, py).unwrap();
</span><span class="boring">        assert_eq!(simple.getattr("__text_signature__").unwrap().to_string(), "(a, b, c)");
</span><span class="boring">        let defaulted = wrap_pyfunction_bound!(function_with_defaults, py).unwrap();
</span><span class="boring">        assert_eq!(defaulted.getattr("__text_signature__").unwrap().to_string(), "(a, b=1, c=2)");
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
</details>
<h2 id="from-016-to-017"><a class="header" href="#from-016-to-017">from 0.16.* to 0.17</a></h2>
<h3 id="type-checks-have-been-changed-for-pymapping-and-pysequence-types"><a class="header" href="#type-checks-have-been-changed-for-pymapping-and-pysequence-types">Type checks have been changed for <code>PyMapping</code> and <code>PySequence</code> types</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>Previously the type checks for <code>PyMapping</code> and <code>PySequence</code> (implemented in <code>PyTryFrom</code>)
used the Python C-API functions <code>PyMapping_Check</code> and <code>PySequence_Check</code>.
Unfortunately these functions are not sufficient for distinguishing such types,
leading to inconsistent behavior (see
<a href="https://github.com/PyO3/pyo3/issues/2072">pyo3/pyo3#2072</a>).</p>
<p>PyO3 0.17 changes these downcast checks to explicitly test if the type is a
subclass of the corresponding abstract base class <code>collections.abc.Mapping</code> or
<code>collections.abc.Sequence</code>. Note this requires calling into Python, which may
incur a performance penalty over the previous method. If this performance
penalty is a problem, you may be able to perform your own checks and use
<code>try_from_unchecked</code> (unsafe).</p>
<p>Another side-effect is that a pyclass defined in Rust with PyO3 will need to
be <em>registered</em> with the corresponding Python abstract base class for
downcasting to succeed. <code>PySequence::register</code> and <code>PyMapping:register</code> have
been added to make it easy to do this from Rust code. These are equivalent to
calling <code>collections.abc.Mapping.register(MappingPyClass)</code> or
<code>collections.abc.Sequence.register(SequencePyClass)</code> from Python.</p>
<p>For example, for a mapping class defined in Rust:</p>
<pre><code class="language-rust compile_fail">use pyo3::prelude::*;
use std::collections::HashMap;

#[pyclass(mapping)]
struct Mapping {
    index: HashMap&lt;String, usize&gt;,
}

#[pymethods]
impl Mapping {
    #[new]
    fn new(elements: Option&lt;&amp;PyList&gt;) -&gt; PyResult&lt;Self&gt; {
    // ...
    // truncated implementation of this mapping pyclass - basically a wrapper around a HashMap
}</code></pre>
<p>You must register the class with <code>collections.abc.Mapping</code> before the downcast will work:</p>
<pre><code class="language-rust compile_fail">let m = Py::new(py, Mapping { index }).unwrap();
assert!(m.as_ref(py).downcast::&lt;PyMapping&gt;().is_err());
PyMapping::register::&lt;Mapping&gt;(py).unwrap();
assert!(m.as_ref(py).downcast::&lt;PyMapping&gt;().is_ok());</code></pre>
<p>Note that this requirement may go away in the future when a pyclass is able to inherit from the abstract base class directly (see <a href="https://github.com/PyO3/pyo3/issues/991">pyo3/pyo3#991</a>).</p>
</details>
<h3 id="the-multiple-pymethods-feature-now-requires-rust-162"><a class="header" href="#the-multiple-pymethods-feature-now-requires-rust-162">The <code>multiple-pymethods</code> feature now requires Rust 1.62</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>Due to limitations in the <code>inventory</code> crate which the <code>multiple-pymethods</code> feature depends on, this feature now
requires Rust 1.62. For more information see <a href="https://github.com/dtolnay/inventory/issues/32">dtolnay/inventory#32</a>.</p>
</details>
<h3 id="added-impl-intopypypystring-for-str"><a class="header" href="#added-impl-intopypypystring-for-str">Added <code>impl IntoPy&lt;Py&lt;PyString&gt;&gt; for &amp;str</code></a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>This may cause inference errors.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>Python::with_gil(|py| {
    // Cannot infer either `Py&lt;PyAny&gt;` or `Py&lt;PyString&gt;`
    let _test = "test".into_py(py);
});
<span class="boring">}</span></code></pre>
<p>After, some type annotations may be necessary:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>Python::with_gil(|py| {
    let _test: Py&lt;PyAny&gt; = "test".into_py(py);
});
<span class="boring">}</span></code></pre>
</details>
<h3 id="the-pyproto-feature-is-now-disabled-by-default"><a class="header" href="#the-pyproto-feature-is-now-disabled-by-default">The <code>pyproto</code> feature is now disabled by default</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>In preparation for removing the deprecated <code>#[pyproto]</code> attribute macro in a future PyO3 version, it is now gated behind an opt-in feature flag. This also gives a slight saving to compile times for code which does not use the deprecated macro.</p>
</details>
<h3 id="pytypeobject-trait-has-been-deprecated"><a class="header" href="#pytypeobject-trait-has-been-deprecated"><code>PyTypeObject</code> trait has been deprecated</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>The <code>PyTypeObject</code> trait already was near-useless; almost all functionality was already on the <code>PyTypeInfo</code> trait, which <code>PyTypeObject</code> had a blanket implementation based upon. In PyO3 0.17 the final method, <code>PyTypeObject::type_object</code> was moved to <code>PyTypeInfo::type_object</code>.</p>
<p>To migrate, update trait bounds and imports from <code>PyTypeObject</code> to <code>PyTypeInfo</code>.</p>
<p>Before:</p>
<pre><code class="language-rust ignore">use pyo3::Python;
use pyo3::type_object::PyTypeObject;
use pyo3::types::PyType;

fn get_type_object&lt;T: PyTypeObject&gt;(py: Python&lt;'_&gt;) -&gt; &amp;PyType {
    T::type_object(py)
}</code></pre>
<p>After</p>
<pre><code class="language-rust ignore">use pyo3::{Python, PyTypeInfo};
use pyo3::types::PyType;

fn get_type_object&lt;T: PyTypeInfo&gt;(py: Python&lt;'_&gt;) -&gt; &amp;PyType {
    T::type_object(py)
}

<span class="boring">Python::with_gil(|py| { get_type_object::&lt;pyo3::types::PyList&gt;(py); });</span></code></pre>
</details>
<h3 id="implt-const-n-usize-intopypyobject-for-t-n-now-requires-t-intopy-rather-than-t-topyobject"><a class="header" href="#implt-const-n-usize-intopypyobject-for-t-n-now-requires-t-intopy-rather-than-t-topyobject"><code>impl&lt;T, const N: usize&gt; IntoPy&lt;PyObject&gt; for [T; N]</code> now requires <code>T: IntoPy</code> rather than <code>T: ToPyObject</code></a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>If this leads to errors, simply implement <code>IntoPy</code>. Because pyclasses already implement <code>IntoPy</code>, you probably don't need to worry about this.</p>
</details>
<h3 id="each-pymodule-can-now-only-be-initialized-once-per-process"><a class="header" href="#each-pymodule-can-now-only-be-initialized-once-per-process">Each <code>#[pymodule]</code> can now only be initialized once per process</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>To make PyO3 modules sound in the presence of Python sub-interpreters, for now it has been necessary to explicitly disable the ability to initialize a <code>#[pymodule]</code> more than once in the same process. Attempting to do this will now raise an <code>ImportError</code>.</p>
</details>
<h2 id="from-015-to-016"><a class="header" href="#from-015-to-016">from 0.15.* to 0.16</a></h2>
<h3 id="drop-support-for-older-technologies-1"><a class="header" href="#drop-support-for-older-technologies-1">Drop support for older technologies</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>PyO3 0.16 has increased minimum Rust version to 1.48 and minimum Python version to 3.7. This enables use of newer language features (enabling some of the other additions in 0.16) and simplifies maintenance of the project.</p>
</details>
<h3 id="pyproto-has-been-deprecated"><a class="header" href="#pyproto-has-been-deprecated"><code>#[pyproto]</code> has been deprecated</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>In PyO3 0.15, the <code>#[pymethods]</code> attribute macro gained support for implementing "magic methods" such as <code>__str__</code> (aka "dunder" methods). This implementation was not quite finalized at the time, with a few edge cases to be decided upon. The existing <code>#[pyproto]</code> attribute macro was left untouched, because it covered these edge cases.</p>
<p>In PyO3 0.16, the <code>#[pymethods]</code> implementation has been completed and is now the preferred way to implement magic methods. To allow the PyO3 project to move forward, <code>#[pyproto]</code> has been deprecated (with expected removal in PyO3 0.18).</p>
<p>Migration from <code>#[pyproto]</code> to <code>#[pymethods]</code> is straightforward; copying the existing methods directly from the <code>#[pyproto]</code> trait implementation is all that is needed in most cases.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail">use pyo3::prelude::*;
use pyo3::class::{PyObjectProtocol, PyIterProtocol};
use pyo3::types::PyString;

#[pyclass]
struct MyClass {}

#[pyproto]
impl PyObjectProtocol for MyClass {
    fn __str__(&amp;self) -&gt; &amp;'static [u8] {
        b"hello, world"
    }
}

#[pyproto]
impl PyIterProtocol for MyClass {
    fn __iter__(slf: PyRef&lt;self&gt;) -&gt; PyResult&lt;&amp;PyAny&gt; {
        PyString::new(slf.py(), "hello, world").iter()
    }
}</code></pre>
<p>After</p>
<pre><code class="language-rust compile_fail">use pyo3::prelude::*;
use pyo3::types::PyString;

#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
    fn __str__(&amp;self) -&gt; &amp;'static [u8] {
        b"hello, world"
    }

    fn __iter__(slf: PyRef&lt;self&gt;) -&gt; PyResult&lt;&amp;PyAny&gt; {
        PyString::new(slf.py(), "hello, world").iter()
    }
}</code></pre>
</details>
<h3 id="removed-partialeq-for-object-wrappers"><a class="header" href="#removed-partialeq-for-object-wrappers">Removed <code>PartialEq</code> for object wrappers</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>The Python object wrappers <code>Py</code> and <code>PyAny</code> had implementations of <code>PartialEq</code>
so that <code>object_a == object_b</code> would compare the Python objects for pointer
equality, which corresponds to the <code>is</code> operator, not the <code>==</code> operator in
Python.  This has been removed in favor of a new method: use
<code>object_a.is(object_b)</code>.  This also has the advantage of not requiring the same
wrapper type for <code>object_a</code> and <code>object_b</code>; you can now directly compare a
<code>Py&lt;T&gt;</code> with a <code>&amp;PyAny</code> without having to convert.</p>
<p>To check for Python object equality (the Python <code>==</code> operator), use the new
method <code>eq()</code>.</p>
</details>
<h3 id="container-magic-methods-now-match-python-behavior"><a class="header" href="#container-magic-methods-now-match-python-behavior">Container magic methods now match Python behavior</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>In PyO3 0.15, <code>__getitem__</code>, <code>__setitem__</code> and <code>__delitem__</code> in <code>#[pymethods]</code> would generate only the <em>mapping</em> implementation for a <code>#[pyclass]</code>. To match the Python behavior, these methods now generate both the <em>mapping</em> <strong>and</strong> <em>sequence</em> implementations.</p>
<p>This means that classes implementing these <code>#[pymethods]</code> will now also be treated as sequences, same as a Python <code>class</code> would be. Small differences in behavior may result:</p>
<ul>
<li>PyO3 will allow instances of these classes to be cast to <code>PySequence</code> as well as <code>PyMapping</code>.</li>
<li>Python will provide a default implementation of <code>__iter__</code> (if the class did not have one) which repeatedly calls <code>__getitem__</code> with integers (starting at 0) until an <code>IndexError</code> is raised.</li>
</ul>
<p>To explain this in detail, consider the following Python class:</p>
<pre><code class="language-python">class ExampleContainer:

    def __len__(self):
        return 5

    def __getitem__(self, idx: int) -&gt; int:
        if idx &lt; 0 or idx &gt; 5:
            raise IndexError()
        return idx
</code></pre>
<p>This class implements a Python <a href="https://docs.python.org/3/glossary.html#term-sequence">sequence</a>.</p>
<p>The <code>__len__</code> and <code>__getitem__</code> methods are also used to implement a Python <a href="https://docs.python.org/3/glossary.html#term-mapping">mapping</a>. In the Python C-API, these methods are not shared: the sequence <code>__len__</code> and <code>__getitem__</code> are defined by the <code>sq_length</code> and <code>sq_item</code> slots, and the mapping equivalents are <code>mp_length</code> and <code>mp_subscript</code>. There are similar distinctions for <code>__setitem__</code> and <code>__delitem__</code>.</p>
<p>Because there is no such distinction from Python, implementing these methods will fill the mapping and sequence slots simultaneously. A Python class with <code>__len__</code> implemented, for example, will have both the <code>sq_length</code> and <code>mp_length</code> slots filled.</p>
<p>The PyO3 behavior in 0.16 has been changed to be closer to this Python behavior by default.</p>
</details>
<h3 id="wrap_pymodule-and-wrap_pyfunction-now-respect-privacy-correctly"><a class="header" href="#wrap_pymodule-and-wrap_pyfunction-now-respect-privacy-correctly"><code>wrap_pymodule!</code> and <code>wrap_pyfunction!</code> now respect privacy correctly</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>Prior to PyO3 0.16 the <code>wrap_pymodule!</code> and <code>wrap_pyfunction!</code> macros could use modules and functions whose defining <code>fn</code> was not reachable according Rust privacy rules.</p>
<p>For example, the following code was legal before 0.16, but in 0.16 is rejected because the <code>wrap_pymodule!</code> macro cannot access the <code>private_submodule</code> function:</p>
<pre><code class="language-rust compile_fail">mod foo {
    use pyo3::prelude::*;

    #[pymodule]
    fn private_submodule(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
        Ok(())
    }
}

use pyo3::prelude::*;
use foo::*;

#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pymodule!(private_submodule))?;
    Ok(())
}</code></pre>
<p>To fix it, make the private submodule visible, e.g. with <code>pub</code> or <code>pub(crate)</code>.</p>
<pre><code class="language-rust ignore">mod foo {
    use pyo3::prelude::*;

    #[pymodule]
    pub(crate) fn private_submodule(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
        Ok(())
    }
}

use pyo3::prelude::*;
use pyo3::wrap_pymodule;
use foo::*;

#[pymodule]
fn my_module(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_wrapped(wrap_pymodule!(private_submodule))?;
    Ok(())
}</code></pre>
</details>
<h2 id="from-014-to-015"><a class="header" href="#from-014-to-015">from 0.14.* to 0.15</a></h2>
<h3 id="changes-in-sequence-indexing"><a class="header" href="#changes-in-sequence-indexing">Changes in sequence indexing</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>For all types that take sequence indices (<code>PyList</code>, <code>PyTuple</code> and <code>PySequence</code>),
the API has been made consistent to only take <code>usize</code> indices, for consistency
with Rust's indexing conventions.  Negative indices, which were only
sporadically supported even in APIs that took <code>isize</code>, now aren't supported
anywhere.</p>
<p>Further, the <code>get_item</code> methods now always return a <code>PyResult</code> instead of
panicking on invalid indices.  The <code>Index</code> trait has been implemented instead,
and provides the same panic behavior as on Rust vectors.</p>
<p>Note that <em>slice</em> indices (accepted by <code>PySequence::get_slice</code> and other) still
inherit the Python behavior of clamping the indices to the actual length, and
not panicking/returning an error on out of range indices.</p>
<p>An additional advantage of using Rust's indexing conventions for these types is
that these types can now also support Rust's indexing operators as part of a
consistent API:</p>
<pre><code class="language-rust">#![allow(deprecated)]
use pyo3::{Python, types::PyList};

Python::with_gil(|py| {
    let list = PyList::new(py, &amp;[1, 2, 3]);
    assert_eq!(list[0..2].to_string(), "[1, 2]");
});</code></pre>
</details>
<h2 id="from-013-to-014"><a class="header" href="#from-013-to-014">from 0.13.* to 0.14</a></h2>
<h3 id="auto-initialize-feature-is-now-opt-in"><a class="header" href="#auto-initialize-feature-is-now-opt-in"><code>auto-initialize</code> feature is now opt-in</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>For projects embedding Python in Rust, PyO3 no longer automatically initializes a Python interpreter on the first call to <code>Python::with_gil</code> (or <code>Python::acquire_gil</code>) unless the <a href="features.html#auto-initialize"><code>auto-initialize</code> feature</a> is enabled.</p>
</details>
<h3 id="new-multiple-pymethods-feature"><a class="header" href="#new-multiple-pymethods-feature">New <code>multiple-pymethods</code> feature</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p><code>#[pymethods]</code> have been reworked with a simpler default implementation which removes the dependency on the <code>inventory</code> crate. This reduces dependencies and compile times for the majority of users.</p>
<p>The limitation of the new default implementation is that it cannot support multiple <code>#[pymethods]</code> blocks for the same <code>#[pyclass]</code>. If you need this functionality, you must enable the <code>multiple-pymethods</code> feature which will switch <code>#[pymethods]</code> to the inventory-based implementation.</p>
</details>
<h3 id="deprecated-pyproto-methods"><a class="header" href="#deprecated-pyproto-methods">Deprecated <code>#[pyproto]</code> methods</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>Some protocol (aka <code>__dunder__</code>) methods such as <code>__bytes__</code> and <code>__format__</code> have been possible to implement two ways in PyO3 for some time: via a <code>#[pyproto]</code> (e.g. <code>PyObjectProtocol</code> for the methods listed here), or by writing them directly in <code>#[pymethods]</code>. This is only true for a handful of the <code>#[pyproto]</code> methods (for technical reasons to do with the way PyO3 currently interacts with the Python C-API).</p>
<p>In the interest of having only one way to do things, the <code>#[pyproto]</code> forms of these methods have been deprecated.</p>
<p>To migrate just move the affected methods from a <code>#[pyproto]</code> to a <code>#[pymethods]</code> block.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail">use pyo3::prelude::*;
use pyo3::class::basic::PyObjectProtocol;

#[pyclass]
struct MyClass {}

#[pyproto]
impl PyObjectProtocol for MyClass {
    fn __bytes__(&amp;self) -&gt; &amp;'static [u8] {
        b"hello, world"
    }
}</code></pre>
<p>After:</p>
<pre><code class="language-rust">use pyo3::prelude::*;

#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
    fn __bytes__(&amp;self) -&gt; &amp;'static [u8] {
        b"hello, world"
    }
}</code></pre>
</details>
<h2 id="from-012-to-013"><a class="header" href="#from-012-to-013">from 0.12.* to 0.13</a></h2>
<h3 id="minimum-rust-version-increased-to-rust-145"><a class="header" href="#minimum-rust-version-increased-to-rust-145">Minimum Rust version increased to Rust 1.45</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>PyO3 <code>0.13</code> makes use of new Rust language features stabilized between Rust 1.40 and Rust 1.45. If you are using a Rust compiler older than Rust 1.45, you will need to update your toolchain to be able to continue using PyO3.</p>
</details>
<h3 id="runtime-changes-to-support-the-cpython-limited-api"><a class="header" href="#runtime-changes-to-support-the-cpython-limited-api">Runtime changes to support the CPython limited API</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>In PyO3 <code>0.13</code> support was added for compiling against the CPython limited API. This had a number of implications for <em>all</em> PyO3 users, described here.</p>
<p>The largest of these is that all types created from PyO3 are what CPython calls "heap" types. The specific implications of this are:</p>
<ul>
<li>If you wish to subclass one of these types <em>from Rust</em> you must mark it <code>#[pyclass(subclass)]</code>, as you would if you wished to allow subclassing it from Python code.</li>
<li>Type objects are now mutable - Python code can set attributes on them.</li>
<li><code>__module__</code> on types without <code>#[pyclass(module="mymodule")]</code> no longer returns <code>builtins</code>, it now raises <code>AttributeError</code>.</li>
</ul>
</details>
<h2 id="from-011-to-012"><a class="header" href="#from-011-to-012">from 0.11.* to 0.12</a></h2>
<h3 id="pyerr-has-been-reworked"><a class="header" href="#pyerr-has-been-reworked"><code>PyErr</code> has been reworked</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>In PyO3 <code>0.12</code> the <code>PyErr</code> type has been re-implemented to be significantly more compatible with
the standard Rust error handling ecosystem. Specifically <code>PyErr</code> now implements
<code>Error + Send + Sync</code>, which are the standard traits used for error types.</p>
<p>While this has necessitated the removal of a number of APIs, the resulting <code>PyErr</code> type should now
be much more easier to work with. The following sections list the changes in detail and how to
migrate to the new APIs.</p>
</details>
<h4 id="pyerrnew-and-pyerrfrom_type-now-require-send--sync-for-their-argument"><a class="header" href="#pyerrnew-and-pyerrfrom_type-now-require-send--sync-for-their-argument"><code>PyErr::new</code> and <code>PyErr::from_type</code> now require <code>Send + Sync</code> for their argument</a></h4>
<details>
<summary><small>Click to expand</small></summary>
<p>For most uses no change will be needed. If you are trying to construct <code>PyErr</code> from a value that is
not <code>Send + Sync</code>, you will need to first create the Python object and then use
<code>PyErr::from_instance</code>.</p>
<p>Similarly, any types which implemented <code>PyErrArguments</code> will now need to be <code>Send + Sync</code>.</p>
</details>
<h4 id="pyerrs-contents-are-now-private"><a class="header" href="#pyerrs-contents-are-now-private"><code>PyErr</code>'s contents are now private</a></h4>
<details>
<summary><small>Click to expand</small></summary>
<p>It is no longer possible to access the fields <code>.ptype</code>, <code>.pvalue</code> and <code>.ptraceback</code> of a <code>PyErr</code>.
You should instead now use the new methods <code>PyErr::ptype</code>, <code>PyErr::pvalue</code> and <code>PyErr::ptraceback</code>.</p>
</details>
<h4 id="pyerrvalue-and-pyerrfrom_value-have-been-removed"><a class="header" href="#pyerrvalue-and-pyerrfrom_value-have-been-removed"><code>PyErrValue</code> and <code>PyErr::from_value</code> have been removed</a></h4>
<details>
<summary><small>Click to expand</small></summary>
<p>As these were part the internals of <code>PyErr</code> which have been reworked, these APIs no longer exist.</p>
<p>If you used this API, it is recommended to use <code>PyException::new_err</code> (see <a href="migration.html#exception-types-have-been-reworked">the section on
Exception types</a>).</p>
</details>
<h4 id="intopyresultt-for-pyerr-has-been-removed"><a class="header" href="#intopyresultt-for-pyerr-has-been-removed"><code>Into&lt;PyResult&lt;T&gt;&gt;</code> for <code>PyErr</code> has been removed</a></h4>
<details>
<summary><small>Click to expand</small></summary>
<p>This implementation was redundant. Just construct the <code>Result::Err</code> variant directly.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail">let result: PyResult&lt;()&gt; = PyErr::new::&lt;TypeError, _&gt;("error message").into();</code></pre>
<p>After (also using the new reworked exception types; see the following section):</p>
<pre><code class="language-rust"><span class="boring">use pyo3::{PyResult, exceptions::PyTypeError};
</span>let result: PyResult&lt;()&gt; = Err(PyTypeError::new_err("error message"));</code></pre>
</details>
<h3 id="exception-types-have-been-reworked"><a class="header" href="#exception-types-have-been-reworked">Exception types have been reworked</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>Previously exception types were zero-sized marker types purely used to construct <code>PyErr</code>. In PyO3
0.12, these types have been replaced with full definitions and are usable in the same way as <code>PyAny</code>, <code>PyDict</code> etc. This
makes it possible to interact with Python exception objects.</p>
<p>The new types also have names starting with the "Py" prefix. For example, before:</p>
<pre><code class="language-rust ignore">let err: PyErr = TypeError::py_err("error message");</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore"><span class="boring">use pyo3::{PyErr, PyResult, Python, type_object::PyTypeObject};
</span><span class="boring">use pyo3::exceptions::{PyBaseException, PyTypeError};
</span><span class="boring">Python::with_gil(|py| -&gt; PyResult&lt;()&gt; {
</span>let err: PyErr = PyTypeError::new_err("error message");

// Uses Display for PyErr, new for PyO3 0.12
assert_eq!(err.to_string(), "TypeError: error message");

// Now possible to interact with exception instances, new for PyO3 0.12
let instance: &amp;PyBaseException = err.instance(py);
assert_eq!(
    instance.getattr("__class__")?,
    PyTypeError::type_object(py).as_ref()
);
<span class="boring">Ok(())
</span><span class="boring">}).unwrap();</span></code></pre>
</details>
<h3 id="frompy-has-been-removed"><a class="header" href="#frompy-has-been-removed"><code>FromPy</code> has been removed</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>To simplify the PyO3 conversion traits, the <code>FromPy</code> trait has been removed. Previously there were
two ways to define the to-Python conversion for a type:
<code>FromPy&lt;T&gt; for PyObject</code> and <code>IntoPy&lt;PyObject&gt; for T</code>.</p>
<p>Now there is only one way to define the conversion, <code>IntoPy</code>, so downstream crates may need to
adjust accordingly.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>struct MyPyObjectWrapper(PyObject);

impl FromPy&lt;MyPyObjectWrapper&gt; for PyObject {
    fn from_py(other: MyPyObjectWrapper, _py: Python&lt;'_&gt;) -&gt; Self {
        other.0
    }
}</code></pre>
<p>After</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[allow(dead_code)]
</span>struct MyPyObjectWrapper(PyObject);

impl IntoPy&lt;PyObject&gt; for MyPyObjectWrapper {
    fn into_py(self, _py: Python&lt;'_&gt;) -&gt; PyObject {
        self.0
    }
}</code></pre>
<p>Similarly, code which was using the <code>FromPy</code> trait can be trivially rewritten to use <code>IntoPy</code>.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span>let obj = PyObject::from_py(1.234, py);
<span class="boring">})</span></code></pre>
<p>After:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">Python::with_gil(|py| {
</span>let obj: PyObject = 1.234.into_py(py);
<span class="boring">})</span></code></pre>
</details>
<h3 id="pyobject-is-now-a-type-alias-of-pypyany"><a class="header" href="#pyobject-is-now-a-type-alias-of-pypyany"><code>PyObject</code> is now a type alias of <code>Py&lt;PyAny&gt;</code></a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>This should change very little from a usage perspective. If you implemented traits for both
<code>PyObject</code> and <code>Py&lt;T&gt;</code>, you may find you can just remove the <code>PyObject</code> implementation.</p>
</details>
<h3 id="aspyref-has-been-removed"><a class="header" href="#aspyref-has-been-removed"><code>AsPyRef</code> has been removed</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>As <code>PyObject</code> has been changed to be just a type alias, the only remaining implementor of <code>AsPyRef</code>
was <code>Py&lt;T&gt;</code>. This removed the need for a trait, so the <code>AsPyRef::as_ref</code> method has been moved to
<code>Py::as_ref</code>.</p>
<p>This should require no code changes except removing <code>use pyo3::AsPyRef</code> for code which did not use
<code>pyo3::prelude::*</code>.</p>
<p>Before:</p>
<pre><code class="language-rust ignore">use pyo3::{AsPyRef, Py, types::PyList};
<span class="boring">pyo3::Python::with_gil(|py| {
</span>let list_py: Py&lt;PyList&gt; = PyList::empty(py).into();
let list_ref: &amp;PyList = list_py.as_ref(py);
<span class="boring">})</span></code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">use pyo3::{Py, types::PyList};
<span class="boring">pyo3::Python::with_gil(|py| {
</span>let list_py: Py&lt;PyList&gt; = PyList::empty(py).into();
let list_ref: &amp;PyList = list_py.as_ref(py);
<span class="boring">})</span></code></pre>
</details>
<h2 id="from-010-to-011"><a class="header" href="#from-010-to-011">from 0.10.* to 0.11</a></h2>
<h3 id="stable-rust"><a class="header" href="#stable-rust">Stable Rust</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>PyO3 now supports the stable Rust toolchain. The minimum required version is 1.39.0.</p>
</details>
<h3 id="pyclass-structs-must-now-be-send-or-unsendable"><a class="header" href="#pyclass-structs-must-now-be-send-or-unsendable"><code>#[pyclass]</code> structs must now be <code>Send</code> or <code>unsendable</code></a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>Because <code>#[pyclass]</code> structs can be sent between threads by the Python interpreter, they must implement
<code>Send</code> or declared as <code>unsendable</code> (by <code>#[pyclass(unsendable)]</code>).
Note that <code>unsendable</code> is added in PyO3 <code>0.11.1</code> and <code>Send</code> is always required in PyO3 <code>0.11.0</code>.</p>
<p>This may "break" some code which previously was accepted, even though it could be unsound.
There can be two fixes:</p>
<ol>
<li>
<p>If you think that your <code>#[pyclass]</code> actually must be <code>Send</code>able, then let's implement <code>Send</code>.
A common, safer way is using thread-safe types. E.g., <code>Arc</code> instead of <code>Rc</code>, <code>Mutex</code> instead of
<code>RefCell</code>, and <code>Box&lt;dyn Send + T&gt;</code> instead of <code>Box&lt;dyn T&gt;</code>.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail">use pyo3::prelude::*;
use std::rc::Rc;
use std::cell::RefCell;

#[pyclass]
struct NotThreadSafe {
    shared_bools: Rc&lt;RefCell&lt;Vec&lt;bool&gt;&gt;&gt;,
    closure: Box&lt;dyn Fn()&gt;,
}</code></pre>
<p>After:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;
use std::sync::{Arc, Mutex};

#[pyclass]
struct ThreadSafe {
    shared_bools: Arc&lt;Mutex&lt;Vec&lt;bool&gt;&gt;&gt;,
    closure: Box&lt;dyn Fn() + Send&gt;,
}</code></pre>
<p>In situations where you cannot change your <code>#[pyclass]</code> to automatically implement <code>Send</code>
(e.g., when it contains a raw pointer), you can use <code>unsafe impl Send</code>.
In such cases, care should be taken to ensure the struct is actually thread safe.
See <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">the Rustonomicon</a> for more.</p>
</li>
<li>
<p>If you think that your <code>#[pyclass]</code> should not be accessed by another thread, you can use
<code>unsendable</code> flag. A class marked with <code>unsendable</code> panics when accessed by another thread,
making it thread-safe to expose an unsendable object to the Python interpreter.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail">use pyo3::prelude::*;

#[pyclass]
struct Unsendable {
    pointers: Vec&lt;*mut std::os::raw::c_char&gt;,
}</code></pre>
<p>After:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

#[pyclass(unsendable)]
struct Unsendable {
    pointers: Vec&lt;*mut std::os::raw::c_char&gt;,
}</code></pre>
</li>
</ol>
</details>
<h3 id="all-pyobject-and-pyt-methods-now-take-python-as-an-argument"><a class="header" href="#all-pyobject-and-pyt-methods-now-take-python-as-an-argument">All <code>PyObject</code> and <code>Py&lt;T&gt;</code> methods now take <code>Python</code> as an argument</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>Previously, a few methods such as <code>Object::get_refcnt</code> did not take <code>Python</code> as an argument (to
ensure that the Python GIL was held by the current thread). Technically, this was not sound.
To migrate, just pass a <code>py</code> argument to any calls to these methods.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail"><span class="boring">pyo3::Python::with_gil(|py| {
</span>py.None().get_refcnt();
<span class="boring">})</span></code></pre>
<p>After:</p>
<pre><code class="language-rust"><span class="boring">pyo3::Python::with_gil(|py| {
</span>py.None().get_refcnt(py);
<span class="boring">})</span></code></pre>
</details>
<h2 id="from-09-to-010"><a class="header" href="#from-09-to-010">from 0.9.* to 0.10</a></h2>
<h3 id="objectprotocol-is-removed"><a class="header" href="#objectprotocol-is-removed"><code>ObjectProtocol</code> is removed</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>All methods are moved to <a href="https://docs.rs/pyo3/0.21.2/pyo3/types/struct.PyAny.html"><code>PyAny</code></a>.
And since now all native types (e.g., <code>PyList</code>) implements <code>Deref&lt;Target=PyAny&gt;</code>,
all you need to do is remove <code>ObjectProtocol</code> from your code.
Or if you use <code>ObjectProtocol</code> by <code>use pyo3::prelude::*</code>, you have to do nothing.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail ignore">use pyo3::ObjectProtocol;

<span class="boring">pyo3::Python::with_gil(|py| {
</span>let obj = py.eval("lambda: 'Hi :)'", None, None).unwrap();
let hi: &amp;pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();
assert_eq!(hi.len().unwrap(), 5);
<span class="boring">})</span></code></pre>
<p>After:</p>
<pre><code class="language-rust ignore"><span class="boring">pyo3::Python::with_gil(|py| {
</span>let obj = py.eval("lambda: 'Hi :)'", None, None).unwrap();
let hi: &amp;pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();
assert_eq!(hi.len().unwrap(), 5);
<span class="boring">})</span></code></pre>
</details>
<h3 id="no-featurespecialization-in-user-code"><a class="header" href="#no-featurespecialization-in-user-code">No <code>#![feature(specialization)]</code> in user code</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>While PyO3 itself still requires specialization and nightly Rust,
now you don't have to use <code>#![feature(specialization)]</code> in your crate.</p>
</details>
<h2 id="from-08-to-09"><a class="header" href="#from-08-to-09">from 0.8.* to 0.9</a></h2>
<h3 id="new-interface"><a class="header" href="#new-interface"><code>#[new]</code> interface</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p><a href="https://docs.rs/pyo3/0.8.5/pyo3/type_object/struct.PyRawObject.html"><code>PyRawObject</code></a>
is now removed and our syntax for constructors has changed.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail">#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
    #[new]
    fn new(obj: &amp;PyRawObject) {
        obj.init(MyClass {})
    }
}</code></pre>
<p>After:</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
    #[new]
    fn new() -&gt; Self {
        MyClass {}
    }
}</code></pre>
<p>Basically you can return <code>Self</code> or <code>Result&lt;Self&gt;</code> directly.
For more, see <a href="class.html#constructor">the constructor section</a> of this guide.</p>
</details>
<h3 id="pycell"><a class="header" href="#pycell">PyCell</a></h3>
<details>
<summary><small>Click to expand</small></summary>
<p>PyO3 0.9 introduces <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyCell.html"><code>PyCell</code></a>, which is a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>-like object wrapper
for ensuring Rust's rules regarding aliasing of references are upheld.
For more detail, see the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references">Rust Book's section on Rust's rules of references</a></p>
<p>For <code>#[pymethods]</code> or <code>#[pyfunction]</code>s, your existing code should continue to work without any change.
Python exceptions will automatically be raised when your functions are used in a way which breaks Rust's
rules of references.</p>
<p>Here is an example.</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct Names {
    names: Vec&lt;String&gt;,
}

#[pymethods]
impl Names {
    #[new]
    fn new() -&gt; Self {
        Names { names: vec![] }
    }
    fn merge(&amp;mut self, other: &amp;mut Names) {
        self.names.append(&amp;mut other.names)
    }
}
<span class="boring">Python::with_gil(|py| {
</span><span class="boring">    let names = Py::new(py, Names::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, names, r"
</span><span class="boring">    try:
</span><span class="boring">       names.merge(names)
</span><span class="boring">       assert False, 'Unreachable'
</span><span class="boring">    except RuntimeError as e:
</span><span class="boring">       assert str(e) == 'Already borrowed'
</span><span class="boring">    ");
</span><span class="boring">})</span></code></pre>
<p><code>Names</code> has a <code>merge</code> method, which takes <code>&amp;mut self</code> and another argument of type <code>&amp;mut Self</code>.
Given this <code>#[pyclass]</code>, calling <code>names.merge(names)</code> in Python raises
a <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyBorrowMutError.html"><code>PyBorrowMutError</code></a> exception, since it requires two mutable borrows of <code>names</code>.</p>
<p>However, for <code>#[pyproto]</code> and some functions, you need to manually fix the code.</p>
<h4 id="object-creation"><a class="header" href="#object-creation">Object creation</a></h4>
<p>In 0.8 object creation was done with <code>PyRef::new</code> and <code>PyRefMut::new</code>.
In 0.9 these have both been removed.
To upgrade code, please use
<a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyCell.html#method.new"><code>PyCell::new</code></a> instead.
If you need <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyRef.html"><code>PyRefMut</code></a>, just call <code>.borrow()</code> or <code>.borrow_mut()</code>
on the newly-created <code>PyCell</code>.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span><span class="boring">Python::with_gil(|py| {
</span>let obj_ref = PyRef::new(py, MyClass {}).unwrap();
<span class="boring">})</span></code></pre>
<p>After:</p>
<pre><code class="language-rust ignore"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span><span class="boring">Python::with_gil(|py| {
</span>let obj = PyCell::new(py, MyClass {}).unwrap();
let obj_ref = obj.borrow();
<span class="boring">})</span></code></pre>
<h4 id="object-extraction"><a class="header" href="#object-extraction">Object extraction</a></h4>
<p>For <code>PyClass</code> types <code>T</code>, <code>&amp;T</code> and <code>&amp;mut T</code> no longer have <a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementations.
Instead you should extract <code>PyRef&lt;T&gt;</code> or <code>PyRefMut&lt;T&gt;</code>, respectively.
If <code>T</code> implements <code>Clone</code>, you can extract <code>T</code> itself.
In addition, you can also extract <code>&amp;PyCell&lt;T&gt;</code>, though you rarely need it.</p>
<p>Before:</p>
<pre><code class="language-compile_fail">let obj: &amp;PyAny = create_obj();
let obj_ref: &amp;MyClass = obj.extract().unwrap();
let obj_ref_mut: &amp;mut MyClass = obj.extract().unwrap();
</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::IntoPyDict;
</span><span class="boring">#[pyclass] #[derive(Clone)] struct MyClass {}
</span><span class="boring">#[pymethods] impl MyClass { #[new]fn new() -&gt; Self { MyClass {} }}
</span><span class="boring">Python::with_gil(|py| {
</span><span class="boring">let typeobj = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">let d = [("c", typeobj)].into_py_dict(py);
</span><span class="boring">let create_obj = || py.eval("c()", None, Some(d)).unwrap();
</span>let obj: &amp;PyAny = create_obj();
let obj_cell: &amp;PyCell&lt;MyClass&gt; = obj.extract().unwrap();
let obj_cloned: MyClass = obj.extract().unwrap(); // extracted by cloning the object
{
    let obj_ref: PyRef&lt;'_, MyClass&gt; = obj.extract().unwrap();
    // we need to drop obj_ref before we can extract a PyRefMut due to Rust's rules of references
}
let obj_ref_mut: PyRefMut&lt;'_, MyClass&gt; = obj.extract().unwrap();
<span class="boring">})</span></code></pre>
<h4 id="pyproto"><a class="header" href="#pyproto"><code>#[pyproto]</code></a></h4>
<p>Most of the arguments to methods in <code>#[pyproto]</code> impls require a
<a href="https://docs.rs/pyo3/0.21.2/pyo3/conversion/trait.FromPyObject.html"><code>FromPyObject</code></a> implementation.
So if your protocol methods take <code>&amp;T</code> or <code>&amp;mut T</code> (where <code>T: PyClass</code>),
please use <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyRef.html"><code>PyRef</code></a> or <a href="https://docs.rs/pyo3/0.21.2/pyo3/pycell/struct.PyRef.html"><code>PyRefMut</code></a> instead.</p>
<p>Before:</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: &amp;Self) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}</code></pre>
<p>After:</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::class::PySequenceProtocol;
</span>#[pyclass]
struct ByteSequence {
    elements: Vec&lt;u8&gt;,
}
#[pyproto]
impl PySequenceProtocol for ByteSequence {
    fn __concat__(&amp;self, other: PyRef&lt;'p, Self&gt;) -&gt; PyResult&lt;Self&gt; {
        let mut elements = self.elements.clone();
        elements.extend_from_slice(&amp;other.elements);
        Ok(Self { elements })
    }
}</code></pre>
</details>
<style>
    /* render details immediately below h3 headers */
    h3:has(+ details) {
        margin-bottom: 0;
    }

    /* make summary text hint that it's clickable and increase the
       size of the clickable area by padding downwards */
    details > summary {
        cursor: pointer;
        padding-bottom: 0.5em;
    }

    /* reduce margin from paragraph directly below the clickable space
       to avoid large gap */
    details > summary + p {
        margin-block-start: 0.5em;
    }

    /* pack headings that aren't expanded slightly closer together */
    h3 + details:not([open]) + h3 {
        margin-top: 1.5em;
    }
</style>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-in-python-a-rust-function-with-trait-bounds"><a class="header" href="#using-in-python-a-rust-function-with-trait-bounds">Using in Python a Rust function with trait bounds</a></h1>
<p>PyO3 allows for easy conversion from Rust to Python for certain functions and classes (see the <a href="conversions/tables.html">conversion table</a>.
However, it is not always straightforward to convert Rust code that requires a given trait implementation as an argument.</p>
<p>This tutorial explains how to convert a Rust function that takes a trait as argument for use in Python with classes implementing the same methods as the trait.</p>
<p>Why is this useful?</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>Make your Rust code available to Python users</li>
<li>Code complex algorithms in Rust with the help of the borrow checker</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>Not as fast as native Rust (type conversion has to be performed and one part of the code runs in Python)</li>
<li>You need to adapt your code to expose it</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's work with the following basic example of an implementation of a optimization solver operating on a given model.</p>
<p>Let's say we have a function <code>solve</code> that operates on a model and mutates its state.
The argument of the function can be any model that implements the <code>Model</code> trait :</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>pub trait Model {
    fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
    fn compute(&amp;mut self);
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
}

pub fn solve&lt;T: Model&gt;(model: &amp;mut T) {
    println!("Magic solver that mutates the model into a resolved state");
}</code></pre>
<p>Let's assume we have the following constraints:</p>
<ul>
<li>We cannot change that code as it runs on many Rust models.</li>
<li>We also have many Python models that cannot be solved as this solver is not available in that language.
Rewriting it in Python would be cumbersome and error-prone, as everything is already available in Rust.</li>
</ul>
<p>How could we expose this solver to Python thanks to PyO3 ?</p>
<h2 id="implementation-of-the-trait-bounds-for-the-python-class"><a class="header" href="#implementation-of-the-trait-bounds-for-the-python-class">Implementation of the trait bounds for the Python class</a></h2>
<p>If a Python class implements the same three methods as the <code>Model</code> trait, it seems logical it could be adapted to use the solver.
However, it is not possible to pass a <code>PyObject</code> to it as it does not implement the Rust trait (even if the Python model has the required methods).</p>
<p>In order to implement the trait, we must write a wrapper around the calls in Rust to the Python model.
The method signatures must be the same as the trait, keeping in mind that the Rust trait cannot be changed for the purpose of making the code available in Python.</p>
<p>The Python model we want to expose is the following one, which already contains all the required methods:</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 - 3 for elt in self.inputs]
    def get_results(self):
        return self.results
</code></pre>
<p>The following wrapper will call the Python model from Rust, using a struct to hold the model as a <code>PyAny</code> object:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;
use pyo3::types::PyList;

<span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span>
struct UserModel {
    model: Py&lt;PyAny&gt;,
}

impl Model for UserModel {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
        println!("Rust calling Python to set the variables");
        Python::with_gil(|py| {
            self.model
                .bind(py)
                .call_method("set_variables", (PyList::new_bound(py, var),), None)
                .unwrap();
        })
    }

    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!("Rust calling Python to get the results");
        Python::with_gil(|py| {
            self.model
                .bind(py)
                .call_method("get_results", (), None)
                .unwrap()
                .extract()
                .unwrap()
        })
    }

    fn compute(&amp;mut self) {
        println!("Rust calling Python to perform the computation");
        Python::with_gil(|py| {
            self.model
                .bind(py)
                .call_method("compute", (), None)
                .unwrap();
        })
    }
}</code></pre>
<p>Now that this bit is implemented, let's expose the model wrapper to Python.
Let's add the PyO3 annotations and add a constructor:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">use pyo3::prelude::*;
</span>
#[pyclass]
struct UserModel {
    model: Py&lt;PyAny&gt;,
}

#[pymodule]
fn trait_exposure(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;UserModel&gt;()?;
    Ok(())
}

#[pymethods]
impl UserModel {
    #[new]
    pub fn new(model: Py&lt;PyAny&gt;) -&gt; Self {
        UserModel { model }
    }
}</code></pre>
<p>Now we add the PyO3 annotations to the trait implementation:</p>
<pre><code class="language-rust ignore">#[pymethods]
impl Model for UserModel {
    // the previous trait implementation
}</code></pre>
<p>However, the previous code will not compile. The compilation error is the following one:
<code>error: #[pymethods] cannot be used on trait impl blocks</code></p>
<p>That's a bummer!
However, we can write a second wrapper around these functions to call them directly.
This wrapper will also perform the type conversions between Python and Rust.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Model for UserModel {
</span><span class="boring"> fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">     println!("Rust calling Python to set the variables");
</span><span class="boring">     Python::with_gil(|py| {
</span><span class="boring">         self.model.bind(py)
</span><span class="boring">             .call_method("set_variables", (PyList::new_bound(py, var),), None)
</span><span class="boring">             .unwrap();
</span><span class="boring">     })
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
</span><span class="boring">     println!("Rust calling Python to get the results");
</span><span class="boring">     Python::with_gil(|py| {
</span><span class="boring">         self.model
</span><span class="boring">             .bind(py)
</span><span class="boring">             .call_method("get_results", (), None)
</span><span class="boring">             .unwrap()
</span><span class="boring">             .extract()
</span><span class="boring">             .unwrap()
</span><span class="boring">     })
</span><span class="boring"> }
</span><span class="boring">
</span><span class="boring"> fn compute(&amp;mut self) {
</span><span class="boring">     println!("Rust calling Python to perform the computation");
</span><span class="boring">     Python::with_gil(|py| {
</span><span class="boring">         self.model
</span><span class="boring">             .bind(py)
</span><span class="boring">             .call_method("compute", (), None)
</span><span class="boring">             .unwrap();
</span><span class="boring">     })
</span><span class="boring">
</span><span class="boring"> }
</span><span class="boring">}
</span>
#[pymethods]
impl UserModel {
    pub fn set_variables(&amp;mut self, var: Vec&lt;f64&gt;) {
        println!("Set variables from Python calling Rust");
        Model::set_variables(self, &amp;var)
    }

    pub fn get_results(&amp;mut self) -&gt; Vec&lt;f64&gt; {
        println!("Get results from Python calling Rust");
        Model::get_results(self)
    }

    pub fn compute(&amp;mut self) {
        println!("Compute from Python calling Rust");
        Model::compute(self)
    }
}</code></pre>
<p>This wrapper handles the type conversion between the PyO3 requirements and the trait.
In order to meet PyO3 requirements, this wrapper must:</p>
<ul>
<li>return an object of type <code>PyResult</code></li>
<li>use only values, not references in the method signatures</li>
</ul>
<p>Let's run the file python file:</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 - 3 for elt in self.inputs]
    def get_results(self):
        return self.results

if __name__=="__main__":
  import trait_exposure

  myModel = Model()
  my_rust_model = trait_exposure.UserModel(myModel)
  my_rust_model.set_variables([2.0])
  print("Print value from Python: ", myModel.inputs)
  my_rust_model.compute()
  print("Print value from Python through Rust: ", my_rust_model.get_results())
  print("Print value directly from Python: ", myModel.get_results())
</code></pre>
<p>This outputs:</p>
<pre><code class="language-block">Set variables from Python calling Rust
Set variables from Rust calling Python
Print value from Python:  [2.0]
Compute from Python calling Rust
Compute from Rust calling Python
Get results from Python calling Rust
Get results from Rust calling Python
Print value from Python through Rust:  [1.0]
Print value directly from Python:  [1.0]
</code></pre>
<p>We have now successfully exposed a Rust model that implements the <code>Model</code> trait to Python!</p>
<p>We will now expose the <code>solve</code> function, but before, let's talk about types errors.</p>
<h2 id="type-errors-in-python"><a class="header" href="#type-errors-in-python">Type errors in Python</a></h2>
<p>What happens if you have type errors when using Python and how can you improve the error messages?</p>
<h3 id="wrong-types-in-python-function-arguments"><a class="header" href="#wrong-types-in-python-function-arguments">Wrong types in Python function arguments</a></h3>
<p>Let's assume in the first case that you will use in your Python file <code>my_rust_model.set_variables(2.0)</code> instead of <code>my_rust_model.set_variables([2.0])</code>.</p>
<p>The Rust signature expects a vector, which corresponds to a list in Python.
What happens if instead of a vector, we pass a single value ?</p>
<p>At the execution of Python, we get :</p>
<pre><code class="language-block">File "main.py", line 15, in &lt;module&gt;
   my_rust_model.set_variables(2)
TypeError
</code></pre>
<p>It is a type error and Python points to it, so it's easy to identify and solve.</p>
<h3 id="wrong-types-in-python-method-signatures"><a class="header" href="#wrong-types-in-python-method-signatures">Wrong types in Python method signatures</a></h3>
<p>Let's assume now that the return type of one of the methods of our Model class is wrong, for example the <code>get_results</code> method that is expected to return a <code>Vec&lt;f64&gt;</code> in Rust, a list in Python.</p>
<pre><code class="language-python">class Model:
    def set_variables(self, inputs):
        self.inputs = inputs
    def compute(self):
        self.results = [elt**2 -3 for elt in self.inputs]
    def get_results(self):
        return self.results[0]
        #return self.results &lt;-- this is the expected output
</code></pre>
<p>This call results in the following panic:</p>
<pre><code class="language-block">pyo3_runtime.PanicException: called `Result::unwrap()` on an `Err` value: PyErr { type: Py(0x10dcf79f0, PhantomData) }
</code></pre>
<p>This error code is not helpful for a Python user that does not know anything about Rust, or someone that does not know PyO3 was used to interface the Rust code.</p>
<p>However, as we are responsible for making the Rust code available to Python, we can do something about it.</p>
<p>The issue is that we called <code>unwrap</code> anywhere we could, and therefore any panic from PyO3 will be directly forwarded to the end user.</p>
<p>Let's modify the code performing the type conversion to give a helpful error message to the Python user:</p>
<p>We used in our <code>get_results</code> method the following call that performs the type conversion:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span>
impl Model for UserModel {
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!("Rust calling Python to get the results");
        Python::with_gil(|py| {
            self.model
                .bind(py)
                .call_method("get_results", (), None)
                .unwrap()
                .extract()
                .unwrap()
        })
    }
<span class="boring">    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">        println!("Rust calling Python to set the variables");
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            self.model.bind(py)
</span><span class="boring">                .call_method("set_variables", (PyList::new_bound(py, var),), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn compute(&amp;mut self) {
</span><span class="boring">        println!("Rust calling Python to perform the computation");
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            self.model
</span><span class="boring">                .bind(py)
</span><span class="boring">                .call_method("compute", (), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span>}</code></pre>
<p>Let's break it down in order to perform better error handling:</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyList;
</span><span class="boring">
</span><span class="boring">pub trait Model {
</span><span class="boring">  fn set_variables(&amp;mut self, inputs: &amp;Vec&lt;f64&gt;);
</span><span class="boring">  fn compute(&amp;mut self);
</span><span class="boring">  fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct UserModel {
</span><span class="boring">    model: Py&lt;PyAny&gt;,
</span><span class="boring">}
</span>
impl Model for UserModel {
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!("Get results from Rust calling Python");
        Python::with_gil(|py| {
            let py_result: Bound&lt;'_, PyAny&gt; = self
                .model
                .bind(py)
                .call_method("get_results", (), None)
                .unwrap();

            if py_result.get_type().name().unwrap() != "list" {
                panic!(
                    "Expected a list for the get_results() method signature, got {}",
                    py_result.get_type().name().unwrap()
                );
            }
            py_result.extract()
        })
        .unwrap()
    }
<span class="boring">    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
</span><span class="boring">        println!("Rust calling Python to set the variables");
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            let py_model = self.model.bind(py)
</span><span class="boring">                .call_method("set_variables", (PyList::new_bound(py, var),), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn compute(&amp;mut self) {
</span><span class="boring">        println!("Rust calling Python to perform the computation");
</span><span class="boring">        Python::with_gil(|py| {
</span><span class="boring">            self.model
</span><span class="boring">                .bind(py)
</span><span class="boring">                .call_method("compute", (), None)
</span><span class="boring">                .unwrap();
</span><span class="boring">        })
</span><span class="boring">    }
</span>}</code></pre>
<p>By doing so, you catch the result of the Python computation and check its type in order to be able to deliver a better error message before performing the unwrapping.</p>
<p>Of course, it does not cover all the possible wrong outputs:
the user could return a list of strings instead of a list of floats.
In this case, a runtime panic would still occur due to PyO3, but with an error message much more difficult to decipher for non-rust user.</p>
<p>It is up to the developer exposing the rust code to decide how much effort to invest into Python type error handling and improved error messages.</p>
<h2 id="the-final-code"><a class="header" href="#the-final-code">The final code</a></h2>
<p>Now let's expose the <code>solve()</code> function to make it available from Python.</p>
<p>It is not possible to directly expose the <code>solve</code> function to Python, as the type conversion cannot be performed.
It requires an object implementing the <code>Model</code> trait as input.</p>
<p>However, the <code>UserModel</code> already implements this trait.
Because of this, we can write a function wrapper that takes the <code>UserModel</code>--which has already been exposed to Python--as an argument in order to call the core function <code>solve</code>.</p>
<p>It is also required to make the struct public.</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;
use pyo3::types::PyList;

pub trait Model {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;);
    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt;;
    fn compute(&amp;mut self);
}

pub fn solve&lt;T: Model&gt;(model: &amp;mut T) {
    println!("Magic solver that mutates the model into a resolved state");
}

#[pyfunction]
#[pyo3(name = "solve")]
pub fn solve_wrapper(model: &amp;mut UserModel) {
    solve(model);
}

#[pyclass]
pub struct UserModel {
    model: Py&lt;PyAny&gt;,
}

#[pymodule]
fn trait_exposure(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_class::&lt;UserModel&gt;()?;
    m.add_function(wrap_pyfunction!(solve_wrapper, m)?)?;
    Ok(())
}

#[pymethods]
impl UserModel {
    #[new]
    pub fn new(model: Py&lt;PyAny&gt;) -&gt; Self {
        UserModel { model }
    }

    pub fn set_variables(&amp;mut self, var: Vec&lt;f64&gt;) {
        println!("Set variables from Python calling Rust");
        Model::set_variables(self, &amp;var)
    }

    pub fn get_results(&amp;mut self) -&gt; Vec&lt;f64&gt; {
        println!("Get results from Python calling Rust");
        Model::get_results(self)
    }

    pub fn compute(&amp;mut self) {
        Model::compute(self)
    }
}

impl Model for UserModel {
    fn set_variables(&amp;mut self, var: &amp;Vec&lt;f64&gt;) {
        println!("Rust calling Python to set the variables");
        Python::with_gil(|py| {
            self.model
                .bind(py)
                .call_method("set_variables", (PyList::new_bound(py, var),), None)
                .unwrap();
        })
    }

    fn get_results(&amp;self) -&gt; Vec&lt;f64&gt; {
        println!("Get results from Rust calling Python");
        Python::with_gil(|py| {
            let py_result: Bound&lt;'_, PyAny&gt; = self
                .model
                .bind(py)
                .call_method("get_results", (), None)
                .unwrap();

            if py_result.get_type().name().unwrap() != "list" {
                panic!(
                    "Expected a list for the get_results() method signature, got {}",
                    py_result.get_type().name().unwrap()
                );
            }
            py_result.extract()
        })
        .unwrap()
    }

    fn compute(&amp;mut self) {
        println!("Rust calling Python to perform the computation");
        Python::with_gil(|py| {
            self.model
                .bind(py)
                .call_method("compute", (), None)
                .unwrap();
        })
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typing-and-ide-hints-for-your-python-package"><a class="header" href="#typing-and-ide-hints-for-your-python-package">Typing and IDE hints for your Python package</a></h1>
<p>PyO3 provides an easy to use interface to code native Python libraries in Rust. The accompanying Maturin allows you to build and publish them as a package. Yet, for a better user experience, Python libraries should provide typing hints and documentation for all public entities, so that IDEs can show them during development and type analyzing tools such as <code>mypy</code> can use them to properly verify the code.</p>
<p>Currently the best solution for the problem is to manually maintain <code>*.pyi</code> files and ship them along with the package.</p>
<p>There is a sketch of a roadmap towards completing <a href="./features.html#experimental-inspect">the <code>experimental-inspect</code> feature</a> which may eventually lead to automatic type annotations generated by PyO3. This needs more testing and implementation, please see <a href="https://github.com/PyO3/pyo3/issues/2454">issue #2454</a>.</p>
<h2 id="introduction-to-pyi-files"><a class="header" href="#introduction-to-pyi-files">Introduction to <code>pyi</code> files</a></h2>
<p><code>pyi</code> files (an abbreviation for <code>Python Interface</code>) are called "stub files" in most of the documentation related to them. A very good definition of what it is can be found in <a href="https://github.com/python/mypy/wiki/Creating-Stubs-For-Python-Modules">old MyPy documentation</a>:</p>
<blockquote>
<p>A stubs file only contains a description of the public interface of the module without any implementations.</p>
</blockquote>
<p>There is also <a href="https://typing.readthedocs.io/en/latest/source/stubs.html">extensive documentation on type stubs on the official Python typing documentation</a>.</p>
<p>Most Python developers probably already encountered them when trying to use their IDE's "Go to Definition" function on any builtin type. For example, the definitions of a few standard exceptions look like this:</p>
<pre><code class="language-python">class BaseException(object):
    args: Tuple[Any, ...]
    __cause__: BaseException | None
    __context__: BaseException | None
    __suppress_context__: bool
    __traceback__: TracebackType | None
    def __init__(self, *args: object) -&gt; None: ...
    def __str__(self) -&gt; str: ...
    def __repr__(self) -&gt; str: ...
    def with_traceback(self: _TBE, tb: TracebackType | None) -&gt; _TBE: ...

class SystemExit(BaseException):
    code: int

class Exception(BaseException): ...

class StopIteration(Exception):
    value: Any
</code></pre>
<p>As we can see, those are not full definitions containing implementation, but just a description of the interface. It is usually all that the user of the library needs.</p>
<h3 id="what-do-the-peps-say"><a class="header" href="#what-do-the-peps-say">What do the PEPs say?</a></h3>
<p>At the time of writing this documentation, the <code>pyi</code> files are referenced in three PEPs.</p>
<p><a href="https://www.python.org/dev/peps/pep-0008/#function-annotations">PEP8 - Style Guide for Python Code - #Function Annotations</a> (last point) recommends all third party library creators to provide stub files as the source of knowledge about the package for type checker tools.</p>
<blockquote>
<p>(...) it is expected that users of third party library packages may want to run type checkers over those packages. For this purpose <a href="https://www.python.org/dev/peps/pep-0484">PEP 484</a> recommends the use of stub files: .pyi files that are read by the type checker in preference of the corresponding .py files. (...)</p>
</blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0484/#stub-files">PEP484 - Type Hints - #Stub Files</a> defines stub files as follows.</p>
<blockquote>
<p>Stub files are files containing type hints that are only for use by the type checker, not at runtime.</p>
</blockquote>
<p>It contains a specification for them (highly recommended reading, since it contains at least one thing that is not used in normal Python code) and also some general information about where to store the stub files.</p>
<p><a href="https://www.python.org/dev/peps/pep-0561/">PEP561 - Distributing and Packaging Type Information</a> describes in detail how to build packages that will enable type checking. In particular it contains information about how the stub files must be distributed in order for type checkers to use them.</p>
<h2 id="how-to-do-it"><a class="header" href="#how-to-do-it">How to do it?</a></h2>
<p><a href="https://www.python.org/dev/peps/pep-0561/">PEP561</a> recognizes three ways of distributing type information:</p>
<ul>
<li><code>inline</code> - the typing is placed directly in source (<code>py</code>) files;</li>
<li><code>separate package with stub files</code> - the typing is placed in <code>pyi</code> files distributed in their own, separate package;</li>
<li><code>in-package stub files</code> - the typing is placed in <code>pyi</code> files distributed in the same package as source files.</li>
</ul>
<p>The first way is tricky with PyO3 since we do not have <code>py</code> files. When it has been investigated and necessary changes are implemented, this document will be updated.</p>
<p>The second way is easy to do, and the whole work can be fully separated from the main library code. The example repo for the package with stub files can be found in <a href="https://www.python.org/dev/peps/pep-0561/#references">PEP561 references section</a>: <a href="https://github.com/ethanhs/stub-package">Stub package repository</a></p>
<p>The third way is described below.</p>
<h3 id="including-pyi-files-in-your-pyo3maturin-build-package"><a class="header" href="#including-pyi-files-in-your-pyo3maturin-build-package">Including <code>pyi</code> files in your PyO3/Maturin build package</a></h3>
<p>When source files are in the same package as stub files, they should be placed next to each other. We need a way to do that with Maturin. Also, in order to mark our package as typing-enabled we need to add an empty file named <code>py.typed</code> to the package.</p>
<h4 id="if-you-do-not-have-other-python-files"><a class="header" href="#if-you-do-not-have-other-python-files">If you do not have other Python files</a></h4>
<p>If you do not need to add any other Python files apart from <code>pyi</code> to the package, Maturin provides a way to do most of the work for you. As documented in the <a href="https://github.com/PyO3/maturin/#mixed-rustpython-projects">Maturin Guide</a>, the only thing you need to do is to create a stub file for your module named <code>&lt;module_name&gt;.pyi</code> in your project root and Maturin will do the rest.</p>
<pre><code class="language-text">my-rust-project/
├── Cargo.toml
├── my_project.pyi  # &lt;&lt;&lt; add type stubs for Rust functions in the my_project module here
├── pyproject.toml
└── src
    └── lib.rs
</code></pre>
<p>For an example <code>pyi</code> file see the <a href="python-typing-hints.html#my_projectpyi-content"><code>my_project.pyi</code> content</a> section.</p>
<h4 id="if-you-need-other-python-files"><a class="header" href="#if-you-need-other-python-files">If you need other Python files</a></h4>
<p>If you need to add other Python files apart from <code>pyi</code> to the package, you can do it also, but that requires some more work. Maturin provides an easy way to add files to a package (<a href="https://github.com/PyO3/maturin/blob/0dee40510083c03607834c821eea76964140a126/Readme.md#mixed-rustpython-projects">documentation</a>). You just need to create a folder with the name of your module next to the <code>Cargo.toml</code> file (for customization see documentation linked above).</p>
<p>The folder structure would be:</p>
<pre><code class="language-text">my-project
├── Cargo.toml
├── my_project
│   ├── __init__.py
│   ├── my_project.pyi
│   ├── other_python_file.py
│   └── py.typed
├── pyproject.toml
├── Readme.md
└── src
    └── lib.rs
</code></pre>
<p>Let's go a little bit more into detail regarding the files inside the package folder.</p>
<h5 id="__init__py-content"><a class="header" href="#__init__py-content"><code>__init__.py</code> content</a></h5>
<p>As we now specify our own package content, we have to provide the <code>__init__.py</code> file, so the folder is treated as a package and we can import things from it. We can always use the same content that Maturin creates for us if we do not specify a Python source folder. For PyO3 bindings it would be:</p>
<pre><code class="language-python">from .my_project import *
</code></pre>
<p>That way everything that is exposed by our native module can be imported directly from the package.</p>
<h5 id="pytyped-requirement"><a class="header" href="#pytyped-requirement"><code>py.typed</code> requirement</a></h5>
<p>As stated in <a href="https://www.python.org/dev/peps/pep-0561/">PEP561</a>:</p>
<blockquote>
<p>Package maintainers who wish to support type checking of their code MUST add a marker file named py.typed to their package supporting typing. This marker applies recursively: if a top-level package includes it, all its sub-packages MUST support type checking as well.</p>
</blockquote>
<p>If we do not include that file, some IDEs might still use our <code>pyi</code> files to show hints, but the type checkers might not. MyPy will raise an error in this situation:</p>
<pre><code class="language-text">error: Skipping analyzing "my_project": found module but no type hints or library stubs
</code></pre>
<p>The file is just a marker file, so it should be empty.</p>
<h5 id="my_projectpyi-content"><a class="header" href="#my_projectpyi-content"><code>my_project.pyi</code> content</a></h5>
<p>Our module stub file. This document does not aim at describing how to write them, since you can find a lot of documentation on it, starting from the already quoted <a href="https://www.python.org/dev/peps/pep-0484/#stub-files">PEP484</a>.</p>
<p>The example can look like this:</p>
<pre><code class="language-python">class Car:
    """
    A class representing a car.

    :param body_type: the name of body type, e.g. hatchback, sedan
    :param horsepower: power of the engine in horsepower
    """
    def __init__(self, body_type: str, horsepower: int) -&gt; None: ...

    @classmethod
    def from_unique_name(cls, name: str) -&gt; 'Car':
        """
        Creates a Car based on unique name

        :param name: model name of a car to be created
        :return: a Car instance with default data
        """

    def best_color(self) -&gt; str:
        """
        Gets the best color for the car.

        :return: the name of the color our great algorithm thinks is the best for this car
        """
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to this project will be documented in this file. For help with updating to new
PyO3 versions, please see the <a href="https://pyo3.rs/latest/migration.html">migration guide</a>.</p>
<p>The format is based on <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a>
and this project adheres to <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.</p>
<p>To see unreleased changes, please see the <a href="https://pyo3.rs/main/changelog.html">CHANGELOG on the main branch guide</a>.</p>
<!-- towncrier release notes start -->
<h2 id="0212---2024-04-16"><a class="header" href="#0212---2024-04-16"><a href="https://github.com/pyo3/pyo3/compare/v0.21.1...v0.21.2">0.21.2</a> - 2024-04-16</a></h2>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li>Deprecate the <code>PySet::empty()</code> gil-ref constructor. <a href="https://github.com/PyO3/pyo3/pull/4082">#4082</a></li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Fix compile error for <code>async fn</code> in <code>#[pymethods]</code> with a <code>&amp;self</code> receiver and more than one additional argument. <a href="https://github.com/PyO3/pyo3/pull/4035">#4035</a></li>
<li>Improve error message for wrong receiver type in <code>__traverse__</code>. <a href="https://github.com/PyO3/pyo3/pull/4045">#4045</a></li>
<li>Fix compile error when exporting a <code>#[pyclass]</code> living in a different Rust module using the <code>experimental-declarative-modules</code> feature. <a href="https://github.com/PyO3/pyo3/pull/4054">#4054</a></li>
<li>Fix <code>missing_docs</code> lint triggering on documented <code>#[pymodule]</code> functions. <a href="https://github.com/PyO3/pyo3/pull/4067">#4067</a></li>
<li>Fix undefined symbol errors for extension modules on AIX (by linking <code>libpython</code>). <a href="https://github.com/PyO3/pyo3/pull/4073">#4073</a></li>
</ul>
<h2 id="0211---2024-04-01"><a class="header" href="#0211---2024-04-01"><a href="https://github.com/pyo3/pyo3/compare/v0.21.0...v0.21.1">0.21.1</a> - 2024-04-01</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>Implement <code>Send</code> and <code>Sync</code> for <code>PyBackedStr</code> and <code>PyBackedBytes</code>. <a href="https://github.com/PyO3/pyo3/pull/4007">#4007</a></li>
<li>Implement <code>Clone</code>, <code>Debug</code>, <code>PartialEq</code>, <code>Eq</code>, <code>PartialOrd</code>, <code>Ord</code> and <code>Hash</code> implementation for <code>PyBackedBytes</code> and <code>PyBackedStr</code>, and <code>Display</code> for <code>PyBackedStr</code>. <a href="https://github.com/PyO3/pyo3/pull/4020">#4020</a></li>
<li>Add <code>import_exception_bound!</code> macro to import exception types without generating GIL Ref functionality for them. <a href="https://github.com/PyO3/pyo3/pull/4027">#4027</a></li>
</ul>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li>Emit deprecation warning for uses of GIL Refs as <code>#[setter]</code> function arguments. <a href="https://github.com/PyO3/pyo3/pull/3998">#3998</a></li>
<li>Add <code>#[inline]</code> hints on many <code>Bound</code> and <code>Borrowed</code> methods. <a href="https://github.com/PyO3/pyo3/pull/4024">#4024</a></li>
</ul>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li>Handle <code>#[pyo3(from_py_with = "")]</code> in <code>#[setter]</code> methods <a href="https://github.com/PyO3/pyo3/pull/3995">#3995</a></li>
<li>Allow extraction of <code>&amp;Bound</code> in <code>#[setter]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/3998">#3998</a></li>
<li>Fix some uncovered code blocks emitted by <code>#[pymodule]</code>, <code>#[pyfunction]</code> and <code>#[pyclass]</code> macros. <a href="https://github.com/PyO3/pyo3/pull/4009">#4009</a></li>
<li>Fix typo in the panic message when a class referenced in <code>pyo3::import_exception!</code> does not exist. <a href="https://github.com/PyO3/pyo3/pull/4012">#4012</a></li>
<li>Fix compile error when using an async <code>#[pymethod]</code> with a receiver and additional arguments. <a href="https://github.com/PyO3/pyo3/pull/4015">#4015</a></li>
</ul>
<h2 id="0210---2024-03-25"><a class="header" href="#0210---2024-03-25"><a href="https://github.com/pyo3/pyo3/compare/v0.20.3...v0.21.0">0.21.0</a> - 2024-03-25</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>Add support for GraalPy (24.0 and up). <a href="https://github.com/PyO3/pyo3/pull/3247">#3247</a></li>
<li>Add <code>PyMemoryView</code> type. <a href="https://github.com/PyO3/pyo3/pull/3514">#3514</a></li>
<li>Allow <code>async fn</code> in for <code>#[pyfunction]</code> and <code>#[pymethods]</code>, with the <code>experimental-async</code> feature. <a href="https://github.com/PyO3/pyo3/pull/3540">#3540</a> <a href="https://github.com/PyO3/pyo3/pull/3588">#3588</a> <a href="https://github.com/PyO3/pyo3/pull/3599">#3599</a> <a href="https://github.com/PyO3/pyo3/pull/3931">#3931</a></li>
<li>Implement <code>PyTypeInfo</code> for <code>PyEllipsis</code>, <code>PyNone</code> and <code>PyNotImplemented</code>. <a href="https://github.com/PyO3/pyo3/pull/3577">#3577</a></li>
<li>Support <code>#[pyclass]</code> on enums that have non-unit variants. <a href="https://github.com/PyO3/pyo3/pull/3582">#3582</a></li>
<li>Support <code>chrono</code> feature with <code>abi3</code> feature. <a href="https://github.com/PyO3/pyo3/pull/3664">#3664</a></li>
<li><code>FromPyObject</code>, <code>IntoPy&lt;PyObject&gt;</code> and <code>ToPyObject</code> are implemented on <code>std::duration::Duration</code> <a href="https://github.com/PyO3/pyo3/pull/3670">#3670</a></li>
<li>Add <code>PyString::to_cow</code>. Add <code>Py&lt;PyString&gt;::to_str</code>, <code>Py&lt;PyString&gt;::to_cow</code>, and <code>Py&lt;PyString&gt;::to_string_lossy</code>, as ways to access Python string data safely beyond the GIL lifetime. <a href="https://github.com/PyO3/pyo3/pull/3677">#3677</a></li>
<li>Add <code>Bound&lt;T&gt;</code> and <code>Borrowed&lt;T&gt;</code> smart pointers as a new API for accessing Python objects. <a href="https://github.com/PyO3/pyo3/pull/3686">#3686</a></li>
<li>Add <code>PyNativeType::as_borrowed</code> to convert "GIL refs" to the new <code>Bound</code> smart pointer. <a href="https://github.com/PyO3/pyo3/pull/3692">#3692</a></li>
<li>Add <code>FromPyObject::extract_bound</code> method, to migrate <code>FromPyObject</code> implementations to the Bound API. <a href="https://github.com/PyO3/pyo3/pull/3706">#3706</a></li>
<li>Add <code>gil-refs</code> feature to allow continued use of the deprecated GIL Refs APIs. <a href="https://github.com/PyO3/pyo3/pull/3707">#3707</a></li>
<li>Add methods to <code>PyAnyMethods</code> for binary operators (<code>add</code>, <code>sub</code>, etc.) <a href="https://github.com/PyO3/pyo3/pull/3712">#3712</a></li>
<li>Add <code>chrono-tz</code> feature allowing conversion between <code>chrono_tz::Tz</code> and <code>zoneinfo.ZoneInfo</code> <a href="https://github.com/PyO3/pyo3/pull/3730">#3730</a></li>
<li>Add FFI definition <code>PyType_GetModuleByDef</code>. <a href="https://github.com/PyO3/pyo3/pull/3734">#3734</a></li>
<li>Conversion between <code>std::time::SystemTime</code> and <code>datetime.datetime</code> <a href="https://github.com/PyO3/pyo3/pull/3736">#3736</a></li>
<li>Add <code>Py::as_any</code> and <code>Py::into_any</code>. <a href="https://github.com/PyO3/pyo3/pull/3785">#3785</a></li>
<li>Add <code>PyStringMethods::encode_utf8</code>. <a href="https://github.com/PyO3/pyo3/pull/3801">#3801</a></li>
<li>Add <code>PyBackedStr</code> and <code>PyBackedBytes</code>, as alternatives to <code>&amp;str</code> and <code>&amp;bytes</code> where a Python object owns the data. <a href="https://github.com/PyO3/pyo3/pull/3802">#3802</a> <a href="https://github.com/PyO3/pyo3/pull/3991">#3991</a></li>
<li>Allow <code>#[pymodule]</code> macro on Rust <code>mod</code> blocks, with the <code>experimental-declarative-modules</code> feature. <a href="https://github.com/PyO3/pyo3/pull/3815">#3815</a></li>
<li>Implement <code>ExactSizeIterator</code> for <code>set</code> and <code>frozenset</code> iterators on <code>abi3</code> feature. <a href="https://github.com/PyO3/pyo3/pull/3849">#3849</a></li>
<li>Add <code>Py::drop_ref</code> to explicitly drop a `Py`` and immediately decrease the Python reference count if the GIL is already held. <a href="https://github.com/PyO3/pyo3/pull/3871">#3871</a></li>
<li>Allow <code>#[pymodule]</code> macro on single argument functions that take <code>&amp;Bound&lt;'_, PyModule&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/3905">#3905</a></li>
<li>Implement <code>FromPyObject</code> for <code>Cow&lt;str&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/3928">#3928</a></li>
<li>Implement <code>Default</code> for <code>GILOnceCell</code>. <a href="https://github.com/PyO3/pyo3/pull/3971">#3971</a></li>
<li>Add <code>PyDictMethods::into_mapping</code>, <code>PyListMethods::into_sequence</code> and <code>PyTupleMethods::into_sequence</code>. <a href="https://github.com/PyO3/pyo3/pull/3982">#3982</a></li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<ul>
<li><code>PyDict::from_sequence</code> now takes a single argument of type <code>&amp;PyAny</code> (previously took two arguments <code>Python</code> and <code>PyObject</code>). <a href="https://github.com/PyO3/pyo3/pull/3532">#3532</a></li>
<li>Deprecate <code>Py::is_ellipsis</code> and <code>PyAny::is_ellipsis</code> in favour of <code>any.is(py.Ellipsis())</code>. <a href="https://github.com/PyO3/pyo3/pull/3577">#3577</a></li>
<li>Split some <code>PyTypeInfo</code> functionality into new traits <code>HasPyGilRef</code> and <code>PyTypeCheck</code>. <a href="https://github.com/PyO3/pyo3/pull/3600">#3600</a></li>
<li>Deprecate <code>PyTryFrom</code> and <code>PyTryInto</code> traits in favor of <code>any.downcast()</code> via the <code>PyTypeCheck</code> and <code>PyTypeInfo</code> traits. <a href="https://github.com/PyO3/pyo3/pull/3601">#3601</a></li>
<li>Allow async methods to accept <code>&amp;self</code>/<code>&amp;mut self</code> <a href="https://github.com/PyO3/pyo3/pull/3609">#3609</a></li>
<li><code>FromPyObject</code> for set types now also accept <code>frozenset</code> objects as input. <a href="https://github.com/PyO3/pyo3/pull/3632">#3632</a></li>
<li><code>FromPyObject</code> for <code>bool</code> now also accepts NumPy's <code>bool_</code> as input. <a href="https://github.com/PyO3/pyo3/pull/3638">#3638</a></li>
<li>Add <code>AsRefSource</code> associated type to <code>PyNativeType</code>. <a href="https://github.com/PyO3/pyo3/pull/3653">#3653</a></li>
<li>Rename <code>.is_true</code> to <code>.is_truthy</code> on <code>PyAny</code> and <code>Py&lt;PyAny&gt;</code> to clarify that the test is not based on identity with or equality to the True singleton. <a href="https://github.com/PyO3/pyo3/pull/3657">#3657</a></li>
<li><code>PyType::name</code> is now <code>PyType::qualname</code> whereas <code>PyType::name</code> efficiently accesses the full name which includes the module name. <a href="https://github.com/PyO3/pyo3/pull/3660">#3660</a></li>
<li>The <code>Iter(A)NextOutput</code> types are now deprecated and <code>__(a)next__</code> can directly return anything which can be converted into Python objects, i.e. awaitables do not need to be wrapped into <code>IterANextOutput</code> or <code>Option</code> any more. <code>Option</code> can still be used as well and returning <code>None</code> will trigger the fast path for <code>__next__</code>, stopping iteration without having to raise a <code>StopIteration</code> exception. <a href="https://github.com/PyO3/pyo3/pull/3661">#3661</a></li>
<li>Implement <code>FromPyObject</code> on <code>chrono::DateTime&lt;Tz&gt;</code> for all <code>Tz</code>, not just <code>FixedOffset</code> and <code>Utc</code>. <a href="https://github.com/PyO3/pyo3/pull/3663">#3663</a></li>
<li>Add lifetime parameter to <code>PyTzInfoAccess</code> trait. For the deprecated gil-ref API, the trait is now implemented for <code>&amp;'py PyTime</code> and <code>&amp;'py PyDateTime</code> instead of <code>PyTime</code> and <code>PyDate</code>. <a href="https://github.com/PyO3/pyo3/pull/3679">#3679</a></li>
<li>Calls to <code>__traverse__</code> become no-ops for unsendable pyclasses if on the wrong thread, thereby avoiding hard aborts at the cost of potential leakage. <a href="https://github.com/PyO3/pyo3/pull/3689">#3689</a></li>
<li>Include <code>PyNativeType</code> in <code>pyo3::prelude</code>. <a href="https://github.com/PyO3/pyo3/pull/3692">#3692</a></li>
<li>Improve performance of <code>extract::&lt;i64&gt;</code> (and other integer types) by avoiding call to <code>__index__()</code> converting the value to an integer for 3.10+. Gives performance improvement of around 30% for successful extraction. <a href="https://github.com/PyO3/pyo3/pull/3742">#3742</a></li>
<li>Relax bound of <code>FromPyObject</code> for <code>Py&lt;T&gt;</code> to just <code>T: PyTypeCheck</code>. <a href="https://github.com/PyO3/pyo3/pull/3776">#3776</a></li>
<li><code>PySet</code> and <code>PyFrozenSet</code> iterators now always iterate the equivalent of <code>iter(set)</code>. (A "fast path" with no noticeable performance benefit was removed.) <a href="https://github.com/PyO3/pyo3/pull/3849">#3849</a></li>
<li>Move implementations of <code>FromPyObject</code> for <code>&amp;str</code>, <code>Cow&lt;str&gt;</code>, <code>&amp;[u8]</code> and <code>Cow&lt;[u8]&gt;</code> onto a temporary trait <code>FromPyObjectBound</code> when <code>gil-refs</code> feature is deactivated. <a href="https://github.com/PyO3/pyo3/pull/3928">#3928</a></li>
<li>Deprecate <code>GILPool</code>, <code>Python::with_pool</code>, and <code>Python::new_pool</code>. <a href="https://github.com/PyO3/pyo3/pull/3947">#3947</a></li>
</ul>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<ul>
<li>Remove all functionality deprecated in PyO3 0.19. <a href="https://github.com/PyO3/pyo3/pull/3603">#3603</a></li>
</ul>
<h3 id="fixed-2"><a class="header" href="#fixed-2">Fixed</a></h3>
<ul>
<li>Match PyPy 7.3.14 in removing PyPy-only symbol <code>Py_MAX_NDIMS</code> in favour of <code>PyBUF_MAX_NDIM</code>. <a href="https://github.com/PyO3/pyo3/pull/3757">#3757</a></li>
<li>Fix segmentation fault using <code>datetime</code> types when an invalid <code>datetime</code> module is on sys.path. <a href="https://github.com/PyO3/pyo3/pull/3818">#3818</a></li>
<li>Fix <code>non_local_definitions</code> lint warning triggered by many PyO3 macros. <a href="https://github.com/PyO3/pyo3/pull/3901">#3901</a></li>
<li>Disable <code>PyCode</code> and <code>PyCode_Type</code> on PyPy: <code>PyCode_Type</code> is not exposed by PyPy. <a href="https://github.com/PyO3/pyo3/pull/3934">#3934</a></li>
</ul>
<h2 id="0210-beta0---2024-03-10"><a class="header" href="#0210-beta0---2024-03-10"><a href="https://github.com/pyo3/pyo3/compare/v0.20.3...v0.21.0-beta.0">0.21.0-beta.0</a> - 2024-03-10</a></h2>
<p>Prerelease of PyO3 0.21. See <a href="https://github.com/pyo3/pyo3/compare/v0.21.0-beta.0...v0.21.0">the GitHub diff</a> for what changed between 0.21.0-beta.0 and the final release.</p>
<h2 id="0203---2024-02-23"><a class="header" href="#0203---2024-02-23"><a href="https://github.com/pyo3/pyo3/compare/v0.20.2...v0.20.3">0.20.3</a> - 2024-02-23</a></h2>
<h3 id="packaging"><a class="header" href="#packaging">Packaging</a></h3>
<ul>
<li>Add <code>portable-atomic</code> dependency. <a href="https://github.com/PyO3/pyo3/pull/3619">#3619</a></li>
<li>Check maximum version of Python at build time and for versions not yet supported require opt-in to the <code>abi3</code> stable ABI by the environment variable <code>PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1</code>. <a href="https://github.com/PyO3/pyo3/pull/3821">#3821</a></li>
</ul>
<h3 id="fixed-3"><a class="header" href="#fixed-3">Fixed</a></h3>
<ul>
<li>Use <code>portable-atomic</code> to support platforms without 64-bit atomics. <a href="https://github.com/PyO3/pyo3/pull/3619">#3619</a></li>
<li>Fix compilation failure with <code>either</code> feature enabled without <code>experimental-inspect</code> enabled. <a href="https://github.com/PyO3/pyo3/pull/3834">#3834</a></li>
</ul>
<h2 id="0202---2024-01-04"><a class="header" href="#0202---2024-01-04"><a href="https://github.com/pyo3/pyo3/compare/v0.20.1...v0.20.2">0.20.2</a> - 2024-01-04</a></h2>
<h3 id="packaging-1"><a class="header" href="#packaging-1">Packaging</a></h3>
<ul>
<li>Pin <code>pyo3</code> and <code>pyo3-ffi</code> dependencies on <code>pyo3-build-config</code> to require the same patch version, i.e. <code>pyo3</code> 0.20.2 requires <em>exactly</em> <code>pyo3-build-config</code> 0.20.2. <a href="https://github.com/PyO3/pyo3/pull/3721">#3721</a></li>
</ul>
<h3 id="fixed-4"><a class="header" href="#fixed-4">Fixed</a></h3>
<ul>
<li>Fix compile failure when building <code>pyo3</code> 0.20.0 with latest <code>pyo3-build-config</code> 0.20.X. <a href="https://github.com/PyO3/pyo3/pull/3724">#3724</a></li>
<li>Fix docs.rs build. <a href="https://github.com/PyO3/pyo3/pull/3722">#3722</a></li>
</ul>
<h2 id="0201---2023-12-30"><a class="header" href="#0201---2023-12-30"><a href="https://github.com/pyo3/pyo3/compare/v0.20.0...v0.20.1">0.20.1</a> - 2023-12-30</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>Add optional <code>either</code> feature to add conversions for <code>either::Either&lt;L, R&gt;</code> sum type. <a href="https://github.com/PyO3/pyo3/pull/3456">#3456</a></li>
<li>Add optional <code>smallvec</code> feature to add conversions for <code>smallvec::SmallVec</code>. <a href="https://github.com/PyO3/pyo3/pull/3507">#3507</a></li>
<li>Add <code>take</code> and <code>into_inner</code> methods to <code>GILOnceCell</code> <a href="https://github.com/PyO3/pyo3/pull/3556">#3556</a></li>
<li><code>#[classmethod]</code> methods can now also receive <code>Py&lt;PyType&gt;</code> as their first argument. <a href="https://github.com/PyO3/pyo3/pull/3587">#3587</a></li>
<li><code>#[pyfunction(pass_module)]</code> can now also receive <code>Py&lt;PyModule&gt;</code> as their first argument. <a href="https://github.com/PyO3/pyo3/pull/3587">#3587</a></li>
<li>Add <code>traverse</code> method to <code>GILProtected</code>. <a href="https://github.com/PyO3/pyo3/pull/3616">#3616</a></li>
<li>Added <code>abi3-py312</code> feature <a href="https://github.com/PyO3/pyo3/pull/3687">#3687</a></li>
</ul>
<h3 id="fixed-5"><a class="header" href="#fixed-5">Fixed</a></h3>
<ul>
<li>Fix minimum version specification for optional <code>chrono</code> dependency. <a href="https://github.com/PyO3/pyo3/pull/3512">#3512</a></li>
<li>Silenced new <code>clippy::unnecessary_fallible_conversions</code> warning when using a <code>Py&lt;Self&gt;</code> <code>self</code> receiver. <a href="https://github.com/PyO3/pyo3/pull/3564">#3564</a></li>
</ul>
<h2 id="0200---2023-10-11"><a class="header" href="#0200---2023-10-11"><a href="https://github.com/pyo3/pyo3/compare/v0.19.2...v0.20.0">0.20.0</a> - 2023-10-11</a></h2>
<h3 id="packaging-2"><a class="header" href="#packaging-2">Packaging</a></h3>
<ul>
<li>Dual-license PyO3 under either the Apache 2.0 OR the MIT license. This makes the project GPLv2 compatible. <a href="https://github.com/PyO3/pyo3/pull/3108">#3108</a></li>
<li>Update MSRV to Rust 1.56. <a href="https://github.com/PyO3/pyo3/pull/3208">#3208</a></li>
<li>Bump <code>indoc</code> dependency to 2.0 and <code>unindent</code> dependency to 0.2. <a href="https://github.com/PyO3/pyo3/pull/3237">#3237</a></li>
<li>Bump <code>syn</code> dependency to 2.0. <a href="https://github.com/PyO3/pyo3/pull/3239">#3239</a></li>
<li>Drop support for debug builds of Python 3.7. <a href="https://github.com/PyO3/pyo3/pull/3387">#3387</a></li>
<li>Bump <code>chrono</code> optional dependency to require 0.4.25 or newer. <a href="https://github.com/PyO3/pyo3/pull/3427">#3427</a></li>
<li>Support Python 3.12. <a href="https://github.com/PyO3/pyo3/pull/3488">#3488</a></li>
</ul>
<h3 id="added-3"><a class="header" href="#added-3">Added</a></h3>
<ul>
<li>Support <code>__lt__</code>, <code>__le__</code>, <code>__eq__</code>, <code>__ne__</code>, <code>__gt__</code> and <code>__ge__</code> in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/3203">#3203</a></li>
<li>Add FFI definition <code>Py_GETENV</code>. <a href="https://github.com/PyO3/pyo3/pull/3336">#3336</a></li>
<li>Add <code>as_ptr</code> and <code>into_ptr</code> inherent methods for <code>Py</code>, <code>PyAny</code>, <code>PyRef</code>, and <code>PyRefMut</code>. <a href="https://github.com/PyO3/pyo3/pull/3359">#3359</a></li>
<li>Implement <code>DoubleEndedIterator</code> for <code>PyTupleIterator</code> and <code>PyListIterator</code>. <a href="https://github.com/PyO3/pyo3/pull/3366">#3366</a></li>
<li>Add <code>#[pyclass(rename_all = "...")]</code> option: this allows renaming all getters and setters of a struct, or all variants of an enum. Available renaming rules are: <code>"camelCase"</code>, <code>"kebab-case"</code>, <code>"lowercase"</code>, <code>"PascalCase"</code>, <code>"SCREAMING-KEBAB-CASE"</code>, <code>"SCREAMING_SNAKE_CASE"</code>, <code>"snake_case"</code>, <code>"UPPERCASE"</code>. <a href="https://github.com/PyO3/pyo3/pull/3384">#3384</a></li>
<li>Add FFI definitions <code>PyObject_GC_IsTracked</code> and <code>PyObject_GC_IsFinalized</code> on Python 3.9 and up (PyPy 3.10 and up). <a href="https://github.com/PyO3/pyo3/pull/3403">#3403</a></li>
<li>Add types for <code>None</code>, <code>Ellipsis</code>, and <code>NotImplemented</code>. <a href="https://github.com/PyO3/pyo3/pull/3408">#3408</a></li>
<li>Add FFI definitions for the <code>Py_mod_multiple_interpreters</code> constant and its possible values. <a href="https://github.com/PyO3/pyo3/pull/3494">#3494</a></li>
<li>Add FFI definitions for <code>PyInterpreterConfig</code> struct, its constants and <code>Py_NewInterpreterFromConfig</code>. <a href="https://github.com/PyO3/pyo3/pull/3502">#3502</a></li>
</ul>
<h3 id="changed-3"><a class="header" href="#changed-3">Changed</a></h3>
<ul>
<li>Change <code>PySet::discard</code> to return <code>PyResult&lt;bool&gt;</code> (previously returned nothing). <a href="https://github.com/PyO3/pyo3/pull/3281">#3281</a></li>
<li>Optimize implmentation of <code>IntoPy</code> for Rust tuples to Python tuples. <a href="https://github.com/PyO3/pyo3/pull/3321">#3321</a></li>
<li>Change <code>PyDict::get_item</code> to no longer suppress arbitrary exceptions (the return type is now <code>PyResult&lt;Option&lt;&amp;PyAny&gt;&gt;</code> instead of <code>Option&lt;&amp;PyAny&gt;</code>), and deprecate <code>PyDict::get_item_with_error</code>. <a href="https://github.com/PyO3/pyo3/pull/3330">#3330</a></li>
<li>Deprecate FFI definitions which are deprecated in Python 3.12. <a href="https://github.com/PyO3/pyo3/pull/3336">#3336</a></li>
<li><code>AsPyPointer</code> is now an <code>unsafe trait</code>. <a href="https://github.com/PyO3/pyo3/pull/3358">#3358</a></li>
<li>Accept all <code>os.PathLike</code> values in implementation of <code>FromPyObject</code> for <code>PathBuf</code>. <a href="https://github.com/PyO3/pyo3/pull/3374">#3374</a></li>
<li>Add <code>__builtins__</code> to globals in <code>py.run()</code> and <code>py.eval()</code> if they're missing. <a href="https://github.com/PyO3/pyo3/pull/3378">#3378</a></li>
<li>Optimize implementation of <code>FromPyObject</code> for <code>BigInt</code> and <code>BigUint</code>. <a href="https://github.com/PyO3/pyo3/pull/3379">#3379</a></li>
<li><code>PyIterator::from_object</code> and <code>PyByteArray::from</code> now take a single argument of type <code>&amp;PyAny</code> (previously took two arguments <code>Python</code> and <code>AsPyPointer</code>). <a href="https://github.com/PyO3/pyo3/pull/3389">#3389</a></li>
<li>Replace <code>AsPyPointer</code> with <code>AsRef&lt;PyAny&gt;</code> as a bound in the blanket implementation of <code>From&lt;&amp;T&gt; for PyObject</code>. <a href="https://github.com/PyO3/pyo3/pull/3391">#3391</a></li>
<li>Replace blanket <code>impl IntoPy&lt;PyObject&gt; for &amp;T where T: AsPyPointer</code> with implementations of <code>impl IntoPy&lt;PyObject&gt;</code> for <code>&amp;PyAny</code>, <code>&amp;T where T: AsRef&lt;PyAny&gt;</code>, and <code>&amp;Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/3393">#3393</a></li>
<li>Preserve <code>std::io::Error</code> kind in implementation of <code>From&lt;std::io::IntoInnerError&gt;</code> for <code>PyErr</code> <a href="https://github.com/PyO3/pyo3/pull/3396">#3396</a></li>
<li>Try to select a relevant <code>ErrorKind</code> in implementation of <code>From&lt;PyErr&gt;</code> for <code>OSError</code> subclass. <a href="https://github.com/PyO3/pyo3/pull/3397">#3397</a></li>
<li>Retrieve the original <code>PyErr</code> in implementation of <code>From&lt;std::io::Error&gt;</code> for <code>PyErr</code> if the <code>std::io::Error</code> has been built using a Python exception (previously would create a new exception wrapping the <code>std::io::Error</code>). <a href="https://github.com/PyO3/pyo3/pull/3402">#3402</a></li>
<li><code>#[pymodule]</code> will now return the same module object on repeated import by the same Python interpreter, on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/3446">#3446</a></li>
<li>Truncate leap-seconds and warn when converting <code>chrono</code> types to Python <code>datetime</code> types (<code>datetime</code> cannot represent leap-seconds). <a href="https://github.com/PyO3/pyo3/pull/3458">#3458</a></li>
<li><code>Err</code> returned from <code>#[pyfunction]</code> will now have a non-None <code>__context__</code> if called from inside a <code>catch</code> block. <a href="https://github.com/PyO3/pyo3/pull/3455">#3455</a></li>
<li>Deprecate undocumented <code>#[__new__]</code> form of <code>#[new]</code> attribute. <a href="https://github.com/PyO3/pyo3/pull/3505">#3505</a></li>
</ul>
<h3 id="removed-1"><a class="header" href="#removed-1">Removed</a></h3>
<ul>
<li>Remove all functionality deprecated in PyO3 0.18, including <code>#[args]</code> attribute for <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/3232">#3232</a></li>
<li>Remove <code>IntoPyPointer</code> trait in favour of <code>into_ptr</code> inherent methods. <a href="https://github.com/PyO3/pyo3/pull/3385">#3385</a></li>
</ul>
<h3 id="fixed-6"><a class="header" href="#fixed-6">Fixed</a></h3>
<ul>
<li>Handle exceptions properly in <code>PySet::discard</code>. <a href="https://github.com/PyO3/pyo3/pull/3281">#3281</a></li>
<li>The <code>PyTupleIterator</code> type returned by <code>PyTuple::iter</code> is now public and hence can be named by downstream crates. <a href="https://github.com/PyO3/pyo3/pull/3366">#3366</a></li>
<li>Linking of <code>PyOS_FSPath</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/3374">#3374</a></li>
<li>Fix memory leak in <code>PyTypeBuilder::build</code>. <a href="https://github.com/PyO3/pyo3/pull/3401">#3401</a></li>
<li>Disable removed FFI definitions <code>_Py_GetAllocatedBlocks</code>, <code>_PyObject_GC_Malloc</code>, and <code>_PyObject_GC_Calloc</code> on Python 3.11 and up. <a href="https://github.com/PyO3/pyo3/pull/3403">#3403</a></li>
<li>Fix <code>ResourceWarning</code> and crashes related to GC when running with debug builds of CPython. <a href="https://github.com/PyO3/pyo3/pull/3404">#3404</a></li>
<li>Some-wrapping of <code>Option&lt;T&gt;</code> default arguments will no longer re-wrap <code>Some(T)</code> or expressions evaluating to <code>None</code>. <a href="https://github.com/PyO3/pyo3/pull/3461">#3461</a></li>
<li>Fix <code>IterNextOutput::Return</code> not returning a value on PyPy. <a href="https://github.com/PyO3/pyo3/pull/3471">#3471</a></li>
<li>Emit compile errors instead of ignoring macro invocations inside <code>#[pymethods]</code> blocks. <a href="https://github.com/PyO3/pyo3/pull/3491">#3491</a></li>
<li>Emit error on invalid arguments to <code>#[new]</code>, <code>#[classmethod]</code>, <code>#[staticmethod]</code>, and <code>#[classattr]</code>. <a href="https://github.com/PyO3/pyo3/pull/3484">#3484</a></li>
<li>Disable <code>PyMarshal_WriteObjectToString</code> from <code>PyMarshal_ReadObjectFromString</code> with the <code>abi3</code> feature. <a href="https://github.com/PyO3/pyo3/pull/3490">#3490</a></li>
<li>Fix FFI definitions for <code>_PyFrameEvalFunction</code> on Python 3.11 and up (it now receives a <code>_PyInterpreterFrame</code> opaque struct). <a href="https://github.com/PyO3/pyo3/pull/3500">#3500</a></li>
</ul>
<h2 id="0192---2023-08-01"><a class="header" href="#0192---2023-08-01"><a href="https://github.com/pyo3/pyo3/compare/v0.19.1...v0.19.2">0.19.2</a> - 2023-08-01</a></h2>
<h3 id="added-4"><a class="header" href="#added-4">Added</a></h3>
<ul>
<li>Add FFI definitions <code>PyState_AddModule</code>, <code>PyState_RemoveModule</code> and <code>PyState_FindModule</code> for PyPy 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/3295">#3295</a></li>
<li>Add FFI definitions <code>_PyObject_CallFunction_SizeT</code> and <code>_PyObject_CallMethod_SizeT</code>. <a href="https://github.com/PyO3/pyo3/pull/3297">#3297</a></li>
<li>Add a "performance" section to the guide collecting performance-related tricks and problems. <a href="https://github.com/PyO3/pyo3/pull/3304">#3304</a></li>
<li>Add <code>PyErr::Display</code> for all Python versions, and FFI symbol <code>PyErr_DisplayException</code> for Python 3.12. <a href="https://github.com/PyO3/pyo3/pull/3334">#3334</a></li>
<li>Add FFI definition <code>PyType_GetDict()</code> for Python 3.12. <a href="https://github.com/PyO3/pyo3/pull/3339">#3339</a></li>
<li>Add <code>PyAny::downcast_exact</code>. <a href="https://github.com/PyO3/pyo3/pull/3346">#3346</a></li>
<li>Add <code>PySlice::full()</code> to construct a full slice (<code>::</code>). <a href="https://github.com/PyO3/pyo3/pull/3353">#3353</a></li>
</ul>
<h3 id="changed-4"><a class="header" href="#changed-4">Changed</a></h3>
<ul>
<li>Update <code>PyErr</code> for 3.12 betas to avoid deprecated ffi methods. <a href="https://github.com/PyO3/pyo3/pull/3306">#3306</a></li>
<li>Update FFI definitions of <code>object.h</code> for Python 3.12.0b4. <a href="https://github.com/PyO3/pyo3/pull/3335">#3335</a></li>
<li>Update <code>pyo3::ffi</code> struct definitions to be compatible with 3.12.0b4. <a href="https://github.com/PyO3/pyo3/pull/3342">#3342</a></li>
<li>Optimize conversion of <code>float</code> to <code>f64</code> (and <code>PyFloat::value</code>) on non-abi3 builds. <a href="https://github.com/PyO3/pyo3/pull/3345">#3345</a></li>
</ul>
<h3 id="fixed-7"><a class="header" href="#fixed-7">Fixed</a></h3>
<ul>
<li>Fix timezone conversion bug for FixedOffset datetimes that were being incorrectly converted to and from UTC. <a href="https://github.com/PyO3/pyo3/pull/3269">#3269</a></li>
<li>Fix <code>SystemError</code> raised in <code>PyUnicodeDecodeError_Create</code> on PyPy 3.10. <a href="https://github.com/PyO3/pyo3/pull/3297">#3297</a></li>
<li>Correct FFI definition <code>Py_EnterRecursiveCall</code> to return <code>c_int</code> (was incorrectly returning <code>()</code>). <a href="https://github.com/PyO3/pyo3/pull/3300">#3300</a></li>
<li>Fix case where <code>PyErr::matches</code> and <code>PyErr::is_instance</code> returned results inconsistent with <code>PyErr::get_type</code>. <a href="https://github.com/PyO3/pyo3/pull/3313">#3313</a></li>
<li>Fix loss of panic message in <code>PanicException</code> when unwinding after the exception was "normalized". <a href="https://github.com/PyO3/pyo3/pull/3326">#3326</a></li>
<li>Fix <code>PyErr::from_value</code> and <code>PyErr::into_value</code> losing traceback on conversion. <a href="https://github.com/PyO3/pyo3/pull/3328">#3328</a></li>
<li>Fix reference counting of immortal objects on Python 3.12.0b4. <a href="https://github.com/PyO3/pyo3/pull/3335">#3335</a></li>
</ul>
<h2 id="0191---2023-07-03"><a class="header" href="#0191---2023-07-03"><a href="https://github.com/pyo3/pyo3/compare/v0.19.0...v0.19.1">0.19.1</a> - 2023-07-03</a></h2>
<h3 id="packaging-3"><a class="header" href="#packaging-3">Packaging</a></h3>
<ul>
<li>Extend range of supported versions of <code>hashbrown</code> optional dependency to include version 0.14 <a href="https://github.com/PyO3/pyo3/pull/3258">#3258</a></li>
<li>Extend range of supported versions of <code>indexmap</code> optional dependency to include version 2. <a href="https://github.com/PyO3/pyo3/pull/3277">#3277</a></li>
<li>Support PyPy 3.10. <a href="https://github.com/PyO3/pyo3/pull/3289">#3289</a></li>
</ul>
<h3 id="added-5"><a class="header" href="#added-5">Added</a></h3>
<ul>
<li>Add <code>pyo3::types::PyFrozenSetBuilder</code> to allow building a <code>PyFrozenSet</code> item by item. <a href="https://github.com/PyO3/pyo3/pull/3156">#3156</a></li>
<li>Add support for converting to and from Python's <code>ipaddress.IPv4Address</code>/<code>ipaddress.IPv6Address</code> and <code>std::net::IpAddr</code>. <a href="https://github.com/PyO3/pyo3/pull/3197">#3197</a></li>
<li>Add support for <code>num-bigint</code> feature in combination with <code>abi3</code>. <a href="https://github.com/PyO3/pyo3/pull/3198">#3198</a></li>
<li>Add <code>PyErr_GetRaisedException()</code>, <code>PyErr_SetRaisedException()</code> to FFI definitions for Python 3.12 and later. <a href="https://github.com/PyO3/pyo3/pull/3248">#3248</a></li>
<li>Add <code>Python::with_pool</code> which is a safer but more limited alternative to <code>Python::new_pool</code>. <a href="https://github.com/PyO3/pyo3/pull/3263">#3263</a></li>
<li>Add <code>PyDict::get_item_with_error</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/3270">#3270</a></li>
<li>Allow <code>#[new]</code> methods may to return <code>Py&lt;Self&gt;</code> in order to return existing instances. <a href="https://github.com/PyO3/pyo3/pull/3287">#3287</a></li>
</ul>
<h3 id="fixed-8"><a class="header" href="#fixed-8">Fixed</a></h3>
<ul>
<li>Fix conversion of classes implementing <code>__complex__</code> to <code>Complex</code> when using <code>abi3</code> or PyPy. <a href="https://github.com/PyO3/pyo3/pull/3185">#3185</a></li>
<li>Stop suppressing unrelated exceptions in <code>PyAny::hasattr</code>. <a href="https://github.com/PyO3/pyo3/pull/3271">#3271</a></li>
<li>Fix memory leak when creating <code>PySet</code> or <code>PyFrozenSet</code> or returning types converted into these internally, e.g. <code>HashSet</code> or <code>BTreeSet</code>. <a href="https://github.com/PyO3/pyo3/pull/3286">#3286</a></li>
</ul>
<h2 id="0190---2023-05-31"><a class="header" href="#0190---2023-05-31"><a href="https://github.com/pyo3/pyo3/compare/v0.18.3...v0.19.0">0.19.0</a> - 2023-05-31</a></h2>
<h3 id="packaging-4"><a class="header" href="#packaging-4">Packaging</a></h3>
<ul>
<li>Correct dependency on syn to version 1.0.85 instead of the incorrect version 1.0.56. <a href="https://github.com/PyO3/pyo3/pull/3152">#3152</a></li>
</ul>
<h3 id="added-6"><a class="header" href="#added-6">Added</a></h3>
<ul>
<li>Accept <code>text_signature</code> option (and automatically generate signature) for <code>#[new]</code> in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2980">#2980</a></li>
<li>Add support for converting to and from Python's <code>decimal.Decimal</code> and <code>rust_decimal::Decimal</code>. <a href="https://github.com/PyO3/pyo3/pull/3016">#3016</a></li>
<li>Add <code>#[pyo3(from_item_all)]</code> when deriving <code>FromPyObject</code> to specify <code>get_item</code> as getter for all fields. <a href="https://github.com/PyO3/pyo3/pull/3120">#3120</a></li>
<li>Add <code>pyo3::exceptions::PyBaseExceptionGroup</code> for Python 3.11, and corresponding FFI definition <code>PyExc_BaseExceptionGroup</code>. <a href="https://github.com/PyO3/pyo3/pull/3141">#3141</a></li>
<li>Accept <code>#[new]</code> with <code>#[classmethod]</code> to create a constructor which receives a (subtype's) class/<code>PyType</code> as its first argument. <a href="https://github.com/PyO3/pyo3/pull/3157">#3157</a></li>
<li>Add <code>PyClass::get</code> and <code>Py::get</code> for GIL-indepedent access to classes with <code>#[pyclass(frozen)]</code>. <a href="https://github.com/PyO3/pyo3/pull/3158">#3158</a></li>
<li>Add <code>PyAny::is_exact_instance</code> and <code>PyAny::is_exact_instance_of</code>. <a href="https://github.com/PyO3/pyo3/pull/3161">#3161</a></li>
</ul>
<h3 id="changed-5"><a class="header" href="#changed-5">Changed</a></h3>
<ul>
<li><code>PyAny::is_instance_of::&lt;T&gt;(obj)</code> is now equivalent to <code>T::is_type_of(obj)</code>, and now returns <code>bool</code> instead of <code>PyResult&lt;bool&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/2881">#2881</a></li>
<li>Deprecate <code>text_signature</code> option on <code>#[pyclass]</code> structs. <a href="https://github.com/PyO3/pyo3/pull/2980">#2980</a></li>
<li>No longer wrap <code>anyhow::Error</code>/<code>eyre::Report</code> containing a basic <code>PyErr</code> without a chain in a <code>PyRuntimeError</code>. <a href="https://github.com/PyO3/pyo3/pull/3004">#3004</a></li>
<li>
<ul>
<li>Change <code>#[getter]</code> and <code>#[setter]</code> to use a common call "trampoline" to slightly reduce generated code size and compile times. <a href="https://github.com/PyO3/pyo3/pull/3029">#3029</a></li>
</ul>
</li>
<li>Improve default values for str, numbers and bool in automatically-generated <code>text_signature</code>. <a href="https://github.com/PyO3/pyo3/pull/3050">#3050</a></li>
<li>Improve default value for <code>None</code> in automatically-generated <code>text_signature</code>. <a href="https://github.com/PyO3/pyo3/pull/3066">#3066</a></li>
<li>Rename <code>PySequence::list</code> and <code>PySequence::tuple</code> to <code>PySequence::to_list</code> and <code>PySequence::to_tuple</code>. (The old names continue to exist as deprecated forms.) <a href="https://github.com/PyO3/pyo3/pull/3111">#3111</a></li>
<li>Extend the lifetime of the GIL token returned by <code>PyRef::py</code> and <code>PyRefMut::py</code> to match the underlying borrow. <a href="https://github.com/PyO3/pyo3/pull/3131">#3131</a></li>
<li>Safe access to the GIL, for example via <code>Python::with_gil</code>, is now locked inside of implementations of the <code>__traverse__</code> slot. <a href="https://github.com/PyO3/pyo3/pull/3168">#3168</a></li>
</ul>
<h3 id="removed-2"><a class="header" href="#removed-2">Removed</a></h3>
<ul>
<li>Remove all functionality deprecated in PyO3 0.17, most prominently <code>Python::acquire_gil</code> is replaced by <code>Python::with_gil</code>. <a href="https://github.com/PyO3/pyo3/pull/2981">#2981</a></li>
</ul>
<h3 id="fixed-9"><a class="header" href="#fixed-9">Fixed</a></h3>
<ul>
<li>Correct FFI definitions <code>PyGetSetDef</code>, <code>PyMemberDef</code>, <code>PyStructSequence_Field</code> and <code>PyStructSequence_Desc</code> to have <code>*const c_char</code> members for <code>name</code> and <code>doc</code> (not <code>*mut c_char</code>). <a href="https://github.com/PyO3/pyo3/pull/3036">#3036</a></li>
<li>Fix panic on <code>fmt::Display</code>, instead return <code>"&lt;unprintable object&gt;"</code> string and report error via <code>sys.unraisablehook()</code> <a href="https://github.com/PyO3/pyo3/pull/3062">#3062</a></li>
<li>Fix a compile error of "temporary value dropped while borrowed" when <code>#[pyfunction]</code>s take references into <code>#[pyclass]</code>es <a href="https://github.com/PyO3/pyo3/pull/3142">#3142</a></li>
<li>Fix crashes caused by PyO3 applying deferred reference count updates when entering a <code>__traverse__</code> implementation. <a href="https://github.com/PyO3/pyo3/pull/3168">#3168</a></li>
<li>Forbid running the <code>Drop</code> implementations of unsendable classes on other threads. <a href="https://github.com/PyO3/pyo3/pull/3176">#3176</a></li>
<li>Fix a compile error when <code>#[pymethods]</code> items come from somewhere else (for example, as a macro argument) and a custom receiver like <code>Py&lt;Self&gt;</code> is used. <a href="https://github.com/PyO3/pyo3/pull/3178">#3178</a></li>
</ul>
<h2 id="0183---2023-04-13"><a class="header" href="#0183---2023-04-13"><a href="https://github.com/pyo3/pyo3/compare/v0.18.2...v0.18.3">0.18.3</a> - 2023-04-13</a></h2>
<h3 id="added-7"><a class="header" href="#added-7">Added</a></h3>
<ul>
<li>Add <code>GILProtected&lt;T&gt;</code> to mediate concurrent access to a value using Python's global interpreter lock (GIL). <a href="https://github.com/PyO3/pyo3/pull/2975">#2975</a></li>
<li>Support <code>PyASCIIObject</code> / <code>PyUnicode</code> and associated methods on big-endian architectures. <a href="https://github.com/PyO3/pyo3/pull/3015">#3015</a></li>
<li>Add FFI definition <code>_PyDict_Contains_KnownHash()</code> for CPython 3.10 and up. <a href="https://github.com/PyO3/pyo3/pull/3088">#3088</a></li>
</ul>
<h3 id="fixed-10"><a class="header" href="#fixed-10">Fixed</a></h3>
<ul>
<li>Fix compile error for <code>#[pymethods]</code> and <code>#[pyfunction]</code> called "output". <a href="https://github.com/PyO3/pyo3/pull/3022">#3022</a></li>
<li>Fix compile error in generated code for magic methods implemented as a <code>#[staticmethod]</code>. <a href="https://github.com/PyO3/pyo3/pull/3055">#3055</a></li>
<li>Fix <code>is_instance</code> for <code>PyDateTime</code> (would incorrectly check for a <code>PyDate</code>). <a href="https://github.com/PyO3/pyo3/pull/3071">#3071</a></li>
<li>Fix upstream deprecation of <code>PyUnicode_InternImmortal</code> since Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/3087">#3071</a></li>
</ul>
<h2 id="0182---2023-03-24"><a class="header" href="#0182---2023-03-24"><a href="https://github.com/pyo3/pyo3/compare/v0.18.1...v0.18.2">0.18.2</a> - 2023-03-24</a></h2>
<h3 id="packaging-5"><a class="header" href="#packaging-5">Packaging</a></h3>
<ul>
<li>Disable default features of <code>chrono</code> to avoid depending on <code>time</code> v0.1.x. <a href="https://github.com/PyO3/pyo3/pull/2939">#2939</a></li>
</ul>
<h3 id="added-8"><a class="header" href="#added-8">Added</a></h3>
<ul>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code>, <code>ToPyObject</code> and <code>FromPyObject</code> for <code>Cow&lt;[u8]&gt;</code> to efficiently handle both <code>bytes</code> and <code>bytearray</code> objects. <a href="https://github.com/PyO3/pyo3/pull/2899">#2899</a></li>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code>, <code>ToPyObject</code> and <code>FromPyObject</code> for <code>Cell&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/3014">#3014</a></li>
<li>Add <code>PyList::to_tuple()</code>, as a convenient and efficient conversion from lists to tuples. <a href="https://github.com/PyO3/pyo3/pull/3042">#3042</a></li>
<li>Add <code>PyTuple::to_list()</code>, as a convenient and efficient conversion from tuples to lists. <a href="https://github.com/PyO3/pyo3/pull/3044">#3044</a></li>
</ul>
<h3 id="changed-6"><a class="header" href="#changed-6">Changed</a></h3>
<ul>
<li>Optimize <code>PySequence</code> conversion for <code>list</code> and <code>tuple</code> inputs. <a href="https://github.com/PyO3/pyo3/pull/2944">#2944</a></li>
<li>Improve exception raised when creating <code>#[pyclass]</code> type object fails during module import. <a href="https://github.com/PyO3/pyo3/pull/2947">#2947</a></li>
<li>Optimize <code>PyMapping</code> conversion for <code>dict</code> inputs. <a href="https://github.com/PyO3/pyo3/pull/2954">#2954</a></li>
<li>Allow <code>create_exception!</code> to take a <code>dotted.module</code> to place the exception in a submodule. <a href="https://github.com/PyO3/pyo3/pull/2979">#2979</a></li>
</ul>
<h3 id="fixed-11"><a class="header" href="#fixed-11">Fixed</a></h3>
<ul>
<li>Fix a reference counting race condition affecting <code>PyObject</code>s cloned in <code>allow_threads</code> blocks. <a href="https://github.com/PyO3/pyo3/pull/2952">#2952</a></li>
<li>Fix <code>clippy::redundant_closure</code> lint on default arguments in <code>#[pyo3(signature = (...))]</code> annotations. <a href="https://github.com/PyO3/pyo3/pull/2990">#2990</a></li>
<li>Fix <code>non_snake_case</code> lint on generated code in <code>#[pyfunction]</code> macro. <a href="https://github.com/PyO3/pyo3/pull/2993">#2993</a></li>
<li>Fix some FFI definitions for the upcoming PyPy 3.10 release. <a href="https://github.com/PyO3/pyo3/pull/3031">#3031</a></li>
</ul>
<h2 id="0181---2023-02-07"><a class="header" href="#0181---2023-02-07"><a href="https://github.com/pyo3/pyo3/compare/v0.18.0...v0.18.1">0.18.1</a> - 2023-02-07</a></h2>
<h3 id="added-9"><a class="header" href="#added-9">Added</a></h3>
<ul>
<li>Add <code>PyErr::write_unraisable()</code>. <a href="https://github.com/PyO3/pyo3/pull/2889">#2889</a></li>
<li>Add <code>Python::Ellipsis()</code> and <code>PyAny::is_ellipsis()</code> methods. <a href="https://github.com/PyO3/pyo3/pull/2911">#2911</a></li>
<li>Add <code>PyDict::update()</code> and <code>PyDict::update_if_missing()</code> methods. <a href="https://github.com/PyO3/pyo3/pull/2912">#2912</a></li>
</ul>
<h3 id="changed-7"><a class="header" href="#changed-7">Changed</a></h3>
<ul>
<li>FFI definition <code>PyIter_Check</code> on CPython 3.7 is now implemented as <code>hasattr(type(obj), "__next__")</code>, which works correctly on all platforms and adds support for <code>abi3</code>. <a href="https://github.com/PyO3/pyo3/pull/2914">#2914</a></li>
<li>Warn about unknown config keys in <code>PYO3_CONFIG_FILE</code> instead of denying. <a href="https://github.com/PyO3/pyo3/pull/2926">#2926</a></li>
</ul>
<h3 id="fixed-12"><a class="header" href="#fixed-12">Fixed</a></h3>
<ul>
<li>Send errors returned by <code>__releasebuffer__</code> to <code>sys.unraisablehook</code> rather than causing <code>SystemError</code>. <a href="https://github.com/PyO3/pyo3/pull/2886">#2886</a></li>
<li>Fix downcast to <code>PyIterator</code> succeeding for Python classes which did not implement <code>__next__</code>. <a href="https://github.com/PyO3/pyo3/pull/2914">#2914</a></li>
<li>Fix segfault in <code>__traverse__</code> when visiting <code>None</code> fields of <code>Option&lt;T: AsPyPointer&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/2921">#2921</a></li>
<li>Fix <code>#[pymethods(crate = "...")]</code> option being ignored. <a href="https://github.com/PyO3/pyo3/pull/2923">#2923</a></li>
<li>Link against <code>pythonXY_d.dll</code> for debug Python builds on Windows. <a href="https://github.com/PyO3/pyo3/pull/2937">#2937</a></li>
</ul>
<h2 id="0180---2023-01-17"><a class="header" href="#0180---2023-01-17"><a href="https://github.com/pyo3/pyo3/compare/v0.17.3...v0.18.0">0.18.0</a> - 2023-01-17</a></h2>
<h3 id="packaging-6"><a class="header" href="#packaging-6">Packaging</a></h3>
<ul>
<li>Relax <code>indexmap</code> optional depecency to allow <code>&gt;= 1.6, &lt; 2</code>. <a href="https://github.com/PyO3/pyo3/pull/2849">#2849</a></li>
<li>Relax <code>hashbrown</code> optional dependency to allow <code>&gt;= 0.9, &lt; 0.14</code>. <a href="https://github.com/PyO3/pyo3/pull/2875">#2875</a></li>
<li>Update <code>memoffset</code> dependency to 0.8. <a href="https://github.com/PyO3/pyo3/pull/2875">#2875</a></li>
</ul>
<h3 id="added-10"><a class="header" href="#added-10">Added</a></h3>
<ul>
<li>Add <code>GILOnceCell::get_or_try_init</code> for fallible <code>GILOnceCell</code> initialization. <a href="https://github.com/PyO3/pyo3/pull/2398">#2398</a></li>
<li>Add experimental feature <code>experimental-inspect</code> with <code>type_input()</code> and <code>type_output()</code> helpers to get the Python type of any Python-compatible object. <a href="https://github.com/PyO3/pyo3/pull/2490">#2490</a> <a href="https://github.com/PyO3/pyo3/pull/2882">#2882</a></li>
<li>The <code>#[pyclass]</code> macro can now take <code>get_all</code> and <code>set_all</code> to create getters and setters for every field. <a href="https://github.com/PyO3/pyo3/pull/2692">#2692</a></li>
<li>Add <code>#[pyo3(signature = (...))]</code> option for <code>#[pyfunction]</code> and <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2702">#2702</a></li>
<li><code>pyo3-build-config</code>: rebuild when <code>PYO3_ENVIRONMENT_SIGNATURE</code> environment variable value changes. <a href="https://github.com/PyO3/pyo3/pull/2727">#2727</a></li>
<li>Add conversions between non-zero int types in <code>std::num</code> and Python <code>int</code>. <a href="https://github.com/PyO3/pyo3/pull/2730">#2730</a></li>
<li>Add <code>Py::downcast()</code> as a companion to <code>PyAny::downcast()</code>, as well as <code>downcast_unchecked()</code> for both types. <a href="https://github.com/PyO3/pyo3/pull/2734">#2734</a></li>
<li>Add types for all built-in <code>Warning</code> classes as well as <code>PyErr::warn_explicit</code>. <a href="https://github.com/PyO3/pyo3/pull/2742">#2742</a></li>
<li>Add <code>abi3-py311</code> feature. <a href="https://github.com/PyO3/pyo3/pull/2776">#2776</a></li>
<li>Add FFI definition <code>_PyErr_ChainExceptions()</code> for CPython. <a href="https://github.com/PyO3/pyo3/pull/2788">#2788</a></li>
<li>Add FFI definitions <code>PyVectorcall_NARGS</code> and <code>PY_VECTORCALL_ARGUMENTS_OFFSET</code> for PyPy 3.8 and up. <a href="https://github.com/PyO3/pyo3/pull/2811">#2811</a></li>
<li>Add <code>PyList::get_item_unchecked</code> for PyPy. <a href="https://github.com/PyO3/pyo3/pull/2827">#2827</a></li>
</ul>
<h3 id="changed-8"><a class="header" href="#changed-8">Changed</a></h3>
<ul>
<li>PyO3's macros now emit a much nicer error message if function return values don't implement the required trait(s). <a href="https://github.com/PyO3/pyo3/pull/2664">#2664</a></li>
<li>Use a TypeError, rather than a ValueError, when refusing to treat a str as a Vec. <a href="https://github.com/PyO3/pyo3/pull/2685">#2685</a></li>
<li>Change <code>PyCFunction::new_closure</code> to take <code>name</code> and <code>doc</code> arguments. <a href="https://github.com/PyO3/pyo3/pull/2686">#2686</a></li>
<li><code>PyType::is_subclass</code>, <code>PyErr::is_instance</code> and <code>PyAny::is_instance</code> now take <code>&amp;PyAny</code> instead of <code>&amp;PyType</code> arguments, so that they work with objects that pretend to be types using <code>__subclasscheck__</code> and <code>__instancecheck__</code>. <a href="https://github.com/PyO3/pyo3/pull/2695">#2695</a></li>
<li>Deprecate <code>#[args]</code> attribute and passing "args" specification directly to <code>#[pyfunction]</code> in favor of the new <code>#[pyo3(signature = (...))]</code> option. <a href="https://github.com/PyO3/pyo3/pull/2702">#2702</a></li>
<li>Deprecate required arguments after <code>Option&lt;T&gt;</code> arguments to <code>#[pyfunction]</code> and <code>#[pymethods]</code> without also using <code>#[pyo3(signature)]</code> to specify whether the arguments should be required or have defaults. <a href="https://github.com/PyO3/pyo3/pull/2703">#2703</a></li>
<li>Change <code>#[pyfunction]</code> and <code>#[pymethods]</code> to use a common call "trampoline" to slightly reduce generated code size and compile times. <a href="https://github.com/PyO3/pyo3/pull/2705">#2705</a></li>
<li><code>PyAny::cast_as()</code> and <code>Py::cast_as()</code> are now deprecated in favor of <code>PyAny::downcast()</code> and the new <code>Py::downcast()</code>. <a href="https://github.com/PyO3/pyo3/pull/2734">#2734</a></li>
<li>Relax lifetime bounds on <code>PyAny::downcast()</code>. <a href="https://github.com/PyO3/pyo3/pull/2734">#2734</a></li>
<li>Automatically generate <code>__text_signature__</code> for all Python functions created using <code>#[pyfunction]</code> and <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2784">#2784</a></li>
<li>Accept any iterator in <code>PySet::new</code> and <code>PyFrozenSet::new</code>. <a href="https://github.com/PyO3/pyo3/pull/2795">#2795</a></li>
<li>Mixing <code>#[cfg(...)]</code> and <code>#[pyo3(...)]</code> attributes on <code>#[pyclass]</code> struct fields will now work. <a href="https://github.com/PyO3/pyo3/pull/2796">#2796</a></li>
<li>Re-enable <code>PyFunction</code> on when building for abi3 or PyPy. <a href="https://github.com/PyO3/pyo3/pull/2838">#2838</a></li>
<li>Improve <code>derive(FromPyObject)</code> to use <code>intern!</code> when applicable for <code>#[pyo3(item)]</code>. <a href="https://github.com/PyO3/pyo3/pull/2879">#2879</a></li>
</ul>
<h3 id="removed-3"><a class="header" href="#removed-3">Removed</a></h3>
<ul>
<li>Remove the deprecated <code>pyproto</code> feature, <code>#[pyproto]</code> macro, and all accompanying APIs. <a href="https://github.com/PyO3/pyo3/pull/2587">#2587</a></li>
<li>Remove all functionality deprecated in PyO3 0.16. <a href="https://github.com/PyO3/pyo3/pull/2843">#2843</a></li>
</ul>
<h3 id="fixed-13"><a class="header" href="#fixed-13">Fixed</a></h3>
<ul>
<li>Disable <code>PyModule::filename</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/2715">#2715</a></li>
<li><code>PyCodeObject</code> is now once again defined with fields on Python 3.7. <a href="https://github.com/PyO3/pyo3/pull/2726">#2726</a></li>
<li>Raise a <code>TypeError</code> if <code>#[new]</code> pymethods with no arguments receive arguments when called from Python. <a href="https://github.com/PyO3/pyo3/pull/2749">#2749</a></li>
<li>Use the <code>NOARGS</code> argument calling convention for methods that have a single <code>py: Python</code> argument (as a performance optimization). <a href="https://github.com/PyO3/pyo3/pull/2760">#2760</a></li>
<li>Fix truncation of <code>isize</code> values to <code>c_long</code> in <code>PySlice::new</code>. <a href="https://github.com/PyO3/pyo3/pull/2769">#2769</a></li>
<li>Fix soundness issue with FFI definition <code>PyUnicodeDecodeError_Create</code> on PyPy leading to indeterminate behavior (typically a <code>TypeError</code>). <a href="https://github.com/PyO3/pyo3/pull/2772">#2772</a></li>
<li>Allow functions taking <code>**kwargs</code> to accept keyword arguments which share a name with a positional-only argument (as permitted by PEP 570). <a href="https://github.com/PyO3/pyo3/pull/2800">#2800</a></li>
<li>Fix unresolved symbol for <code>PyObject_Vectorcall</code> on PyPy 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/2811">#2811</a></li>
<li>Fix memory leak in <code>PyCFunction::new_closure</code>. <a href="https://github.com/PyO3/pyo3/pull/2842">#2842</a></li>
</ul>
<h2 id="0173---2022-11-01"><a class="header" href="#0173---2022-11-01"><a href="https://github.com/pyo3/pyo3/compare/v0.17.2...v0.17.3">0.17.3</a> - 2022-11-01</a></h2>
<h3 id="packaging-7"><a class="header" href="#packaging-7">Packaging</a></h3>
<ul>
<li>Support Python 3.11. (Previous versions of PyO3 0.17 have been tested against Python 3.11 release candidates and are expected to be compatible, this is the first version tested against Python 3.11.0.) <a href="https://github.com/PyO3/pyo3/pull/2708">#2708</a></li>
</ul>
<h3 id="added-11"><a class="header" href="#added-11">Added</a></h3>
<ul>
<li>Implemented <code>ExactSizeIterator</code> for <code>PyListIterator</code>, <code>PyDictIterator</code>, <code>PySetIterator</code> and <code>PyFrozenSetIterator</code>. <a href="https://github.com/PyO3/pyo3/pull/2676">#2676</a></li>
</ul>
<h3 id="fixed-14"><a class="header" href="#fixed-14">Fixed</a></h3>
<ul>
<li>Fix regression of <code>impl FromPyObject for [T; N]</code> no longer accepting types passing <code>PySequence_Check</code>, e.g. NumPy arrays, since version 0.17.0. This the same fix that was applied <code>impl FromPyObject for Vec&lt;T&gt;</code> in version 0.17.1 extended to fixed-size arrays. <a href="https://github.com/PyO3/pyo3/pull/2675">#2675</a></li>
<li>Fix UB in <code>FunctionDescription::extract_arguments_fastcall</code> due to creating slices from a null pointer. <a href="https://github.com/PyO3/pyo3/pull/2687">#2687</a></li>
</ul>
<h2 id="0172---2022-10-04"><a class="header" href="#0172---2022-10-04"><a href="https://github.com/pyo3/pyo3/compare/v0.17.1...v0.17.2">0.17.2</a> - 2022-10-04</a></h2>
<h3 id="packaging-8"><a class="header" href="#packaging-8">Packaging</a></h3>
<ul>
<li>Added optional <code>chrono</code> feature to convert <code>chrono</code> types into types in the <code>datetime</code> module. <a href="https://github.com/PyO3/pyo3/pull/2612">#2612</a></li>
</ul>
<h3 id="added-12"><a class="header" href="#added-12">Added</a></h3>
<ul>
<li>Add support for <code>num-bigint</code> feature on <code>PyPy</code>. <a href="https://github.com/PyO3/pyo3/pull/2626">#2626</a></li>
</ul>
<h3 id="fixed-15"><a class="header" href="#fixed-15">Fixed</a></h3>
<ul>
<li>Correctly implement <code>__richcmp__</code> for enums, fixing <code>__ne__</code> returning always returning <code>True</code>. <a href="https://github.com/PyO3/pyo3/pull/2622">#2622</a></li>
<li>Fix compile error since 0.17.0 with <code>Option&lt;&amp;SomePyClass&gt;</code> argument with a default. <a href="https://github.com/PyO3/pyo3/pull/2630">#2630</a></li>
<li>Fix regression of <code>impl FromPyObject for Vec&lt;T&gt;</code> no longer accepting types passing <code>PySequence_Check</code>, e.g. NumPy arrays, since 0.17.0. <a href="https://github.com/PyO3/pyo3/pull/2631">#2631</a></li>
</ul>
<h2 id="0171---2022-08-28"><a class="header" href="#0171---2022-08-28"><a href="https://github.com/pyo3/pyo3/compare/v0.17.0...v0.17.1">0.17.1</a> - 2022-08-28</a></h2>
<h3 id="fixed-16"><a class="header" href="#fixed-16">Fixed</a></h3>
<ul>
<li>Fix visibility of <code>PyDictItems</code>, <code>PyDictKeys</code>, and <code>PyDictValues</code> types added in PyO3 0.17.0.</li>
<li>Fix compile failure when using <code>#[pyo3(from_py_with = "...")]</code> attribute on an argument of type <code>Option&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/2592">#2592</a></li>
<li>Fix clippy <code>redundant-closure</code> lint on <code>**kwargs</code> arguments for <code>#[pyfunction]</code> and <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2595">#2595</a></li>
</ul>
<h2 id="0170---2022-08-23"><a class="header" href="#0170---2022-08-23"><a href="https://github.com/pyo3/pyo3/compare/v0.16.6...v0.17.0">0.17.0</a> - 2022-08-23</a></h2>
<h3 id="packaging-9"><a class="header" href="#packaging-9">Packaging</a></h3>
<ul>
<li>Update inventory dependency to <code>0.3</code> (the <code>multiple-pymethods</code> feature now requires Rust 1.62 for correctness). <a href="https://github.com/PyO3/pyo3/pull/2492">#2492</a></li>
</ul>
<h3 id="added-13"><a class="header" href="#added-13">Added</a></h3>
<ul>
<li>Add <code>timezone_utc</code>. <a href="https://github.com/PyO3/pyo3/pull/1588">#1588</a></li>
<li>Implement <code>ToPyObject</code> for <code>[T; N]</code>. <a href="https://github.com/PyO3/pyo3/pull/2313">#2313</a></li>
<li>Add <code>PyDictKeys</code>, <code>PyDictValues</code> and <code>PyDictItems</code> Rust types. <a href="https://github.com/PyO3/pyo3/pull/2358">#2358</a></li>
<li>Add <code>append_to_inittab</code>. <a href="https://github.com/PyO3/pyo3/pull/2377">#2377</a></li>
<li>Add FFI definition <code>PyFrame_GetCode</code>. <a href="https://github.com/PyO3/pyo3/pull/2406">#2406</a></li>
<li>Add <code>PyCode</code> and <code>PyFrame</code> high level objects. <a href="https://github.com/PyO3/pyo3/pull/2408">#2408</a></li>
<li>Add FFI definitions <code>Py_fstring_input</code>, <code>sendfunc</code>, and <code>_PyErr_StackItem</code>. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Add <code>PyDateTime::new_with_fold</code>, <code>PyTime::new_with_fold</code>, <code>PyTime::get_fold</code>, and <code>PyDateTime::get_fold</code> for PyPy. <a href="https://github.com/PyO3/pyo3/pull/2428">#2428</a></li>
<li>Add <code>#[pyclass(frozen)]</code>. <a href="https://github.com/PyO3/pyo3/pull/2448">#2448</a></li>
<li>Accept <code>#[pyo3(name)]</code> on enum variants. <a href="https://github.com/PyO3/pyo3/pull/2457">#2457</a></li>
<li>Add <code>CompareOp::matches</code> to implement <code>__richcmp__</code> as the result of a Rust <code>std::cmp::Ordering</code> comparison. <a href="https://github.com/PyO3/pyo3/pull/2460">#2460</a></li>
<li>Add <code>PySuper</code> type. <a href="https://github.com/PyO3/pyo3/pull/2486">#2486</a></li>
<li>Support PyPy on Windows with the <code>generate-import-lib</code> feature. <a href="https://github.com/PyO3/pyo3/pull/2506">#2506</a></li>
<li>Add FFI definitions <code>Py_EnterRecursiveCall</code> and <code>Py_LeaveRecursiveCall</code>. <a href="https://github.com/PyO3/pyo3/pull/2511">#2511</a></li>
<li>Add <code>PyDict::get_item_with_error</code>. <a href="https://github.com/PyO3/pyo3/pull/2536">#2536</a></li>
<li>Add <code>#[pyclass(sequence)]</code> option. <a href="https://github.com/PyO3/pyo3/pull/2567">#2567</a></li>
</ul>
<h3 id="changed-9"><a class="header" href="#changed-9">Changed</a></h3>
<ul>
<li>Change datetime constructors taking a <code>tzinfo</code> to take <code>Option&lt;&amp;PyTzInfo&gt;</code> instead of <code>Option&lt;&amp;PyObject&gt;</code>: <code>PyDateTime::new</code>, <code>PyDateTime::new_with_fold</code>, <code>PyTime::new</code>, and <code>PyTime::new_with_fold</code>. <a href="https://github.com/PyO3/pyo3/pull/1588">#1588</a></li>
<li>Move <code>PyTypeObject::type_object</code> method to the <code>PyTypeInfo</code> trait, and deprecate the <code>PyTypeObject</code> trait. <a href="https://github.com/PyO3/pyo3/pull/2287">#2287</a></li>
<li>Methods of <code>Py</code> and <code>PyAny</code> now accept <code>impl IntoPy&lt;Py&lt;PyString&gt;&gt;</code> rather than just <code>&amp;str</code> to allow use of the <code>intern!</code> macro. <a href="https://github.com/PyO3/pyo3/pull/2312">#2312</a></li>
<li>Change the deprecated <code>pyproto</code> feature to be opt-in instead of opt-out. <a href="https://github.com/PyO3/pyo3/pull/2322">#2322</a></li>
<li>Emit better error messages when <code>#[pyfunction]</code> return types do not implement <code>IntoPy</code>. <a href="https://github.com/PyO3/pyo3/pull/2326">#2326</a></li>
<li>Require <code>T: IntoPy</code> for <code>impl&lt;T, const N: usize&gt; IntoPy&lt;PyObject&gt; for [T; N]</code> instead of <code>T: ToPyObject</code>. <a href="https://github.com/PyO3/pyo3/pull/2326">#2326</a></li>
<li>Deprecate the <code>ToBorrowedObject</code> trait. <a href="https://github.com/PyO3/pyo3/pull/2333">#2333</a></li>
<li>Iterators over <code>PySet</code> and <code>PyDict</code> will now panic if the underlying collection is mutated during the iteration. <a href="https://github.com/PyO3/pyo3/pull/2380">#2380</a></li>
<li>Iterators over <code>PySet</code> and <code>PyDict</code> will now panic if the underlying collection is mutated during the iteration. <a href="https://github.com/PyO3/pyo3/pull/2380">#2380</a></li>
<li>Allow <code>#[classattr]</code> methods to be fallible. <a href="https://github.com/PyO3/pyo3/pull/2385">#2385</a></li>
<li>Prevent multiple <code>#[pymethods]</code> with the same name for a single <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/2399">#2399</a></li>
<li>Fixup <code>lib_name</code> when using <code>PYO3_CONFIG_FILE</code>. <a href="https://github.com/PyO3/pyo3/pull/2404">#2404</a></li>
<li>Add a message to the <code>ValueError</code> raised by the <code>#[derive(FromPyObject)]</code> implementation for a tuple struct. <a href="https://github.com/PyO3/pyo3/pull/2414">#2414</a></li>
<li>Allow <code>#[classattr]</code> methods to take <code>Python</code> argument. <a href="https://github.com/PyO3/pyo3/pull/2456">#2456</a></li>
<li>Rework <code>PyCapsule</code> type to resolve soundness issues: <a href="https://github.com/PyO3/pyo3/pull/2485">#2485</a>
<ul>
<li><code>PyCapsule::new</code> and <code>PyCapsule::new_with_destructor</code> now take <code>name: Option&lt;CString&gt;</code> instead of <code>&amp;CStr</code>.</li>
<li>The destructor <code>F</code> in <code>PyCapsule::new_with_destructor</code> must now be <code>Send</code>.</li>
<li><code>PyCapsule::get_context</code> deprecated in favor of <code>PyCapsule::context</code> which doesn't take a <code>py: Python&lt;'_&gt;</code> argument.</li>
<li><code>PyCapsule::set_context</code> no longer takes a <code>py: Python&lt;'_&gt;</code> argument.</li>
<li><code>PyCapsule::name</code> now returns <code>PyResult&lt;Option&lt;&amp;CStr&gt;&gt;</code> instead of <code>&amp;CStr</code>.</li>
</ul>
</li>
<li><code>FromPyObject::extract</code> for <code>Vec&lt;T&gt;</code> no longer accepts Python <code>str</code> inputs. <a href="https://github.com/PyO3/pyo3/pull/2500">#2500</a></li>
<li>Ensure each <code>#[pymodule]</code> is only initialized once. <a href="https://github.com/PyO3/pyo3/pull/2523">#2523</a></li>
<li><code>pyo3_build_config::add_extension_module_link_args</code> now also emits linker arguments for <code>wasm32-unknown-emscripten</code>. <a href="https://github.com/PyO3/pyo3/pull/2538">#2538</a></li>
<li>Type checks for <code>PySequence</code> and <code>PyMapping</code> now require inputs to inherit from (or register with) <code>collections.abc.Sequence</code> and <code>collections.abc.Mapping</code> respectively. <a href="https://github.com/PyO3/pyo3/pull/2477">#2477</a></li>
<li>Disable <code>PyFunction</code> on when building for abi3 or PyPy. <a href="https://github.com/PyO3/pyo3/pull/2542">#2542</a></li>
<li>Deprecate <code>Python::acquire_gil</code>. <a href="https://github.com/PyO3/pyo3/pull/2549">#2549</a></li>
</ul>
<h3 id="removed-4"><a class="header" href="#removed-4">Removed</a></h3>
<ul>
<li>Remove all functionality deprecated in PyO3 0.15. <a href="https://github.com/PyO3/pyo3/pull/2283">#2283</a></li>
<li>Make the <code>Dict</code>, <code>WeakRef</code> and <code>BaseNativeType</code> members of the <code>PyClass</code> private implementation details. <a href="https://github.com/PyO3/pyo3/pull/2572">#2572</a></li>
</ul>
<h3 id="fixed-17"><a class="header" href="#fixed-17">Fixed</a></h3>
<ul>
<li>Enable incorrectly disabled FFI definition <code>PyThreadState_DeleteCurrent</code>. <a href="https://github.com/PyO3/pyo3/pull/2357">#2357</a></li>
<li>Fix <code>wrap_pymodule</code> interactions with name resolution rules: it no longer "sees through" glob imports of <code>use submodule::*</code> when <code>submodule::submodule</code> is a <code>#[pymodule]</code>. <a href="https://github.com/PyO3/pyo3/pull/2363">#2363</a></li>
<li>Correct FFI definition <code>PyEval_EvalCodeEx</code> to take <code>*const *mut PyObject</code> array arguments instead of <code>*mut *mut PyObject</code>. <a href="https://github.com/PyO3/pyo3/pull/2368">#2368</a></li>
<li>Fix "raw-ident" structs (e.g. <code>#[pyclass] struct r#RawName</code>) incorrectly having <code>r#</code> at the start of the class name created in Python. <a href="https://github.com/PyO3/pyo3/pull/2395">#2395</a></li>
<li>Correct FFI definition <code>Py_tracefunc</code> to be <code>unsafe extern "C" fn</code> (was previously safe). <a href="https://github.com/PyO3/pyo3/pull/2407">#2407</a></li>
<li>Fix compile failure with <code>#[pyo3(from_py_with = "...")]</code> annotations on a field in a <code>#[derive(FromPyObject)]</code> struct. <a href="https://github.com/PyO3/pyo3/pull/2414">#2414</a></li>
<li>Fix FFI definitions <code>_PyDateTime_BaseTime</code> and <code>_PyDateTime_BaseDateTime</code> lacking leading underscores in their names. <a href="https://github.com/PyO3/pyo3/pull/2421">#2421</a></li>
<li>Remove FFI definition <code>PyArena</code> on Python 3.10 and up. <a href="https://github.com/PyO3/pyo3/pull/2421">#2421</a></li>
<li>Fix FFI definition <code>PyCompilerFlags</code> missing member <code>cf_feature_version</code> on Python 3.8 and up. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PyAsyncMethods</code> missing member <code>am_send</code> on Python 3.10 and up. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PyGenObject</code> having multiple incorrect members on various Python versions. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PySyntaxErrorObject</code> missing members <code>end_lineno</code> and <code>end_offset</code> on Python 3.10 and up. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PyHeapTypeObject</code> missing member <code>ht_module</code> on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/2423">#2423</a></li>
<li>Fix FFI definition <code>PyFrameObject</code> having multiple incorrect members on various Python versions. <a href="https://github.com/PyO3/pyo3/pull/2424">#2424</a> <a href="https://github.com/PyO3/pyo3/pull/2434">#2434</a></li>
<li>Fix FFI definition <code>PyTypeObject</code> missing deprecated field <code>tp_print</code> on Python 3.8. <a href="https://github.com/PyO3/pyo3/pull/2428">#2428</a></li>
<li>Fix FFI definitions <code>PyDateTime_CAPI</code>. <code>PyDateTime_Date</code>, <code>PyASCIIObject</code>, <code>PyBaseExceptionObject</code>, <code>PyListObject</code>, and <code>PyTypeObject</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/2428">#2428</a></li>
<li>Fix FFI definition <code>_inittab</code> field <code>initfunc</code> typo'd as <code>initfun</code>. <a href="https://github.com/PyO3/pyo3/pull/2431">#2431</a></li>
<li>Fix FFI definitions <code>_PyDateTime_BaseTime</code> and <code>_PyDateTime_BaseDateTime</code> incorrectly having <code>fold</code> member. <a href="https://github.com/PyO3/pyo3/pull/2432">#2432</a></li>
<li>Fix FFI definitions <code>PyTypeObject</code>. <code>PyHeapTypeObject</code>, and <code>PyCFunctionObject</code> having incorrect members on PyPy 3.9. <a href="https://github.com/PyO3/pyo3/pull/2433">#2433</a></li>
<li>Fix FFI definition <code>PyGetSetDef</code> to have <code>*const c_char</code> for <code>doc</code> member (not <code>*mut c_char</code>). <a href="https://github.com/PyO3/pyo3/pull/2439">#2439</a></li>
<li>Fix <code>#[pyo3(from_py_with = "...")]</code> being ignored for 1-element tuple structs and transparent structs. <a href="https://github.com/PyO3/pyo3/pull/2440">#2440</a></li>
<li>Use <code>memoffset</code> to avoid UB when computing <code>PyCell</code> layout. <a href="https://github.com/PyO3/pyo3/pull/2450">#2450</a></li>
<li>Fix incorrect enum names being returned by the generated <code>repr</code> for enums renamed by <code>#[pyclass(name = "...")]</code> <a href="https://github.com/PyO3/pyo3/pull/2457">#2457</a></li>
<li>Fix <code>PyObject_CallNoArgs</code> incorrectly being available when building for abi3 on Python 3.9. <a href="https://github.com/PyO3/pyo3/pull/2476">#2476</a></li>
<li>Fix several clippy warnings generated by <code>#[pyfunction]</code> arguments. <a href="https://github.com/PyO3/pyo3/pull/2503">#2503</a></li>
</ul>
<h2 id="0166---2022-08-23"><a class="header" href="#0166---2022-08-23"><a href="https://github.com/pyo3/pyo3/compare/v0.16.5...v0.16.6">0.16.6</a> - 2022-08-23</a></h2>
<h3 id="changed-10"><a class="header" href="#changed-10">Changed</a></h3>
<ul>
<li>Fix soundness issues with <code>PyCapsule</code> type with select workarounds. Users are encourage to upgrade to PyO3 0.17 at their earliest convenience which contains API breakages which fix the issues in a long-term fashion. <a href="https://github.com/PyO3/pyo3/pull/2522">#2522</a>
<ul>
<li><code>PyCapsule::new</code> and <code>PyCapsule::new_with_destructor</code> now take ownership of a copy of the <code>name</code> to resolve a possible use-after-free.</li>
<li><code>PyCapsule::name</code> now returns an empty <code>CStr</code> instead of dereferencing a null pointer if the capsule has no name.</li>
<li>The destructor <code>F</code> in <code>PyCapsule::new_with_destructor</code> will never be called if the capsule is deleted from a thread other than the one which the capsule was created in (a warning will be emitted).</li>
</ul>
</li>
<li>Panics during drop of panic payload caught by PyO3 will now abort. <a href="https://github.com/PyO3/pyo3/pull/2544">#2544</a></li>
</ul>
<h2 id="0165---2022-05-15"><a class="header" href="#0165---2022-05-15"><a href="https://github.com/pyo3/pyo3/compare/v0.16.4...v0.16.5">0.16.5</a> - 2022-05-15</a></h2>
<h3 id="added-14"><a class="header" href="#added-14">Added</a></h3>
<ul>
<li>Add an experimental <code>generate-import-lib</code> feature to support auto-generating non-abi3 python import libraries for Windows targets. <a href="https://github.com/PyO3/pyo3/pull/2364">#2364</a></li>
<li>Add FFI definition <code>Py_ExitStatusException</code>. <a href="https://github.com/PyO3/pyo3/pull/2374">#2374</a></li>
</ul>
<h3 id="changed-11"><a class="header" href="#changed-11">Changed</a></h3>
<ul>
<li>Deprecate experimental <code>generate-abi3-import-lib</code> feature in favor of the new <code>generate-import-lib</code> feature. <a href="https://github.com/PyO3/pyo3/pull/2364">#2364</a></li>
</ul>
<h3 id="fixed-18"><a class="header" href="#fixed-18">Fixed</a></h3>
<ul>
<li>Added missing <code>warn_default_encoding</code> field to <code>PyConfig</code> on 3.10+. The previously missing field could result in incorrect behavior or crashes. <a href="https://github.com/PyO3/pyo3/pull/2370">#2370</a></li>
<li>Fixed order of <code>pathconfig_warnings</code> and <code>program_name</code> fields of <code>PyConfig</code> on 3.10+. Previously, the order of the fields was swapped and this could lead to incorrect behavior or crashes. <a href="https://github.com/PyO3/pyo3/pull/2370">#2370</a></li>
</ul>
<h2 id="0164---2022-04-14"><a class="header" href="#0164---2022-04-14"><a href="https://github.com/pyo3/pyo3/compare/v0.16.3...v0.16.4">0.16.4</a> - 2022-04-14</a></h2>
<h3 id="added-15"><a class="header" href="#added-15">Added</a></h3>
<ul>
<li>Add <code>PyTzInfoAccess</code> trait for safe access to time zone information. <a href="https://github.com/PyO3/pyo3/pull/2263">#2263</a></li>
<li>Add an experimental <code>generate-abi3-import-lib</code> feature to auto-generate <code>python3.dll</code> import libraries for Windows. <a href="https://github.com/PyO3/pyo3/pull/2282">#2282</a></li>
<li>Add FFI definitions for <code>PyDateTime_BaseTime</code> and <code>PyDateTime_BaseDateTime</code>. <a href="https://github.com/PyO3/pyo3/pull/2294">#2294</a></li>
</ul>
<h3 id="changed-12"><a class="header" href="#changed-12">Changed</a></h3>
<ul>
<li>Improved performance of failing calls to <code>FromPyObject::extract</code> which is common when functions accept multiple distinct types. <a href="https://github.com/PyO3/pyo3/pull/2279">#2279</a></li>
<li>Default to "m" ABI tag when choosing <code>libpython</code> link name for CPython 3.7 on Unix. <a href="https://github.com/PyO3/pyo3/pull/2288">#2288</a></li>
<li>Allow to compile "abi3" extensions without a working build host Python interpreter. <a href="https://github.com/PyO3/pyo3/pull/2293">#2293</a></li>
</ul>
<h3 id="fixed-19"><a class="header" href="#fixed-19">Fixed</a></h3>
<ul>
<li>Crates depending on PyO3 can collect code coverage via LLVM instrumentation using stable Rust. <a href="https://github.com/PyO3/pyo3/pull/2286">#2286</a></li>
<li>Fix segfault when calling FFI methods <code>PyDateTime_DATE_GET_TZINFO</code> or <code>PyDateTime_TIME_GET_TZINFO</code> on <code>datetime</code> or <code>time</code> without a tzinfo. <a href="https://github.com/PyO3/pyo3/pull/2289">#2289</a></li>
<li>Fix directory names starting with the letter <code>n</code> breaking serialization of the interpreter configuration on Windows since PyO3 0.16.3. <a href="https://github.com/PyO3/pyo3/pull/2299">#2299</a></li>
</ul>
<h2 id="0163---2022-04-05"><a class="header" href="#0163---2022-04-05"><a href="https://github.com/pyo3/pyo3/compare/v0.16.2...v0.16.3">0.16.3</a> - 2022-04-05</a></h2>
<h3 id="packaging-10"><a class="header" href="#packaging-10">Packaging</a></h3>
<ul>
<li>Extend <code>parking_lot</code> dependency supported versions to include 0.12. <a href="https://github.com/PyO3/pyo3/pull/2239">#2239</a></li>
</ul>
<h3 id="added-16"><a class="header" href="#added-16">Added</a></h3>
<ul>
<li>Add methods to <code>pyo3_build_config::InterpreterConfig</code> to run Python scripts using the configured executable. <a href="https://github.com/PyO3/pyo3/pull/2092">#2092</a></li>
<li>Add <code>as_bytes</code> method to <code>Py&lt;PyBytes&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/2235">#2235</a></li>
<li>Add FFI definitions for <code>PyType_FromModuleAndSpec</code>, <code>PyType_GetModule</code>, <code>PyType_GetModuleState</code> and <code>PyModule_AddType</code>. <a href="https://github.com/PyO3/pyo3/pull/2250">#2250</a></li>
<li>Add <code>pyo3_build_config::cross_compiling_from_to</code> as a helper to detect when PyO3 is cross-compiling. <a href="https://github.com/PyO3/pyo3/pull/2253">#2253</a></li>
<li>Add <code>#[pyclass(mapping)]</code> option to leave sequence slots empty in container implementations. <a href="https://github.com/PyO3/pyo3/pull/2265">#2265</a></li>
<li>Add <code>PyString::intern</code> to enable usage of the Python's built-in string interning. <a href="https://github.com/PyO3/pyo3/pull/2268">#2268</a></li>
<li>Add <code>intern!</code> macro which can be used to amortize the cost of creating Python strings by storing them inside a <code>GILOnceCell</code>. <a href="https://github.com/PyO3/pyo3/pull/2269">#2269</a></li>
<li>Add <code>PYO3_CROSS_PYTHON_IMPLEMENTATION</code> environment variable for selecting the default cross Python implementation. <a href="https://github.com/PyO3/pyo3/pull/2272">#2272</a></li>
</ul>
<h3 id="changed-13"><a class="header" href="#changed-13">Changed</a></h3>
<ul>
<li>Allow <code>#[pyo3(crate = "...", text_signature = "...")]</code> options to be used directly in <code>#[pyclass(crate = "...", text_signature = "...")]</code>. <a href="https://github.com/PyO3/pyo3/pull/2234">#2234</a></li>
<li>Make <code>PYO3_CROSS_LIB_DIR</code> environment variable optional when cross compiling. <a href="https://github.com/PyO3/pyo3/pull/2241">#2241</a></li>
<li>Mark <code>METH_FASTCALL</code> calling convention as limited API on Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/2250">#2250</a></li>
<li>Deprecate <code>pyo3_build_config::cross_compiling</code> in favor of <code>pyo3_build_config::cross_compiling_from_to</code>. <a href="https://github.com/PyO3/pyo3/pull/2253">#2253</a></li>
</ul>
<h3 id="fixed-20"><a class="header" href="#fixed-20">Fixed</a></h3>
<ul>
<li>Fix <code>abi3-py310</code> feature: use Python 3.10 ABI when available instead of silently falling back to the 3.9 ABI. <a href="https://github.com/PyO3/pyo3/pull/2242">#2242</a></li>
<li>Use shared linking mode when cross compiling against a <a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html">Framework bundle</a> for macOS. <a href="https://github.com/PyO3/pyo3/pull/2233">#2233</a></li>
<li>Fix panic during compilation when <code>PYO3_CROSS_LIB_DIR</code> is set for some host/target combinations. <a href="https://github.com/PyO3/pyo3/pull/2232">#2232</a></li>
<li>Correct dependency version for <code>syn</code> to require minimal patch version 1.0.56. <a href="https://github.com/PyO3/pyo3/pull/2240">#2240</a></li>
</ul>
<h2 id="0162---2022-03-15"><a class="header" href="#0162---2022-03-15"><a href="https://github.com/pyo3/pyo3/compare/v0.16.1...v0.16.2">0.16.2</a> - 2022-03-15</a></h2>
<h3 id="packaging-11"><a class="header" href="#packaging-11">Packaging</a></h3>
<ul>
<li>Warn when modules are imported on PyPy 3.7 versions older than PyPy 7.3.8, as they are known to have binary compatibility issues. <a href="https://github.com/PyO3/pyo3/pull/2217">#2217</a></li>
<li>Ensure build script of <code>pyo3-ffi</code> runs before that of <code>pyo3</code> to fix cross compilation. <a href="https://github.com/PyO3/pyo3/pull/2224">#2224</a></li>
</ul>
<h2 id="0161---2022-03-05"><a class="header" href="#0161---2022-03-05"><a href="https://github.com/pyo3/pyo3/compare/v0.16.0...v0.16.1">0.16.1</a> - 2022-03-05</a></h2>
<h3 id="packaging-12"><a class="header" href="#packaging-12">Packaging</a></h3>
<ul>
<li>Extend <code>hashbrown</code> optional dependency supported versions to include 0.12. <a href="https://github.com/PyO3/pyo3/pull/2197">#2197</a></li>
</ul>
<h3 id="fixed-21"><a class="header" href="#fixed-21">Fixed</a></h3>
<ul>
<li>Fix incorrect platform detection for Windows in <code>pyo3-build-config</code>. <a href="https://github.com/PyO3/pyo3/pull/2198">#2198</a></li>
<li>Fix regression from 0.16 preventing cross compiling to aarch64 macOS. <a href="https://github.com/PyO3/pyo3/pull/2201">#2201</a></li>
</ul>
<h2 id="0160---2022-02-27"><a class="header" href="#0160---2022-02-27"><a href="https://github.com/pyo3/pyo3/compare/v0.15.1...v0.16.0">0.16.0</a> - 2022-02-27</a></h2>
<h3 id="packaging-13"><a class="header" href="#packaging-13">Packaging</a></h3>
<ul>
<li>Update MSRV to Rust 1.48. <a href="https://github.com/PyO3/pyo3/pull/2004">#2004</a></li>
<li>Update <code>indoc</code> optional dependency to 1.0. <a href="https://github.com/PyO3/pyo3/pull/2004">#2004</a></li>
<li>Drop support for Python 3.6, remove <code>abi3-py36</code> feature. <a href="https://github.com/PyO3/pyo3/pull/2006">#2006</a></li>
<li><code>pyo3-build-config</code> no longer enables the <code>resolve-config</code> feature by default. <a href="https://github.com/PyO3/pyo3/pull/2008">#2008</a></li>
<li>Update <code>inventory</code> optional dependency to 0.2. <a href="https://github.com/PyO3/pyo3/pull/2019">#2019</a></li>
<li>Drop <code>paste</code> dependency. <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a></li>
<li>The bindings found in <code>pyo3::ffi</code> are now a re-export of a separate <code>pyo3-ffi</code> crate. <a href="https://github.com/PyO3/pyo3/pull/2126">#2126</a></li>
<li>Support PyPy 3.9. <a href="https://github.com/PyO3/pyo3/pull/2143">#2143</a></li>
</ul>
<h3 id="added-17"><a class="header" href="#added-17">Added</a></h3>
<ul>
<li>Add <code>PyCapsule</code> type exposing the <a href="https://docs.python.org/3/c-api/capsule.html#capsules">Capsule API</a>. <a href="https://github.com/PyO3/pyo3/pull/1980">#1980</a></li>
<li>Add <code>pyo3_build_config::Sysconfigdata</code> and supporting APIs. <a href="https://github.com/PyO3/pyo3/pull/1996">#1996</a></li>
<li>Add <code>Py::setattr</code> method. <a href="https://github.com/PyO3/pyo3/pull/2009">#2009</a></li>
<li>Add <code>#[pyo3(crate = "some::path")]</code> option to all attribute macros (except the deprecated <code>#[pyproto]</code>). <a href="https://github.com/PyO3/pyo3/pull/2022">#2022</a></li>
<li>Enable <code>create_exception!</code> macro to take an optional docstring. <a href="https://github.com/PyO3/pyo3/pull/2027">#2027</a></li>
<li>Enable <code>#[pyclass]</code> for fieldless (aka C-like) enums. <a href="https://github.com/PyO3/pyo3/pull/2034">#2034</a></li>
<li>Add buffer magic methods <code>__getbuffer__</code> and <code>__releasebuffer__</code> to <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2067">#2067</a></li>
<li>Add support for paths in <code>wrap_pyfunction</code> and <code>wrap_pymodule</code>. <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a></li>
<li>Enable <code>wrap_pyfunction!</code> to wrap a <code>#[pyfunction]</code> implemented in a different Rust module or crate. <a href="https://github.com/PyO3/pyo3/pull/2091">#2091</a></li>
<li>Add <code>PyAny::contains</code> method (<code>in</code> operator for <code>PyAny</code>). <a href="https://github.com/PyO3/pyo3/pull/2115">#2115</a></li>
<li>Add <code>PyMapping::contains</code> method (<code>in</code> operator for <code>PyMapping</code>). <a href="https://github.com/PyO3/pyo3/pull/2133">#2133</a></li>
<li>Add garbage collection magic magic methods <code>__traverse__</code> and <code>__clear__</code> to <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2159">#2159</a></li>
<li>Add support for <code>from_py_with</code> on struct tuples and enums to override the default from-Python conversion. <a href="https://github.com/PyO3/pyo3/pull/2181">#2181</a></li>
<li>Add <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code> methods to <code>PyAny</code> that wrap <code>rich_compare</code>. <a href="https://github.com/PyO3/pyo3/pull/2175">#2175</a></li>
<li>Add <code>Py::is</code> and <code>PyAny::is</code> methods to check for object identity. <a href="https://github.com/PyO3/pyo3/pull/2183">#2183</a></li>
<li>Add support for the <code>__getattribute__</code> magic method. <a href="https://github.com/PyO3/pyo3/pull/2187">#2187</a></li>
</ul>
<h3 id="changed-14"><a class="header" href="#changed-14">Changed</a></h3>
<ul>
<li><code>PyType::is_subclass</code>, <code>PyErr::is_instance</code> and <code>PyAny::is_instance</code> now operate run-time type object instead of a type known at compile-time. The old behavior is still available as <code>PyType::is_subclass_of</code>, <code>PyErr::is_instance_of</code> and <code>PyAny::is_instance_of</code>.  <a href="https://github.com/PyO3/pyo3/pull/1985">#1985</a></li>
<li>Rename some methods on <code>PyErr</code> (the old names are just marked deprecated for now): <a href="https://github.com/PyO3/pyo3/pull/2026">#2026</a>
<ul>
<li><code>pytype</code> -&gt; <code>get_type</code></li>
<li><code>pvalue</code> -&gt; <code>value</code> (and deprecate equivalent <code>instance</code>)</li>
<li><code>ptraceback</code> -&gt; <code>traceback</code></li>
<li><code>from_instance</code> -&gt; <code>from_value</code></li>
<li><code>into_instance</code> -&gt; <code>into_value</code></li>
</ul>
</li>
<li><code>PyErr::new_type</code> now takes an optional docstring and now returns <code>PyResult&lt;Py&lt;PyType&gt;&gt;</code> rather than a <code>ffi::PyTypeObject</code> pointer. <a href="https://github.com/PyO3/pyo3/pull/2027">#2027</a></li>
<li>Deprecate <code>PyType::is_instance</code>; it is inconsistent with other <code>is_instance</code> methods in PyO3. Instead of <code>typ.is_instance(obj)</code>, use <code>obj.is_instance(typ)</code>. <a href="https://github.com/PyO3/pyo3/pull/2031">#2031</a></li>
<li><code>__getitem__</code>, <code>__setitem__</code> and <code>__delitem__</code> in <code>#[pymethods]</code> now implement both a Python mapping and sequence by default. <a href="https://github.com/PyO3/pyo3/pull/2065">#2065</a></li>
<li>Improve performance and error messages for <code>#[derive(FromPyObject)]</code> for enums. <a href="https://github.com/PyO3/pyo3/pull/2068">#2068</a></li>
<li>Reduce generated LLVM code size (to improve compile times) for:
<ul>
<li>internal <code>handle_panic</code> helper <a href="https://github.com/PyO3/pyo3/pull/2074">#2074</a> <a href="https://github.com/PyO3/pyo3/pull/2158">#2158</a></li>
<li><code>#[pyfunction]</code> and <code>#[pymethods]</code> argument extraction <a href="https://github.com/PyO3/pyo3/pull/2075">#2075</a> <a href="https://github.com/PyO3/pyo3/pull/2085">#2085</a></li>
<li><code>#[pyclass]</code> type object creation <a href="https://github.com/PyO3/pyo3/pull/2076">#2076</a> <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a> <a href="https://github.com/PyO3/pyo3/pull/2157">#2157</a></li>
</ul>
</li>
<li>Respect Rust privacy rules for items wrapped with <code>wrap_pyfunction</code> and <code>wrap_pymodule</code>. <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a></li>
<li>Add modulo argument to <code>__ipow__</code> magic method. <a href="https://github.com/PyO3/pyo3/pull/2083">#2083</a></li>
<li>Fix FFI definition for <code>_PyCFunctionFast</code>. <a href="https://github.com/PyO3/pyo3/pull/2126">#2126</a></li>
<li><code>PyDateTimeAPI</code> and <code>PyDateTime_TimeZone_UTC</code> are now unsafe functions instead of statics. <a href="https://github.com/PyO3/pyo3/pull/2126">#2126</a></li>
<li><code>PyDateTimeAPI</code> does not implicitly call <code>PyDateTime_IMPORT</code> anymore to reflect the original Python API more closely. Before the first call to <code>PyDateTime_IMPORT</code> a null pointer is returned. Therefore before calling any of the following FFI functions <code>PyDateTime_IMPORT</code> must be called to avoid undefined behavior: <a href="https://github.com/PyO3/pyo3/pull/2126">#2126</a>
<ul>
<li><code>PyDateTime_TimeZone_UTC</code></li>
<li><code>PyDate_Check</code></li>
<li><code>PyDate_CheckExact</code></li>
<li><code>PyDateTime_Check</code></li>
<li><code>PyDateTime_CheckExact</code></li>
<li><code>PyTime_Check</code></li>
<li><code>PyTime_CheckExact</code></li>
<li><code>PyDelta_Check</code></li>
<li><code>PyDelta_CheckExact</code></li>
<li><code>PyTZInfo_Check</code></li>
<li><code>PyTZInfo_CheckExact</code></li>
<li><code>PyDateTime_FromTimestamp</code></li>
<li><code>PyDate_FromTimestamp</code></li>
</ul>
</li>
<li>Deprecate the <code>gc</code> option for <code>pyclass</code> (e.g. <code>#[pyclass(gc)]</code>). Just implement a <code>__traverse__</code> <code>#[pymethod]</code>. <a href="https://github.com/PyO3/pyo3/pull/2159">#2159</a></li>
<li>The <code>ml_meth</code> field of <code>PyMethodDef</code> is now represented by the <code>PyMethodDefPointer</code> union. <a href="https://github.com/PyO3/pyo3/pull/2166">2166</a></li>
<li>Deprecate the <code>#[pyproto]</code> traits. <a href="https://github.com/PyO3/pyo3/pull/2173">#2173</a></li>
</ul>
<h3 id="removed-5"><a class="header" href="#removed-5">Removed</a></h3>
<ul>
<li>Remove all functionality deprecated in PyO3 0.14. <a href="https://github.com/PyO3/pyo3/pull/2007">#2007</a></li>
<li>Remove <code>Default</code> impl for <code>PyMethodDef</code>. <a href="https://github.com/PyO3/pyo3/pull/2166">#2166</a></li>
<li>Remove <code>PartialEq</code> impl for <code>Py</code> and <code>PyAny</code> (use the new <code>is</code> instead). <a href="https://github.com/PyO3/pyo3/pull/2183">#2183</a></li>
</ul>
<h3 id="fixed-22"><a class="header" href="#fixed-22">Fixed</a></h3>
<ul>
<li>Fix undefined symbol for <code>PyObject_HasAttr</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/2025">#2025</a></li>
<li>Fix memory leak in <code>PyErr::into_value</code>. <a href="https://github.com/PyO3/pyo3/pull/2026">#2026</a></li>
<li>Fix clippy warning <code>needless-option-as-deref</code> in code generated by <code>#[pyfunction]</code> and <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/2040">#2040</a></li>
<li>Fix undefined behavior in <code>PySlice::indices</code>. <a href="https://github.com/PyO3/pyo3/pull/2061">#2061</a></li>
<li>Fix the <code>wrap_pymodule!</code> macro using the wrong name for a <code>#[pymodule]</code> with a <code>#[pyo3(name = "..")]</code> attribute. <a href="https://github.com/PyO3/pyo3/pull/2081">#2081</a></li>
<li>Fix magic methods in <code>#[pymethods]</code> accepting implementations with the wrong number of arguments. <a href="https://github.com/PyO3/pyo3/pull/2083">#2083</a></li>
<li>Fix panic in <code>#[pyfunction]</code> generated code when a required argument following an <code>Option</code> was not provided.  <a href="https://github.com/PyO3/pyo3/pull/2093">#2093</a></li>
<li>Fixed undefined behavior caused by incorrect <code>ExactSizeIterator</code> implementations. <a href="https://github.com/PyO3/pyo3/pull/2124">#2124</a></li>
<li>Fix missing FFI definition <code>PyCMethod_New</code> on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/2143">#2143</a></li>
<li>Add missing FFI definitions <code>_PyLong_NumBits</code> and <code>_PyLong_AsByteArray</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/2146">#2146</a></li>
<li>Fix memory leak in implementation of <code>AsPyPointer</code> for <code>Option&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/2160">#2160</a></li>
<li>Fix FFI definition of <code>_PyLong_NumBits</code> to return <code>size_t</code> instead of <code>c_int</code>. <a href="https://github.com/PyO3/pyo3/pull/2161">#2161</a></li>
<li>Fix <code>TypeError</code> thrown when argument parsing failed missing the originating causes. <a href="https://github.com/PyO3/pyo3/pull/2178">2177</a></li>
</ul>
<h2 id="0152---2022-04-14"><a class="header" href="#0152---2022-04-14"><a href="https://github.com/pyo3/pyo3/compare/v0.15.1...v0.15.2">0.15.2</a> - 2022-04-14</a></h2>
<h3 id="packaging-14"><a class="header" href="#packaging-14">Packaging</a></h3>
<ul>
<li>Backport of PyPy 3.9 support from PyO3 0.16. <a href="https://github.com/PyO3/pyo3/pull/2262">#2262</a></li>
</ul>
<h2 id="0151---2021-11-19"><a class="header" href="#0151---2021-11-19"><a href="https://github.com/pyo3/pyo3/compare/v0.15.0...v0.15.1">0.15.1</a> - 2021-11-19</a></h2>
<h3 id="added-18"><a class="header" href="#added-18">Added</a></h3>
<ul>
<li>Add implementations for <code>Py::as_ref</code> and <code>Py::into_ref</code> for <code>Py&lt;PySequence&gt;</code>, <code>Py&lt;PyIterator&gt;</code> and <code>Py&lt;PyMapping&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1682">#1682</a></li>
<li>Add <code>PyTraceback</code> type to represent and format Python tracebacks. <a href="https://github.com/PyO3/pyo3/pull/1977">#1977</a></li>
</ul>
<h3 id="changed-15"><a class="header" href="#changed-15">Changed</a></h3>
<ul>
<li><code>#[classattr]</code> constants with a known magic method name (which is lowercase) no longer trigger lint warnings expecting constants to be uppercase. <a href="https://github.com/PyO3/pyo3/pull/1969">#1969</a></li>
</ul>
<h3 id="fixed-23"><a class="header" href="#fixed-23">Fixed</a></h3>
<ul>
<li>Fix creating <code>#[classattr]</code> by functions with the name of a known magic method. <a href="https://github.com/PyO3/pyo3/pull/1969">#1969</a></li>
<li>Fix use of <code>catch_unwind</code> in <code>allow_threads</code> which can cause fatal crashes. <a href="https://github.com/PyO3/pyo3/pull/1989">#1989</a></li>
<li>Fix build failure on PyPy when abi3 features are activated. <a href="https://github.com/PyO3/pyo3/pull/1991">#1991</a></li>
<li>Fix mingw platform detection. <a href="https://github.com/PyO3/pyo3/pull/1993">#1993</a></li>
<li>Fix panic in <code>__get__</code> implementation when accessing descriptor on type object. <a href="https://github.com/PyO3/pyo3/pull/1997">#1997</a></li>
</ul>
<h2 id="0150---2021-11-03"><a class="header" href="#0150---2021-11-03"><a href="https://github.com/pyo3/pyo3/compare/v0.14.5...v0.15.0">0.15.0</a> - 2021-11-03</a></h2>
<h3 id="packaging-15"><a class="header" href="#packaging-15">Packaging</a></h3>
<ul>
<li><code>pyo3</code>'s <code>Cargo.toml</code> now advertises <code>links = "python"</code> to inform Cargo that it links against <em>libpython</em>. <a href="https://github.com/PyO3/pyo3/pull/1819">#1819</a></li>
<li>Added optional <code>anyhow</code> feature to convert <code>anyhow::Error</code> into <code>PyErr</code>. <a href="https://github.com/PyO3/pyo3/pull/1822">#1822</a></li>
<li>Support Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1889">#1889</a></li>
<li>Added optional <code>eyre</code> feature to convert <code>eyre::Report</code> into <code>PyErr</code>. <a href="https://github.com/PyO3/pyo3/pull/1893">#1893</a></li>
<li>Support PyPy 3.8. <a href="https://github.com/PyO3/pyo3/pull/1948">#1948</a></li>
</ul>
<h3 id="added-19"><a class="header" href="#added-19">Added</a></h3>
<ul>
<li>Add <code>PyList::get_item_unchecked</code> and <code>PyTuple::get_item_unchecked</code> to get items without bounds checks. <a href="https://github.com/PyO3/pyo3/pull/1733">#1733</a></li>
<li>Support <code>#[doc = include_str!(...)]</code> attributes on Rust 1.54 and up. <a href="https://github.com/PyO3/pyo3/issues/1746">#1746</a></li>
<li>Add <code>PyAny::py</code> as a convenience for <code>PyNativeType::py</code>. <a href="https://github.com/PyO3/pyo3/pull/1751">#1751</a></li>
<li>Add implementation of <code>std::ops::Index&lt;usize&gt;</code> for <code>PyList</code>, <code>PyTuple</code> and <code>PySequence</code>. <a href="https://github.com/PyO3/pyo3/pull/1825">#1825</a></li>
<li>Add range indexing implementations of <code>std::ops::Index</code> for <code>PyList</code>, <code>PyTuple</code> and <code>PySequence</code>. <a href="https://github.com/PyO3/pyo3/pull/1829">#1829</a></li>
<li>Add <code>PyMapping</code> type to represent the Python mapping protocol. <a href="https://github.com/PyO3/pyo3/pull/1844">#1844</a></li>
<li>Add commonly-used sequence methods to <code>PyList</code> and <code>PyTuple</code>. <a href="https://github.com/PyO3/pyo3/pull/1849">#1849</a></li>
<li>Add <code>as_sequence</code> methods to <code>PyList</code> and <code>PyTuple</code>. <a href="https://github.com/PyO3/pyo3/pull/1860">#1860</a></li>
<li>Add support for magic methods in <code>#[pymethods]</code>, intended as a replacement for <code>#[pyproto]</code>. <a href="https://github.com/PyO3/pyo3/pull/1864">#1864</a></li>
<li>Add <code>abi3-py310</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1889">#1889</a></li>
<li>Add <code>PyCFunction::new_closure</code> to create a Python function from a Rust closure. <a href="https://github.com/PyO3/pyo3/pull/1901">#1901</a></li>
<li>Add support for positional-only arguments in <code>#[pyfunction]</code>. <a href="https://github.com/PyO3/pyo3/pull/1925">#1925</a></li>
<li>Add <code>PyErr::take</code> to attempt to fetch a Python exception if present. <a href="https://github.com/PyO3/pyo3/pull/1957">#1957</a></li>
</ul>
<h3 id="changed-16"><a class="header" href="#changed-16">Changed</a></h3>
<ul>
<li><code>PyList</code>, <code>PyTuple</code> and <code>PySequence</code>'s APIs now accepts only <code>usize</code> indices instead of <code>isize</code>.
<a href="https://github.com/PyO3/pyo3/pull/1733">#1733</a>, <a href="https://github.com/PyO3/pyo3/pull/1802">#1802</a>,
<a href="https://github.com/PyO3/pyo3/pull/1803">#1803</a></li>
<li><code>PyList::get_item</code> and <code>PyTuple::get_item</code> now return <code>PyResult&lt;&amp;PyAny&gt;</code> instead of panicking. <a href="https://github.com/PyO3/pyo3/pull/1733">#1733</a></li>
<li><code>PySequence::in_place_repeat</code> and <code>PySequence::in_place_concat</code> now return <code>PyResult&lt;&amp;PySequence&gt;</code> instead of <code>PyResult&lt;()&gt;</code>, which is needed in case of immutable sequences such as tuples. <a href="https://github.com/PyO3/pyo3/pull/1803">#1803</a></li>
<li><code>PySequence::get_slice</code> now returns <code>PyResult&lt;&amp;PySequence&gt;</code> instead of <code>PyResult&lt;&amp;PyAny&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1829">#1829</a></li>
<li>Deprecate <code>PyTuple::split_from</code>. <a href="https://github.com/PyO3/pyo3/pull/1804">#1804</a></li>
<li>Deprecate <code>PyTuple::slice</code>, new method <code>PyTuple::get_slice</code> added with <code>usize</code> indices. <a href="https://github.com/PyO3/pyo3/pull/1828">#1828</a></li>
<li>Deprecate FFI definitions <code>PyParser_SimpleParseStringFlags</code>, <code>PyParser_SimpleParseStringFlagsFilename</code>, <code>PyParser_SimpleParseFileFlags</code> when building for Python 3.9. <a href="https://github.com/PyO3/pyo3/pull/1830">#1830</a></li>
<li>Mark FFI definitions removed in Python 3.10 <code>PyParser_ASTFromString</code>, <code>PyParser_ASTFromStringObject</code>, <code>PyParser_ASTFromFile</code>, <code>PyParser_ASTFromFileObject</code>, <code>PyParser_SimpleParseStringFlags</code>, <code>PyParser_SimpleParseStringFlagsFilename</code>, <code>PyParser_SimpleParseFileFlags</code>, <code>PyParser_SimpleParseString</code>, <code>PyParser_SimpleParseFile</code>, <code>Py_SymtableString</code>, and <code>Py_SymtableStringObject</code>. <a href="https://github.com/PyO3/pyo3/pull/1830">#1830</a></li>
<li><code>#[pymethods]</code> now handles magic methods similarly to <code>#[pyproto]</code>. In the future, <code>#[pyproto]</code> may be deprecated. <a href="https://github.com/PyO3/pyo3/pull/1864">#1864</a></li>
<li>Deprecate FFI definitions <code>PySys_AddWarnOption</code>, <code>PySys_AddWarnOptionUnicode</code> and <code>PySys_HasWarnOptions</code>. <a href="https://github.com/PyO3/pyo3/pull/1887">#1887</a></li>
<li>Deprecate <code>#[call]</code> attribute in favor of using <code>fn __call__</code>. <a href="https://github.com/PyO3/pyo3/pull/1929">#1929</a></li>
<li>Fix missing FFI definition <code>_PyImport_FindExtensionObject</code> on Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1942">#1942</a></li>
<li>Change <code>PyErr::fetch</code> to panic in debug mode if no exception is present. <a href="https://github.com/PyO3/pyo3/pull/1957">#1957</a></li>
</ul>
<h3 id="fixed-24"><a class="header" href="#fixed-24">Fixed</a></h3>
<ul>
<li>Fix building with a conda environment on Windows. <a href="https://github.com/PyO3/pyo3/pull/1873">#1873</a></li>
<li>Fix panic on Python 3.6 when calling <code>Python::with_gil</code> with Python initialized but threading not initialized. <a href="https://github.com/PyO3/pyo3/pull/1874">#1874</a></li>
<li>Fix incorrect linking to version-specific DLL instead of <code>python3.dll</code> when cross-compiling to Windows with <code>abi3</code>. <a href="https://github.com/PyO3/pyo3/pull/1880">#1880</a></li>
<li>Fix FFI definition for <code>PyTuple_ClearFreeList</code> incorrectly being present for Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1887">#1887</a></li>
<li>Fix panic in generated <code>#[derive(FromPyObject)]</code> for enums. <a href="https://github.com/PyO3/pyo3/pull/1888">#1888</a></li>
<li>Fix cross-compiling to Python 3.7 builds with the "m" abi flag. <a href="https://github.com/PyO3/pyo3/pull/1908">#1908</a></li>
<li>Fix <code>__mod__</code> magic method fallback to <code>__rmod__</code>. <a href="https://github.com/PyO3/pyo3/pull/1934">#1934</a>.</li>
<li>Fix missing FFI definition <code>_PyImport_FindExtensionObject</code> on Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1942">#1942</a></li>
</ul>
<h2 id="0145---2021-09-05"><a class="header" href="#0145---2021-09-05"><a href="https://github.com/pyo3/pyo3/compare/v0.14.4...v0.14.5">0.14.5</a> - 2021-09-05</a></h2>
<h3 id="added-20"><a class="header" href="#added-20">Added</a></h3>
<ul>
<li>Make <code>pyo3_build_config::InterpreterConfig</code> and subfields public. <a href="https://github.com/PyO3/pyo3/pull/1848">#1848</a></li>
<li>Add <code>resolve-config</code> feature to the <code>pyo3-build-config</code> to control whether its build script does anything. <a href="https://github.com/PyO3/pyo3/pull/1856">#1856</a></li>
</ul>
<h3 id="fixed-25"><a class="header" href="#fixed-25">Fixed</a></h3>
<ul>
<li>Fix 0.14.4 compile regression on <code>s390x-unknown-linux-gnu</code> target. <a href="https://github.com/PyO3/pyo3/pull/1850">#1850</a></li>
</ul>
<h2 id="0144---2021-08-29"><a class="header" href="#0144---2021-08-29"><a href="https://github.com/pyo3/pyo3/compare/v0.14.3...v0.14.4">0.14.4</a> - 2021-08-29</a></h2>
<h3 id="changed-17"><a class="header" href="#changed-17">Changed</a></h3>
<ul>
<li>Mark <code>PyString::data</code> as <code>unsafe</code> and disable it and some supporting PyUnicode FFI APIs (which depend on a C bitfield) on big-endian targets. <a href="https://github.com/PyO3/pyo3/pull/1834">#1834</a></li>
</ul>
<h2 id="0143---2021-08-22"><a class="header" href="#0143---2021-08-22"><a href="https://github.com/pyo3/pyo3/compare/v0.14.2...v0.14.3">0.14.3</a> - 2021-08-22</a></h2>
<h3 id="added-21"><a class="header" href="#added-21">Added</a></h3>
<ul>
<li>Add <code>PyString::data</code> to access the raw bytes stored in a Python string. <a href="https://github.com/PyO3/pyo3/pull/1794">#1794</a></li>
</ul>
<h3 id="fixed-26"><a class="header" href="#fixed-26">Fixed</a></h3>
<ul>
<li>Raise <code>AttributeError</code> to avoid panic when calling <code>del</code> on a <code>#[setter]</code> defined class property. <a href="https://github.com/PyO3/pyo3/pull/1779">#1779</a></li>
<li>Restrict FFI definitions <code>PyGILState_Check</code> and <code>Py_tracefunc</code> to the unlimited API. <a href="https://github.com/PyO3/pyo3/pull/1787">#1787</a></li>
<li>Add missing <code>_type</code> field to <code>PyStatus</code> struct definition. <a href="https://github.com/PyO3/pyo3/pull/1791">#1791</a></li>
<li>Reduce lower bound <code>num-complex</code> optional dependency to support interop with <code>rust-numpy</code> and <code>ndarray</code> when building with the MSRV of 1.41 <a href="https://github.com/PyO3/pyo3/pull/1799">#1799</a></li>
<li>Fix memory leak in <code>Python::run_code</code>. <a href="https://github.com/PyO3/pyo3/pull/1806">#1806</a></li>
<li>Fix memory leak in <code>PyModule::from_code</code>. <a href="https://github.com/PyO3/pyo3/pull/1810">#1810</a></li>
<li>Remove use of <code>pyo3::</code> in <code>pyo3::types::datetime</code> which broke builds using <code>-Z avoid-dev-deps</code> <a href="https://github.com/PyO3/pyo3/pull/1811">#1811</a></li>
</ul>
<h2 id="0142---2021-08-09"><a class="header" href="#0142---2021-08-09"><a href="https://github.com/pyo3/pyo3/compare/v0.14.1...v0.14.2">0.14.2</a> - 2021-08-09</a></h2>
<h3 id="added-22"><a class="header" href="#added-22">Added</a></h3>
<ul>
<li>Add <code>indexmap</code> feature to add <code>ToPyObject</code>, <code>IntoPy</code> and <code>FromPyObject</code> implementations for <code>indexmap::IndexMap</code>. <a href="https://github.com/PyO3/pyo3/pull/1728">#1728</a></li>
<li>Add <code>pyo3_build_config::add_extension_module_link_args</code> to use in build scripts to set linker arguments (for macOS). <a href="https://github.com/PyO3/pyo3/pull/1755">#1755</a></li>
<li>Add <code>Python::with_gil_unchecked</code> unsafe variation of <code>Python::with_gil</code> to allow obtaining a <code>Python</code> in scenarios where <code>Python::with_gil</code> would fail. <a href="https://github.com/PyO3/pyo3/pull/1769">#1769</a></li>
</ul>
<h3 id="changed-18"><a class="header" href="#changed-18">Changed</a></h3>
<ul>
<li><code>PyErr::new</code> no longer acquires the Python GIL internally. <a href="https://github.com/PyO3/pyo3/pull/1724">#1724</a></li>
<li>Reverted PyO3 0.14.0's use of <code>cargo:rustc-cdylib-link-arg</code> in its build script, as Cargo unintentionally allowed crates to pass linker args to downstream crates in this way. Projects supporting macOS may need to restore <code>.cargo/config.toml</code> files. <a href="https://github.com/PyO3/pyo3/pull/1755">#1755</a></li>
</ul>
<h3 id="fixed-27"><a class="header" href="#fixed-27">Fixed</a></h3>
<ul>
<li>Fix regression in 0.14.0 rejecting usage of <code>#[doc(hidden)]</code> on structs and functions annotated with PyO3 macros. <a href="https://github.com/PyO3/pyo3/pull/1722">#1722</a></li>
<li>Fix regression in 0.14.0 leading to incorrect code coverage being computed for <code>#[pyfunction]</code>s. <a href="https://github.com/PyO3/pyo3/pull/1726">#1726</a></li>
<li>Fix incorrect FFI definition of <code>Py_Buffer</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/1737">#1737</a></li>
<li>Fix incorrect calculation of <code>dictoffset</code> on 32-bit Windows. <a href="https://github.com/PyO3/pyo3/pull/1475">#1475</a></li>
<li>Fix regression in 0.13.2 leading to linking to incorrect Python library on Windows "gnu" targets. <a href="https://github.com/PyO3/pyo3/pull/1759">#1759</a></li>
<li>Fix compiler warning: deny trailing semicolons in expression macro. <a href="https://github.com/PyO3/pyo3/pull/1762">#1762</a></li>
<li>Fix incorrect FFI definition of <code>Py_DecodeLocale</code>. The 2nd argument is now <code>*mut Py_ssize_t</code> instead of <code>Py_ssize_t</code>. <a href="https://github.com/PyO3/pyo3/pull/1766">#1766</a></li>
</ul>
<h2 id="0141---2021-07-04"><a class="header" href="#0141---2021-07-04"><a href="https://github.com/pyo3/pyo3/compare/v0.14.0...v0.14.1">0.14.1</a> - 2021-07-04</a></h2>
<h3 id="added-23"><a class="header" href="#added-23">Added</a></h3>
<ul>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code> for <code>&amp;PathBuf</code> and <code>&amp;OsString</code>. <a href="https://github.com/PyO3/pyo3/pull/1712">#1712</a></li>
</ul>
<h3 id="fixed-28"><a class="header" href="#fixed-28">Fixed</a></h3>
<ul>
<li>Fix crashes on PyPy due to incorrect definitions of <code>PyList_SET_ITEM</code>. <a href="https://github.com/PyO3/pyo3/pull/1713">#1713</a></li>
</ul>
<h2 id="0140---2021-07-03"><a class="header" href="#0140---2021-07-03"><a href="https://github.com/pyo3/pyo3/compare/v0.13.2...v0.14.0">0.14.0</a> - 2021-07-03</a></h2>
<h3 id="packaging-16"><a class="header" href="#packaging-16">Packaging</a></h3>
<ul>
<li>Update <code>num-bigint</code> optional dependency to 0.4. <a href="https://github.com/PyO3/pyo3/pull/1481">#1481</a></li>
<li>Update <code>num-complex</code> optional dependency to 0.4. <a href="https://github.com/PyO3/pyo3/pull/1482">#1482</a></li>
<li>Extend <code>hashbrown</code> optional dependency supported versions to include 0.11. <a href="https://github.com/PyO3/pyo3/pull/1496">#1496</a></li>
<li>Support PyPy 3.7. <a href="https://github.com/PyO3/pyo3/pull/1538">#1538</a></li>
</ul>
<h3 id="added-24"><a class="header" href="#added-24">Added</a></h3>
<ul>
<li>Extend conversions for <code>[T; N]</code> to all <code>N</code> using const generics (on Rust 1.51 and up). <a href="https://github.com/PyO3/pyo3/pull/1128">#1128</a></li>
<li>Add conversions between <code>OsStr</code>/ <code>OsString</code> and Python strings. <a href="https://github.com/PyO3/pyo3/pull/1379">#1379</a></li>
<li>Add conversions between <code>Path</code>/ <code>PathBuf</code> and Python strings (and <code>pathlib.Path</code> objects). <a href="https://github.com/PyO3/pyo3/pull/1379">#1379</a> <a href="https://github.com/PyO3/pyo3/pull/1654">#1654</a></li>
<li>Add a new set of <code>#[pyo3(...)]</code> attributes to control various PyO3 macro functionality:
<ul>
<li><code>#[pyo3(from_py_with = "...")]</code> function arguments and struct fields to override the default from-Python conversion. <a href="https://github.com/PyO3/pyo3/pull/1411">#1411</a></li>
<li><code>#[pyo3(name = "...")]</code> for setting Python names. <a href="https://github.com/PyO3/pyo3/pull/1567">#1567</a></li>
<li><code>#[pyo3(text_signature = "...")]</code> for setting text signature. <a href="https://github.com/PyO3/pyo3/pull/1658">#1658</a></li>
</ul>
</li>
<li>Add FFI definition <code>PyCFunction_CheckExact</code> for Python 3.9 and later. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li>Add FFI definition <code>Py_IS_TYPE</code>. <a href="https://github.com/PyO3/pyo3/pull/1429">#1429</a></li>
<li>Add FFI definition <code>_Py_InitializeMain</code>. <a href="https://github.com/PyO3/pyo3/pull/1473">#1473</a></li>
<li>Add FFI definitions from <code>cpython/import.h</code>.<a href="https://github.com/PyO3/pyo3/pull/1475">#1475</a></li>
<li>Add tuple and unit struct support for <code>#[pyclass]</code> macro. <a href="https://github.com/PyO3/pyo3/pull/1504">#1504</a></li>
<li>Add FFI definition <code>PyDateTime_TimeZone_UTC</code>. <a href="https://github.com/PyO3/pyo3/pull/1572">#1572</a></li>
<li>Add support for <code>#[pyclass(extends=Exception)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1591">#1591</a></li>
<li>Add <code>PyErr::cause</code> and <code>PyErr::set_cause</code>. <a href="https://github.com/PyO3/pyo3/pull/1679">#1679</a></li>
<li>Add FFI definitions from <code>cpython/pystate.h</code>. <a href="https://github.com/PyO3/pyo3/pull/1687/">#1687</a></li>
<li>Add <code>wrap_pyfunction!</code> macro to <code>pyo3::prelude</code>. <a href="https://github.com/PyO3/pyo3/pull/1695">#1695</a></li>
</ul>
<h3 id="changed-19"><a class="header" href="#changed-19">Changed</a></h3>
<ul>
<li>Allow only one <code>#[pymethods]</code> block per <code>#[pyclass]</code> by default, to remove the dependency on <code>inventory</code>. Add a <code>multiple-pymethods</code> feature to opt-in the original behavior and dependency on <code>inventory</code>. <a href="https://github.com/PyO3/pyo3/pull/1457">#1457</a></li>
<li>Change <code>PyTimeAccess::get_fold</code> to return a <code>bool</code> instead of a <code>u8</code>. <a href="https://github.com/PyO3/pyo3/pull/1397">#1397</a></li>
<li>Deprecate FFI definition <code>PyCFunction_Call</code> for Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li>Deprecate FFI definition <code>PyModule_GetFilename</code>. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li>The <code>auto-initialize</code> feature is no longer enabled by default. <a href="https://github.com/PyO3/pyo3/pull/1443">#1443</a></li>
<li>Change <code>PyCFunction::new</code> and <code>PyCFunction::new_with_keywords</code> to take <code>&amp;'static str</code> arguments rather than implicitly copying (and leaking) them. <a href="https://github.com/PyO3/pyo3/pull/1450">#1450</a></li>
<li>Deprecate <code>PyModule::call</code>, <code>PyModule::call0</code>, <code>PyModule::call1</code> and <code>PyModule::get</code>. <a href="https://github.com/PyO3/pyo3/pull/1492">#1492</a></li>
<li>Add length information to <code>PyBufferError</code>s raised from <code>PyBuffer::copy_to_slice</code> and <code>PyBuffer::copy_from_slice</code>. <a href="https://github.com/PyO3/pyo3/pull/1534">#1534</a></li>
<li>Automatically set <code>-undefined</code> and <code>dynamic_lookup</code> linker arguments on macOS with the <code>extension-module</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1539">#1539</a></li>
<li>Deprecate <code>#[pyproto]</code> methods which are easier to implement as <code>#[pymethods]</code>: <a href="https://github.com/PyO3/pyo3/pull/1560">#1560</a>
<ul>
<li><code>PyBasicProtocol::__bytes__</code> and <code>PyBasicProtocol::__format__</code></li>
<li><code>PyContextProtocol::__enter__</code> and <code>PyContextProtocol::__exit__</code></li>
<li><code>PyDescrProtocol::__delete__</code> and <code>PyDescrProtocol::__set_name__</code></li>
<li><code>PyMappingProtocol::__reversed__</code></li>
<li><code>PyNumberProtocol::__complex__</code> and <code>PyNumberProtocol::__round__</code></li>
<li><code>PyAsyncProtocol::__aenter__</code> and <code>PyAsyncProtocol::__aexit__</code></li>
</ul>
</li>
<li>Deprecate several attributes in favor of the new <code>#[pyo3(...)]</code> options:
<ul>
<li><code>#[name = "..."]</code>, replaced by <code>#[pyo3(name = "...")]</code> <a href="https://github.com/PyO3/pyo3/pull/1567">#1567</a></li>
<li><code>#[pyfn(m, "name")]</code>, replaced by <code>#[pyfn(m)] #[pyo3(name = "...")]</code>. <a href="https://github.com/PyO3/pyo3/pull/1610">#1610</a></li>
<li><code>#[pymodule(name)]</code>, replaced by <code>#[pymodule] #[pyo3(name = "...")]</code> <a href="https://github.com/PyO3/pyo3/pull/1650">#1650</a></li>
<li><code>#[text_signature = "..."]</code>, replaced by <code>#[pyo3(text_signature = "...")]</code>. <a href="https://github.com/PyO3/pyo3/pull/1658">#1658</a></li>
</ul>
</li>
<li>Reduce LLVM line counts to improve compilation times. <a href="https://github.com/PyO3/pyo3/pull/1604">#1604</a></li>
<li>No longer call <code>PyEval_InitThreads</code> in <code>#[pymodule]</code> init code. <a href="https://github.com/PyO3/pyo3/pull/1630">#1630</a></li>
<li>Use <code>METH_FASTCALL</code> argument passing convention, when possible, to improve <code>#[pyfunction]</code> and method performance.
<a href="https://github.com/PyO3/pyo3/pull/1619">#1619</a>, <a href="https://github.com/PyO3/pyo3/pull/1660">#1660</a></li>
<li>Filter sysconfigdata candidates by architecture when cross-compiling. <a href="https://github.com/PyO3/pyo3/pull/1626">#1626</a></li>
</ul>
<h3 id="removed-6"><a class="header" href="#removed-6">Removed</a></h3>
<ul>
<li>Remove deprecated exception names <code>BaseException</code> etc. <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li>Remove deprecated methods <code>Python::is_instance</code>, <code>Python::is_subclass</code>, <code>Python::release</code>, <code>Python::xdecref</code>, and <code>Py::from_owned_ptr_or_panic</code>. <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li>Remove many FFI definitions which never existed in the Python C-API:
<ul>
<li>(previously deprecated) <code>PyGetSetDef_INIT</code>, <code>PyGetSetDef_DICT</code>, <code>PyCoro_Check</code>, <code>PyCoroWrapper_Check</code>, and <code>PyAsyncGen_Check</code> <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li><code>PyMethodDef_INIT</code> <a href="https://github.com/PyO3/pyo3/pull/1426">#1426</a></li>
<li><code>PyTypeObject_INIT</code> <a href="https://github.com/PyO3/pyo3/pull/1429">#1429</a></li>
<li><code>PyObject_Check</code>, <code>PySuper_Check</code>, and <code>FreeFunc</code> <a href="https://github.com/PyO3/pyo3/pull/1438">#1438</a></li>
<li><code>PyModuleDef_INIT</code> <a href="https://github.com/PyO3/pyo3/pull/1630">#1630</a></li>
</ul>
</li>
<li>Remove pyclass implementation details from <code>PyTypeInfo</code>:
<ul>
<li><code>Type</code>, <code>DESCRIPTION</code>, and <code>FLAGS</code> <a href="https://github.com/PyO3/pyo3/pull/1456">#1456</a></li>
<li><code>BaseType</code>, <code>BaseLayout</code>, <code>Layout</code>, <code>Initializer</code> <a href="https://github.com/PyO3/pyo3/pull/1596">#1596</a></li>
</ul>
</li>
<li>Remove <code>PYO3_CROSS_INCLUDE_DIR</code> environment variable and the associated C header parsing functionality. <a href="https://github.com/PyO3/pyo3/pull/1521">#1521</a></li>
<li>Remove <code>raw_pycfunction!</code> macro. <a href="https://github.com/PyO3/pyo3/pull/1619">#1619</a></li>
<li>Remove <code>PyClassAlloc</code> trait. <a href="https://github.com/PyO3/pyo3/pull/1657">#1657</a></li>
<li>Remove <code>PyList::get_parked_item</code>. <a href="https://github.com/PyO3/pyo3/pull/1664">#1664</a></li>
</ul>
<h3 id="fixed-29"><a class="header" href="#fixed-29">Fixed</a></h3>
<ul>
<li>Remove FFI definition <code>PyCFunction_ClearFreeList</code> for Python 3.9 and later. <a href="https://github.com/PyO3/pyo3/pull/1425">#1425</a></li>
<li><code>PYO3_CROSS_LIB_DIR</code> environment variable no long required when compiling for x86-64 Python from macOS arm64 and reverse. <a href="https://github.com/PyO3/pyo3/pull/1428">#1428</a></li>
<li>Fix FFI definition <code>_PyEval_RequestCodeExtraIndex</code>, which took an argument of the wrong type. <a href="https://github.com/PyO3/pyo3/pull/1429">#1429</a></li>
<li>Fix FFI definition <code>PyIndex_Check</code> missing with the <code>abi3</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1436">#1436</a></li>
<li>Fix incorrect <code>TypeError</code> raised when keyword-only argument passed along with a positional argument in <code>*args</code>. <a href="https://github.com/PyO3/pyo3/pull/1440">#1440</a></li>
<li>Fix inability to use a named lifetime for <code>&amp;PyTuple</code> of <code>*args</code> in <code>#[pyfunction]</code>. <a href="https://github.com/PyO3/pyo3/pull/1440">#1440</a></li>
<li>Fix use of Python argument for <code>#[pymethods]</code> inside macro expansions. <a href="https://github.com/PyO3/pyo3/pull/1505">#1505</a></li>
<li>No longer include <code>__doc__</code> in <code>__all__</code> generated for <code>#[pymodule]</code>. <a href="https://github.com/PyO3/pyo3/pull/1509">#1509</a></li>
<li>Always use cross-compiling configuration if any of the <code>PYO3_CROSS</code> family of environment variables are set. <a href="https://github.com/PyO3/pyo3/pull/1514">#1514</a></li>
<li>Support <code>EnvironmentError</code>, <code>IOError</code>, and <code>WindowsError</code> on PyPy. <a href="https://github.com/PyO3/pyo3/pull/1533">#1533</a></li>
<li>Fix unnecessary rebuilds when cycling between <code>cargo check</code> and <code>cargo clippy</code> in a Python virtualenv. <a href="https://github.com/PyO3/pyo3/pull/1557">#1557</a></li>
<li>Fix segfault when dereferencing <code>ffi::PyDateTimeAPI</code> without the GIL. <a href="https://github.com/PyO3/pyo3/pull/1563">#1563</a></li>
<li>Fix memory leak in <code>FromPyObject</code> implementations for <code>u128</code> and <code>i128</code>. <a href="https://github.com/PyO3/pyo3/pull/1638">#1638</a></li>
<li>Fix <code>#[pyclass(extends=PyDict)]</code> leaking the dict contents on drop. <a href="https://github.com/PyO3/pyo3/pull/1657">#1657</a></li>
<li>Fix segfault when calling <code>PyList::get_item</code> with negative indices. <a href="https://github.com/PyO3/pyo3/pull/1668">#1668</a></li>
<li>Fix FFI definitions of <code>PyEval_SetProfile</code>/<code>PyEval_SetTrace</code> to take <code>Option&lt;Py_tracefunc&gt;</code> parameters. <a href="https://github.com/PyO3/pyo3/pull/1692">#1692</a></li>
<li>Fix <code>ToPyObject</code> impl for <code>HashSet</code> to accept non-default hashers. <a href="https://github.com/PyO3/pyo3/pull/1702">#1702</a></li>
</ul>
<h2 id="0132---2021-02-12"><a class="header" href="#0132---2021-02-12"><a href="https://github.com/pyo3/pyo3/compare/v0.13.1...v0.13.2">0.13.2</a> - 2021-02-12</a></h2>
<h3 id="packaging-17"><a class="header" href="#packaging-17">Packaging</a></h3>
<ul>
<li>Lower minimum supported Rust version to 1.41. <a href="https://github.com/PyO3/pyo3/pull/1421">#1421</a></li>
</ul>
<h3 id="added-25"><a class="header" href="#added-25">Added</a></h3>
<ul>
<li>Add unsafe API <code>with_embedded_python_interpreter</code> to initialize a Python interpreter, execute a closure, and finalize the interpreter. <a href="https://github.com/PyO3/pyo3/pull/1355">#1355</a></li>
<li>Add <code>serde</code> feature which provides implementations of <code>Serialize</code> and <code>Deserialize</code> for <code>Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1366">#1366</a></li>
<li>Add FFI definition <code>_PyCFunctionFastWithKeywords</code> on Python 3.7 and up. <a href="https://github.com/PyO3/pyo3/pull/1384">#1384</a></li>
<li>Add <code>PyDateTime::new_with_fold</code> method. <a href="https://github.com/PyO3/pyo3/pull/1398">#1398</a></li>
<li>Add <code>size_hint</code> impls for <code>{PyDict,PyList,PySet,PyTuple}Iterator</code>s. <a href="https://github.com/PyO3/pyo3/pull/1699">#1699</a></li>
</ul>
<h3 id="changed-20"><a class="header" href="#changed-20">Changed</a></h3>
<ul>
<li><code>prepare_freethreaded_python</code> will no longer register an <code>atexit</code> handler to call <code>Py_Finalize</code>. This resolves a number of issues with incompatible C extensions causing crashes at finalization. <a href="https://github.com/PyO3/pyo3/pull/1355">#1355</a></li>
<li>Mark <code>PyLayout::py_init</code>, <code>PyClassDict::clear_dict</code>, and <code>opt_to_pyobj</code> safe, as they do not perform any unsafe operations. <a href="https://github.com/PyO3/pyo3/pull/1404">#1404</a></li>
</ul>
<h3 id="fixed-30"><a class="header" href="#fixed-30">Fixed</a></h3>
<ul>
<li>Fix support for using <code>r#raw_idents</code> as argument names in pyfunctions. <a href="https://github.com/PyO3/pyo3/pull/1383">#1383</a></li>
<li>Fix typo in FFI definition for <code>PyFunction_GetCode</code> (was incorrectly <code>PyFunction_Code</code>). <a href="https://github.com/PyO3/pyo3/pull/1387">#1387</a></li>
<li>Fix FFI definitions <code>PyMarshal_WriteObjectToString</code> and <code>PyMarshal_ReadObjectFromString</code> as available in limited API. <a href="https://github.com/PyO3/pyo3/pull/1387">#1387</a></li>
<li>Fix FFI definitions <code>PyListObject</code> and those from <code>funcobject.h</code> as requiring non-limited API. <a href="https://github.com/PyO3/pyo3/pull/1387">#1387</a></li>
<li>Fix unqualified <code>Result</code> usage in <code>pyobject_native_type_base</code>. <a href="https://github.com/PyO3/pyo3/pull/1402">#1402</a></li>
<li>Fix build on systems where the default Python encoding is not UTF-8. <a href="https://github.com/PyO3/pyo3/pull/1405">#1405</a></li>
<li>Fix build on mingw / MSYS2. <a href="https://github.com/PyO3/pyo3/pull/1423">#1423</a></li>
</ul>
<h2 id="0131---2021-01-10"><a class="header" href="#0131---2021-01-10"><a href="https://github.com/pyo3/pyo3/compare/v0.13.0...v0.13.1">0.13.1</a> - 2021-01-10</a></h2>
<h3 id="added-26"><a class="header" href="#added-26">Added</a></h3>
<ul>
<li>Add support for <code>#[pyclass(dict)]</code> and <code>#[pyclass(weakref)]</code> with the <code>abi3</code> feature on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1342">#1342</a></li>
<li>Add FFI definitions <code>PyOS_BeforeFork</code>, <code>PyOS_AfterFork_Parent</code>, <code>PyOS_AfterFork_Child</code> for Python 3.7 and up. <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Add an <code>auto-initialize</code> feature to control whether PyO3 should automatically initialize an embedded Python interpreter. For compatibility this feature is enabled by default in PyO3 0.13.1, but is planned to become opt-in from PyO3 0.14.0. <a href="https://github.com/PyO3/pyo3/pull/1347">#1347</a></li>
<li>Add support for cross-compiling to Windows without needing <code>PYO3_CROSS_INCLUDE_DIR</code>. <a href="https://github.com/PyO3/pyo3/pull/1350">#1350</a></li>
</ul>
<h3 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h3>
<ul>
<li>Deprecate FFI definitions <code>PyEval_CallObjectWithKeywords</code>, <code>PyEval_CallObject</code>, <code>PyEval_CallFunction</code>, <code>PyEval_CallMethod</code> when building for Python 3.9. <a href="https://github.com/PyO3/pyo3/pull/1338">#1338</a></li>
<li>Deprecate FFI definitions <code>PyGetSetDef_DICT</code> and <code>PyGetSetDef_INIT</code> which have never been in the Python API. <a href="https://github.com/PyO3/pyo3/pull/1341">#1341</a></li>
<li>Deprecate FFI definitions <code>PyGen_NeedsFinalizing</code>, <code>PyImport_Cleanup</code> (removed in 3.9), and <code>PyOS_InitInterrupts</code> (3.10). <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Deprecate FFI definition <code>PyOS_AfterFork</code> for Python 3.7 and up. <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Deprecate FFI definitions <code>PyCoro_Check</code>, <code>PyAsyncGen_Check</code>, and <code>PyCoroWrapper_Check</code>, which have never been in the Python API (for the first two, it is possible to use <code>PyCoro_CheckExact</code> and <code>PyAsyncGen_CheckExact</code> instead; these are the actual functions provided by the Python API). <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
<li>Deprecate FFI definitions for <code>PyUnicode_FromUnicode</code>, <code>PyUnicode_AsUnicode</code> and <code>PyUnicode_AsUnicodeAndSize</code>, which will be removed from 3.12 and up due to <a href="https://www.python.org/dev/peps/pep-0623/">PEP 623</a>. <a href="https://github.com/PyO3/pyo3/pull/1370">#1370</a></li>
</ul>
<h3 id="removed-7"><a class="header" href="#removed-7">Removed</a></h3>
<ul>
<li>Remove FFI definition <code>PyFrame_ClearFreeList</code> when building for Python 3.9. <a href="https://github.com/PyO3/pyo3/pull/1341">#1341</a></li>
<li>Remove FFI definition <code>_PyDict_Contains</code> when building for Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1341">#1341</a></li>
<li>Remove FFI definitions <code>PyGen_NeedsFinalizing</code> and <code>PyImport_Cleanup</code> (for 3.9 and up), and <code>PyOS_InitInterrupts</code> (3.10). <a href="https://github.com/PyO3/pyo3/pull/1348">#1348</a></li>
</ul>
<h3 id="fixed-31"><a class="header" href="#fixed-31">Fixed</a></h3>
<ul>
<li>Stop including <code>Py_TRACE_REFS</code> config setting automatically if <code>Py_DEBUG</code> is set on Python 3.8 and up. <a href="https://github.com/PyO3/pyo3/pull/1334">#1334</a></li>
<li>Remove <code>#[deny(warnings)]</code> attribute (and instead refuse warnings only in CI). <a href="https://github.com/PyO3/pyo3/pull/1340">#1340</a></li>
<li>Fix deprecation warning for missing <code>__module__</code> with <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/1343">#1343</a></li>
<li>Correct return type of <code>PyFrozenSet::empty</code> to <code>&amp;PyFrozenSet</code> (was incorrectly <code>&amp;PySet</code>). <a href="https://github.com/PyO3/pyo3/pull/1351">#1351</a></li>
<li>Fix missing <code>Py_INCREF</code> on heap type objects on Python versions before 3.8. <a href="https://github.com/PyO3/pyo3/pull/1365">#1365</a></li>
</ul>
<h2 id="0130---2020-12-22"><a class="header" href="#0130---2020-12-22"><a href="https://github.com/pyo3/pyo3/compare/v0.12.4...v0.13.0">0.13.0</a> - 2020-12-22</a></h2>
<h3 id="packaging-18"><a class="header" href="#packaging-18">Packaging</a></h3>
<ul>
<li>Drop support for Python 3.5 (as it is now end-of-life). <a href="https://github.com/PyO3/pyo3/pull/1250">#1250</a></li>
<li>Bump minimum supported Rust version to 1.45. <a href="https://github.com/PyO3/pyo3/pull/1272">#1272</a></li>
<li>Bump indoc dependency to 1.0. <a href="https://github.com/PyO3/pyo3/pull/1272">#1272</a></li>
<li>Bump paste dependency to 1.0. <a href="https://github.com/PyO3/pyo3/pull/1272">#1272</a></li>
<li>Rename internal crates <code>pyo3cls</code> and <code>pyo3-derive-backend</code> to <code>pyo3-macros</code> and <code>pyo3-macros-backend</code> respectively. <a href="https://github.com/PyO3/pyo3/pull/1317">#1317</a></li>
</ul>
<h3 id="added-27"><a class="header" href="#added-27">Added</a></h3>
<ul>
<li>Add support for building for CPython limited API. Opting-in to the limited API enables a single extension wheel built with PyO3 to be installable on multiple Python versions. This required a few minor changes to runtime behavior of of PyO3 <code>#[pyclass]</code> types. See the migration guide for full details. <a href="https://github.com/PyO3/pyo3/pull/1152">#1152</a>
<ul>
<li>Add feature flags <code>abi3-py36</code>, <code>abi3-py37</code>, <code>abi3-py38</code> etc. to set the minimum Python version when using the limited API. <a href="https://github.com/PyO3/pyo3/pull/1263">#1263</a></li>
</ul>
</li>
<li>Add argument names to <code>TypeError</code> messages generated by pymethod wrappers. <a href="https://github.com/PyO3/pyo3/pull/1212">#1212</a></li>
<li>Add FFI definitions for PEP 587 "Python Initialization Configuration". <a href="https://github.com/PyO3/pyo3/pull/1247">#1247</a></li>
<li>Add FFI definitions for <code>PyEval_SetProfile</code> and <code>PyEval_SetTrace</code>. <a href="https://github.com/PyO3/pyo3/pull/1255">#1255</a></li>
<li>Add FFI definitions for context.h functions (<code>PyContext_New</code>, etc). <a href="https://github.com/PyO3/pyo3/pull/1259">#1259</a></li>
<li>Add <code>PyAny::is_instance</code> method. <a href="https://github.com/PyO3/pyo3/pull/1276">#1276</a></li>
<li>Add support for conversion between <code>char</code> and <code>PyString</code>. <a href="https://github.com/PyO3/pyo3/pull/1282">#1282</a></li>
<li>Add FFI definitions for <code>PyBuffer_SizeFromFormat</code>, <code>PyObject_LengthHint</code>, <code>PyObject_CallNoArgs</code>, <code>PyObject_CallOneArg</code>, <code>PyObject_CallMethodNoArgs</code>, <code>PyObject_CallMethodOneArg</code>, <code>PyObject_VectorcallDict</code>, and <code>PyObject_VectorcallMethod</code>. <a href="https://github.com/PyO3/pyo3/pull/1287">#1287</a></li>
<li>Add conversions between <code>u128</code>/<code>i128</code> and <code>PyLong</code> for PyPy. <a href="https://github.com/PyO3/pyo3/pull/1310">#1310</a></li>
<li>Add <code>Python::version</code> and <code>Python::version_info</code> to get the running interpreter version. <a href="https://github.com/PyO3/pyo3/pull/1322">#1322</a></li>
<li>Add conversions for tuples of length 10, 11, and 12. <a href="https://github.com/PyO3/pyo3/pull/1454">#1454</a></li>
</ul>
<h3 id="changed-21"><a class="header" href="#changed-21">Changed</a></h3>
<ul>
<li>Change return type of <code>PyType::name</code> from <code>Cow&lt;str&gt;</code> to <code>PyResult&lt;&amp;str&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1152">#1152</a></li>
<li><code>#[pyclass(subclass)]</code> is now required for subclassing from Rust (was previously just required for subclassing from Python). <a href="https://github.com/PyO3/pyo3/pull/1152">#1152</a></li>
<li>Change <code>PyIterator</code> to be consistent with other native types: it is now used as <code>&amp;PyIterator</code> instead of <code>PyIterator&lt;'a&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1176">#1176</a></li>
<li>Change formatting of <code>PyDowncastError</code> messages to be closer to Python's builtin error messages. <a href="https://github.com/PyO3/pyo3/pull/1212">#1212</a></li>
<li>Change <code>Debug</code> and <code>Display</code> impls for <code>PyException</code> to be consistent with <code>PyAny</code>. <a href="https://github.com/PyO3/pyo3/pull/1275">#1275</a></li>
<li>Change <code>Debug</code> impl of <code>PyErr</code> to output more helpful information (acquiring the GIL if necessary). <a href="https://github.com/PyO3/pyo3/pull/1275">#1275</a></li>
<li>Rename <code>PyTypeInfo::is_instance</code> and <code>PyTypeInfo::is_exact_instance</code> to <code>PyTypeInfo::is_type_of</code> and <code>PyTypeInfo::is_exact_type_of</code>. <a href="https://github.com/PyO3/pyo3/pull/1278">#1278</a></li>
<li>Optimize <code>PyAny::call0</code>, <code>Py::call0</code> and <code>PyAny::call_method0</code> and <code>Py::call_method0</code> on Python 3.9 and up. <a href="https://github.com/PyO3/pyo3/pull/1285">#1287</a></li>
<li>Require double-quotes for pyclass name argument e.g <code>#[pyclass(name = "MyClass")]</code>. <a href="https://github.com/PyO3/pyo3/pull/1303">#1303</a></li>
</ul>
<h3 id="deprecated-1"><a class="header" href="#deprecated-1">Deprecated</a></h3>
<ul>
<li>Deprecate <code>Python::is_instance</code>, <code>Python::is_subclass</code>, <code>Python::release</code>, and <code>Python::xdecref</code>. <a href="https://github.com/PyO3/pyo3/pull/1292">#1292</a></li>
</ul>
<h3 id="removed-8"><a class="header" href="#removed-8">Removed</a></h3>
<ul>
<li>Remove deprecated ffi definitions <code>PyUnicode_AsUnicodeCopy</code>, <code>PyUnicode_GetMax</code>, <code>_Py_CheckRecursionLimit</code>, <code>PyObject_AsCharBuffer</code>, <code>PyObject_AsReadBuffer</code>, <code>PyObject_CheckReadBuffer</code> and <code>PyObject_AsWriteBuffer</code>, which will be removed in Python 3.10. <a href="https://github.com/PyO3/pyo3/pull/1217">#1217</a></li>
<li>Remove unused <code>python3</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1235">#1235</a></li>
</ul>
<h3 id="fixed-32"><a class="header" href="#fixed-32">Fixed</a></h3>
<ul>
<li>Fix missing field in <code>PyCodeObject</code> struct (<code>co_posonlyargcount</code>) - caused invalid access to other fields in Python &gt;3.7. <a href="https://github.com/PyO3/pyo3/pull/1260">#1260</a></li>
<li>Fix building for <code>x86_64-unknown-linux-musl</code> target from <code>x86_64-unknown-linux-gnu</code> host. <a href="https://github.com/PyO3/pyo3/pull/1267">#1267</a></li>
<li>Fix <code>#[text_signature]</code> interacting badly with rust <code>r#raw_identifiers</code>. <a href="https://github.com/PyO3/pyo3/pull/1286">#1286</a></li>
<li>Fix FFI definitions for <code>PyObject_Vectorcall</code> and <code>PyVectorcall_Call</code>. <a href="https://github.com/PyO3/pyo3/pull/1285">#1287</a></li>
<li>Fix building with Anaconda python inside a virtualenv. <a href="https://github.com/PyO3/pyo3/pull/1290">#1290</a></li>
<li>Fix definition of opaque FFI types. <a href="https://github.com/PyO3/pyo3/pull/1312">#1312</a></li>
<li>Fix using custom error type in pyclass <code>#[new]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/1319">#1319</a></li>
</ul>
<h2 id="0124---2020-11-28"><a class="header" href="#0124---2020-11-28"><a href="https://github.com/pyo3/pyo3/compare/v0.12.3...v0.12.4">0.12.4</a> - 2020-11-28</a></h2>
<h3 id="fixed-33"><a class="header" href="#fixed-33">Fixed</a></h3>
<ul>
<li>Fix reference count bug in implementation of <code>From&lt;Py&lt;T&gt;&gt;</code> for <code>PyObject</code>, a regression introduced in PyO3 0.12. <a href="https://github.com/PyO3/pyo3/pull/1297">#1297</a></li>
</ul>
<h2 id="0123---2020-10-12"><a class="header" href="#0123---2020-10-12"><a href="https://github.com/pyo3/pyo3/compare/v0.12.2...v0.12.3">0.12.3</a> - 2020-10-12</a></h2>
<h3 id="fixed-34"><a class="header" href="#fixed-34">Fixed</a></h3>
<ul>
<li>Fix support for Rust versions 1.39 to 1.44, broken by an incorrect internal update to paste 1.0 which was done in PyO3 0.12.2. <a href="https://github.com/PyO3/pyo3/pull/1234">#1234</a></li>
</ul>
<h2 id="0122---2020-10-12"><a class="header" href="#0122---2020-10-12"><a href="https://github.com/pyo3/pyo3/compare/v0.12.1...v0.12.2">0.12.2</a> - 2020-10-12</a></h2>
<h3 id="added-28"><a class="header" href="#added-28">Added</a></h3>
<ul>
<li>Add support for keyword-only arguments without default values in <code>#[pyfunction]</code>. <a href="https://github.com/PyO3/pyo3/pull/1209">#1209</a></li>
<li>Add <code>Python::check_signals</code> as a safe a wrapper for <code>PyErr_CheckSignals</code>. <a href="https://github.com/PyO3/pyo3/pull/1214">#1214</a></li>
</ul>
<h3 id="fixed-35"><a class="header" href="#fixed-35">Fixed</a></h3>
<ul>
<li>Fix invalid document for protocol methods. <a href="https://github.com/PyO3/pyo3/pull/1169">#1169</a></li>
<li>Hide docs of PyO3 private implementation details in <code>pyo3::class::methods</code>. <a href="https://github.com/PyO3/pyo3/pull/1169">#1169</a></li>
<li>Fix unnecessary rebuild on PATH changes when the python interpreter is provided by PYO3_PYTHON. <a href="https://github.com/PyO3/pyo3/pull/1231">#1231</a></li>
</ul>
<h2 id="0121---2020-09-16"><a class="header" href="#0121---2020-09-16"><a href="https://github.com/pyo3/pyo3/compare/v0.12.0...v0.12.1">0.12.1</a> - 2020-09-16</a></h2>
<h3 id="fixed-36"><a class="header" href="#fixed-36">Fixed</a></h3>
<ul>
<li>Fix building for a 32-bit Python on 64-bit Windows with a 64-bit Rust toolchain. <a href="https://github.com/PyO3/pyo3/pull/1179">#1179</a></li>
<li>Fix building on platforms where <code>c_char</code> is <code>u8</code>. <a href="https://github.com/PyO3/pyo3/pull/1182">#1182</a></li>
</ul>
<h2 id="0120---2020-09-12"><a class="header" href="#0120---2020-09-12"><a href="https://github.com/pyo3/pyo3/compare/v0.11.1...v0.12.0">0.12.0</a> - 2020-09-12</a></h2>
<h3 id="added-29"><a class="header" href="#added-29">Added</a></h3>
<ul>
<li>Add FFI definitions <code>Py_FinalizeEx</code>, <code>PyOS_getsig</code>, and <code>PyOS_setsig</code>. <a href="https://github.com/PyO3/pyo3/pull/1021">#1021</a></li>
<li>Add <code>PyString::to_str</code> for accessing <code>PyString</code> as <code>&amp;str</code>. <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Add <code>Python::with_gil</code> for executing a closure with the Python GIL. <a href="https://github.com/PyO3/pyo3/pull/1037">#1037</a></li>
<li>Add type information to failures in <code>PyAny::downcast</code>. <a href="https://github.com/PyO3/pyo3/pull/1050">#1050</a></li>
<li>Implement <code>Debug</code> for <code>PyIterator</code>. <a href="https://github.com/PyO3/pyo3/pull/1051">#1051</a></li>
<li>Add <code>PyBytes::new_with</code> and <code>PyByteArray::new_with</code> for initialising <code>bytes</code> and <code>bytearray</code> objects using a closure. <a href="https://github.com/PyO3/pyo3/pull/1074">#1074</a></li>
<li>Add <code>#[derive(FromPyObject)]</code> macro for enums and structs. <a href="https://github.com/PyO3/pyo3/pull/1065">#1065</a></li>
<li>Add <code>Py::as_ref</code> and <code>Py::into_ref</code> for converting <code>Py&lt;T&gt;</code> to <code>&amp;T</code>. <a href="https://github.com/PyO3/pyo3/pull/1098">#1098</a></li>
<li>Add ability to return <code>Result</code> types other than <code>PyResult</code> from <code>#[pyfunction]</code>, <code>#[pymethod]</code> and <code>#[pyproto]</code> functions. <a href="https://github.com/PyO3/pyo3/pull/1118">#1106</a>.</li>
<li>Implement <code>ToPyObject</code>, <code>IntoPy</code>, and <code>FromPyObject</code> for <a href="https://crates.io/crates/hashbrown">hashbrown</a>'s <code>HashMap</code> and <code>HashSet</code> types (requires the <code>hashbrown</code> feature). <a href="https://github.com/PyO3/pyo3/pull/1114">#1114</a></li>
<li>Add <code>#[pyfunction(pass_module)]</code> and <code>#[pyfn(pass_module)]</code> to pass the module object as the first function argument. <a href="https://github.com/PyO3/pyo3/pull/1143">#1143</a></li>
<li>Add <code>PyModule::add_function</code> and <code>PyModule::add_submodule</code> as typed alternatives to <code>PyModule::add_wrapped</code>. <a href="https://github.com/PyO3/pyo3/pull/1143">#1143</a></li>
<li>Add native <code>PyCFunction</code> and <code>PyFunction</code> types. <a href="https://github.com/PyO3/pyo3/pull/1163">#1163</a></li>
</ul>
<h3 id="changed-22"><a class="header" href="#changed-22">Changed</a></h3>
<ul>
<li>Rework exception types: <a href="https://github.com/PyO3/pyo3/pull/1024">#1024</a> <a href="https://github.com/PyO3/pyo3/pull/1115">#1115</a>
<ul>
<li>Rename exception types from e.g. <code>RuntimeError</code> to <code>PyRuntimeError</code>. The old names continue to exist but are deprecated.</li>
<li>Exception objects are now accessible as <code>&amp;T</code> or <code>Py&lt;T&gt;</code>, just like other Python-native types.</li>
<li>Rename <code>PyException::py_err</code> to <code>PyException::new_err</code>.</li>
<li>Rename <code>PyUnicodeDecodeErr::new_err</code> to <code>PyUnicodeDecodeErr::new</code>.</li>
<li>Remove <code>PyStopIteration::stop_iteration</code>.</li>
</ul>
</li>
<li>Require <code>T: Send</code> for the return value <code>T</code> of <code>Python::allow_threads</code>. <a href="https://github.com/PyO3/pyo3/pull/1036">#1036</a></li>
<li>Rename <code>PYTHON_SYS_EXECUTABLE</code> to <code>PYO3_PYTHON</code>. The old name will continue to work (undocumented) but will be removed in a future release. <a href="https://github.com/PyO3/pyo3/pull/1039">#1039</a></li>
<li>Remove <code>unsafe</code> from signature of <code>PyType::as_type_ptr</code>. <a href="https://github.com/PyO3/pyo3/pull/1047">#1047</a></li>
<li>Change return type of <code>PyIterator::from_object</code> to <code>PyResult&lt;PyIterator&gt;</code> (was <code>Result&lt;PyIterator, PyDowncastError&gt;</code>). <a href="https://github.com/PyO3/pyo3/pull/1051">#1051</a></li>
<li><code>IntoPy</code> is no longer implied by <code>FromPy</code>. <a href="https://github.com/PyO3/pyo3/pull/1063">#1063</a></li>
<li>Change <code>PyObject</code> to be a type alias for <code>Py&lt;PyAny&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/1063">#1063</a></li>
<li>Rework <code>PyErr</code> to be compatible with the <code>std::error::Error</code> trait: <a href="https://github.com/PyO3/pyo3/pull/1067">#1067</a> <a href="https://github.com/PyO3/pyo3/pull/1115">#1115</a>
<ul>
<li>Implement <code>Display</code>, <code>Error</code>, <code>Send</code> and <code>Sync</code> for <code>PyErr</code> and <code>PyErrArguments</code>.</li>
<li>Add <code>PyErr::instance</code> for accessing <code>PyErr</code> as <code>&amp;PyBaseException</code>.</li>
<li><code>PyErr</code>'s fields are now an implementation detail. The equivalent values can be accessed with <code>PyErr::ptype</code>, <code>PyErr::pvalue</code> and <code>PyErr::ptraceback</code>.</li>
<li>Change receiver of <code>PyErr::print</code> and <code>PyErr::print_and_set_sys_last_vars</code> to <code>&amp;self</code> (was <code>self</code>).</li>
<li>Remove <code>PyErrValue</code>, <code>PyErr::from_value</code>, <code>PyErr::into_normalized</code>, and <code>PyErr::normalize</code>.</li>
<li>Remove <code>PyException::into</code>.</li>
<li>Remove <code>Into&lt;PyResult&lt;T&gt;&gt;</code> for <code>PyErr</code> and <code>PyException</code>.</li>
</ul>
</li>
<li>Change methods generated by <code>#[pyproto]</code> to return <code>NotImplemented</code> if Python should try a reversed operation. #<a href="https://github.com/PyO3/pyo3/pull/1072">1072</a></li>
<li>Change argument to <code>PyModule::add</code> to <code>impl IntoPy&lt;PyObject&gt;</code> (was <code>impl ToPyObject</code>). #<a href="https://github.com/PyO3/pyo3/pull/1124">1124</a></li>
</ul>
<h3 id="removed-9"><a class="header" href="#removed-9">Removed</a></h3>
<ul>
<li>Remove many exception and <code>PyErr</code> APIs; see the "changed" section above. <a href="https://github.com/PyO3/pyo3/pull/1024">#1024</a> <a href="https://github.com/PyO3/pyo3/pull/1067">#1067</a> <a href="https://github.com/PyO3/pyo3/pull/1115">#1115</a></li>
<li>Remove <code>PyString::to_string</code> (use new <code>PyString::to_str</code>). <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Remove <code>PyString::as_bytes</code>. <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Remove <code>Python::register_any</code>. <a href="https://github.com/PyO3/pyo3/pull/1023">#1023</a></li>
<li>Remove <code>GILGuard::acquire</code> from the public API. Use <code>Python::acquire_gil</code> or <code>Python::with_gil</code>. <a href="https://github.com/PyO3/pyo3/pull/1036">#1036</a></li>
<li>Remove the <code>FromPy</code> trait. <a href="https://github.com/PyO3/pyo3/pull/1063">#1063</a></li>
<li>Remove the <code>AsPyRef</code> trait. <a href="https://github.com/PyO3/pyo3/pull/1098">#1098</a></li>
</ul>
<h3 id="fixed-37"><a class="header" href="#fixed-37">Fixed</a></h3>
<ul>
<li>Correct FFI definitions <code>Py_SetProgramName</code> and <code>Py_SetPythonHome</code> to take <code>*const</code> arguments (was <code>*mut</code>). <a href="https://github.com/PyO3/pyo3/pull/1021">#1021</a></li>
<li>Fix <code>FromPyObject</code> for <code>num_bigint::BigInt</code> for Python objects with an <code>__index__</code> method. <a href="https://github.com/PyO3/pyo3/pull/1027">#1027</a></li>
<li>Correct FFI definition <code>_PyLong_AsByteArray</code> to take <code>*mut c_uchar</code> argument (was <code>*const c_uchar</code>). <a href="https://github.com/PyO3/pyo3/pull/1029">#1029</a></li>
<li>Fix segfault with <code>#[pyclass(dict, unsendable)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1058">#1058</a> <a href="https://github.com/PyO3/pyo3/pull/1059">#1059</a></li>
<li>Fix using <code>&amp;Self</code> as an argument type for functions in a <code>#[pymethods]</code> block. <a href="https://github.com/PyO3/pyo3/pull/1071">#1071</a></li>
<li>Fix best-effort build against PyPy 3.6. <a href="https://github.com/PyO3/pyo3/pull/1092">#1092</a></li>
<li>Fix many cases of lifetime elision in <code>#[pyproto]</code> implementations. <a href="https://github.com/PyO3/pyo3/pull/1093">#1093</a></li>
<li>Fix detection of Python build configuration when cross-compiling. <a href="https://github.com/PyO3/pyo3/pull/1095">#1095</a></li>
<li>Always link against libpython on android with the <code>extension-module</code> feature. <a href="https://github.com/PyO3/pyo3/pull/1095">#1095</a></li>
<li>Fix the <code>+</code> operator not trying <code>__radd__</code> when both <code>__add__</code> and <code>__radd__</code> are defined in <code>PyNumberProtocol</code> (and similar for all other reversible operators). <a href="https://github.com/PyO3/pyo3/pull/1107">#1107</a></li>
<li>Fix building with Anaconda python. <a href="https://github.com/PyO3/pyo3/pull/1175">#1175</a></li>
</ul>
<h2 id="0111---2020-06-30"><a class="header" href="#0111---2020-06-30"><a href="https://github.com/pyo3/pyo3/compare/v0.11.0...v0.11.1">0.11.1</a> - 2020-06-30</a></h2>
<h3 id="added-30"><a class="header" href="#added-30">Added</a></h3>
<ul>
<li><code>#[pyclass(unsendable)]</code>. <a href="https://github.com/PyO3/pyo3/pull/1009">#1009</a></li>
</ul>
<h3 id="changed-23"><a class="header" href="#changed-23">Changed</a></h3>
<ul>
<li>Update <code>parking_lot</code> dependency to <code>0.11</code>. <a href="https://github.com/PyO3/pyo3/pull/1010">#1010</a></li>
</ul>
<h2 id="0110---2020-06-28"><a class="header" href="#0110---2020-06-28"><a href="https://github.com/pyo3/pyo3/compare/v0.10.1...v0.11.0">0.11.0</a> - 2020-06-28</a></h2>
<h3 id="added-31"><a class="header" href="#added-31">Added</a></h3>
<ul>
<li>Support stable versions of Rust (&gt;=1.39). <a href="https://github.com/PyO3/pyo3/pull/969">#969</a></li>
<li>Add FFI definition <code>PyObject_AsFileDescriptor</code>. <a href="https://github.com/PyO3/pyo3/pull/938">#938</a></li>
<li>Add <code>PyByteArray::data</code>, <code>PyByteArray::as_bytes</code>, and <code>PyByteArray::as_bytes_mut</code>. <a href="https://github.com/PyO3/pyo3/pull/967">#967</a></li>
<li>Add <code>GILOnceCell</code> to use in situations where <code>lazy_static</code> or <code>once_cell</code> can deadlock. <a href="https://github.com/PyO3/pyo3/pull/975">#975</a></li>
<li>Add <code>Py::borrow</code>, <code>Py::borrow_mut</code>, <code>Py::try_borrow</code>, and <code>Py::try_borrow_mut</code> for accessing <code>#[pyclass]</code> values. <a href="https://github.com/PyO3/pyo3/pull/976">#976</a></li>
<li>Add <code>IterNextOutput</code> and <code>IterANextOutput</code> for returning from <code>__next__</code> / <code>__anext__</code>. <a href="https://github.com/PyO3/pyo3/pull/997">#997</a></li>
</ul>
<h3 id="changed-24"><a class="header" href="#changed-24">Changed</a></h3>
<ul>
<li>Simplify internals of <code>#[pyo3(get)]</code> attribute. (Remove the hidden API <code>GetPropertyValue</code>.) <a href="https://github.com/PyO3/pyo3/pull/934">#934</a></li>
<li>Call <code>Py_Finalize</code> at exit to flush buffers, etc. <a href="https://github.com/PyO3/pyo3/pull/943">#943</a></li>
<li>Add type parameter to PyBuffer. #<a href="https://github.com/PyO3/pyo3/pull/951">951</a></li>
<li>Require <code>Send</code> bound for <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/966">#966</a></li>
<li>Add <code>Python</code> argument to most methods on <code>PyObject</code> and <code>Py&lt;T&gt;</code> to ensure GIL safety. <a href="https://github.com/PyO3/pyo3/pull/970">#970</a></li>
<li>Change signature of <code>PyTypeObject::type_object</code> - now takes <code>Python</code> argument and returns <code>&amp;PyType</code>. <a href="https://github.com/PyO3/pyo3/pull/970">#970</a></li>
<li>Change return type of <code>PyTuple::slice</code> and <code>PyTuple::split_from</code> from <code>Py&lt;PyTuple&gt;</code> to <code>&amp;PyTuple</code>. <a href="https://github.com/PyO3/pyo3/pull/970">#970</a></li>
<li>Change return type of <code>PyTuple::as_slice</code> to <code>&amp;[&amp;PyAny]</code>. <a href="https://github.com/PyO3/pyo3/pull/971">#971</a></li>
<li>Rename <code>PyTypeInfo::type_object</code> to <code>type_object_raw</code>, and add <code>Python</code> argument. <a href="https://github.com/PyO3/pyo3/pull/975">#975</a></li>
<li>Update <code>num-complex</code> optional dependendency from <code>0.2</code> to <code>0.3</code>. <a href="https://github.com/PyO3/pyo3/pull/977">#977</a></li>
<li>Update <code>num-bigint</code> optional dependendency from <code>0.2</code> to <code>0.3</code>. <a href="https://github.com/PyO3/pyo3/pull/978">#978</a></li>
<li><code>#[pyproto]</code> is re-implemented without specialization. <a href="https://github.com/PyO3/pyo3/pull/961">#961</a></li>
<li><code>PyClassAlloc::alloc</code> is renamed to <code>PyClassAlloc::new</code>. <a href="https://github.com/PyO3/pyo3/pull/990">#990</a></li>
<li><code>#[pyproto]</code> methods can now have return value <code>T</code> or <code>PyResult&lt;T&gt;</code> (previously only <code>PyResult&lt;T&gt;</code> was supported). <a href="https://github.com/PyO3/pyo3/pull/996">#996</a></li>
<li><code>#[pyproto]</code> methods can now skip annotating the return type if it is <code>()</code>. <a href="https://github.com/PyO3/pyo3/pull/998">#998</a></li>
</ul>
<h3 id="removed-10"><a class="header" href="#removed-10">Removed</a></h3>
<ul>
<li>Remove <code>ManagedPyRef</code> (unused, and needs specialization) <a href="https://github.com/PyO3/pyo3/pull/930">#930</a></li>
</ul>
<h3 id="fixed-38"><a class="header" href="#fixed-38">Fixed</a></h3>
<ul>
<li>Fix passing explicit <code>None</code> to <code>Option&lt;T&gt;</code> argument <code>#[pyfunction]</code> with a default value. <a href="https://github.com/PyO3/pyo3/pull/936">#936</a></li>
<li>Fix <code>PyClass.__new__</code>'s not respecting subclasses when inherited by a Python class. <a href="https://github.com/PyO3/pyo3/pull/990">#990</a></li>
<li>Fix returning <code>Option&lt;T&gt;</code> from <code>#[pyproto]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/996">#996</a></li>
<li>Fix accepting <code>PyRef&lt;Self&gt;</code> and <code>PyRefMut&lt;Self&gt;</code> to <code>#[getter]</code> and <code>#[setter]</code> methods. <a href="https://github.com/PyO3/pyo3/pull/999">#999</a></li>
</ul>
<h2 id="0101---2020-05-14"><a class="header" href="#0101---2020-05-14"><a href="https://github.com/pyo3/pyo3/compare/v0.10.0...v0.10.1">0.10.1</a> - 2020-05-14</a></h2>
<h3 id="fixed-39"><a class="header" href="#fixed-39">Fixed</a></h3>
<ul>
<li>Fix deadlock in <code>Python::acquire_gil</code> after dropping a <code>PyObject</code> or <code>Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/924">#924</a></li>
</ul>
<h2 id="0100---2020-05-13"><a class="header" href="#0100---2020-05-13"><a href="https://github.com/pyo3/pyo3/compare/v0.9.2...v0.10.0">0.10.0</a> - 2020-05-13</a></h2>
<h3 id="added-32"><a class="header" href="#added-32">Added</a></h3>
<ul>
<li>Add FFI definition <code>_PyDict_NewPresized</code>. <a href="https://github.com/PyO3/pyo3/pull/849">#849</a></li>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code> for <code>HashSet</code> and <code>BTreeSet</code>. <a href="https://github.com/PyO3/pyo3/pull/864">#864</a></li>
<li>Add <code>PyAny::dir</code> method. <a href="https://github.com/PyO3/pyo3/pull/886">#886</a></li>
<li>Gate macros behind a <code>macros</code> feature (enabled by default). <a href="https://github.com/PyO3/pyo3/pull/897">#897</a></li>
<li>Add ability to define class attributes using <code>#[classattr]</code> on functions in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/905">#905</a></li>
<li>Implement <code>Clone</code> for <code>PyObject</code> and <code>Py&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/908">#908</a></li>
<li>Implement <code>Deref&lt;Target = PyAny&gt;</code> for all builtin types. (<code>PyList</code>, <code>PyTuple</code>, <code>PyDict</code> etc.) <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Implement <code>Deref&lt;Target = PyAny&gt;</code> for <code>PyCell&lt;T&gt;</code>. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Add <code>#[classattr]</code> support for associated constants in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/914">#914</a></li>
</ul>
<h3 id="changed-25"><a class="header" href="#changed-25">Changed</a></h3>
<ul>
<li>Panics will now be raised as a Python <code>PanicException</code>. <a href="https://github.com/PyO3/pyo3/pull/797">#797</a></li>
<li>Change <code>PyObject</code> and <code>Py&lt;T&gt;</code> reference counts to decrement immediately upon drop when the GIL is held. <a href="https://github.com/PyO3/pyo3/pull/851">#851</a></li>
<li>Allow <code>PyIterProtocol</code> methods to use either <code>PyRef</code> or <code>PyRefMut</code> as the receiver type. <a href="https://github.com/PyO3/pyo3/pull/856">#856</a></li>
<li>Change the implementation of <code>FromPyObject</code> for <code>Py&lt;T&gt;</code> to apply to a wider range of <code>T</code>, including all <code>T: PyClass</code>. <a href="https://github.com/PyO3/pyo3/pull/880">#880</a></li>
<li>Move all methods from the <code>ObjectProtocol</code> trait to the <code>PyAny</code> struct. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Remove need for <code>#![feature(specialization)]</code> in crates depending on PyO3. <a href="https://github.com/PyO3/pyo3/pull/917">#917</a></li>
</ul>
<h3 id="removed-11"><a class="header" href="#removed-11">Removed</a></h3>
<ul>
<li>Remove <code>PyMethodsProtocol</code> trait. <a href="https://github.com/PyO3/pyo3/pull/889">#889</a></li>
<li>Remove <code>num-traits</code> dependency. <a href="https://github.com/PyO3/pyo3/pull/895">#895</a></li>
<li>Remove <code>ObjectProtocol</code> trait. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Remove <code>PyAny::None</code>. Users should use <code>Python::None</code> instead. <a href="https://github.com/PyO3/pyo3/pull/911">#911</a></li>
<li>Remove all <code>*ProtocolImpl</code> traits. <a href="https://github.com/PyO3/pyo3/pull/917">#917</a></li>
</ul>
<h3 id="fixed-40"><a class="header" href="#fixed-40">Fixed</a></h3>
<ul>
<li>Fix support for <code>__radd__</code> and other <code>__r*__</code> methods as implementations for Python mathematical operators. <a href="https://github.com/PyO3/pyo3/pull/839">#839</a></li>
<li>Fix panics during garbage collection when traversing objects that were already mutably borrowed. <a href="https://github.com/PyO3/pyo3/pull/855">#855</a></li>
<li>Prevent <code>&amp;'static</code> references to Python objects as arguments to <code>#[pyfunction]</code> and <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/869">#869</a></li>
<li>Fix lifetime safety bug with <code>AsPyRef::as_ref</code>. <a href="https://github.com/PyO3/pyo3/pull/876">#876</a></li>
<li>Fix <code>#[pyo3(get)]</code> attribute on <code>Py&lt;T&gt;</code> fields. <a href="https://github.com/PyO3/pyo3/pull/880">#880</a></li>
<li>Fix segmentation faults caused by functions such as <code>PyList::get_item</code> returning borrowed objects when it was not safe to do so. <a href="https://github.com/PyO3/pyo3/pull/890">#890</a></li>
<li>Fix segmentation faults caused by nested <code>Python::acquire_gil</code> calls creating dangling references. <a href="https://github.com/PyO3/pyo3/pull/893">#893</a></li>
<li>Fix segmentatation faults when a panic occurs during a call to <code>Python::allow_threads</code>. <a href="https://github.com/PyO3/pyo3/pull/912">#912</a></li>
</ul>
<h2 id="092---2020-04-09"><a class="header" href="#092---2020-04-09"><a href="https://github.com/pyo3/pyo3/compare/v0.9.1...v0.9.2">0.9.2</a> - 2020-04-09</a></h2>
<h3 id="added-33"><a class="header" href="#added-33">Added</a></h3>
<ul>
<li><code>FromPyObject</code> implementations for <code>HashSet</code> and <code>BTreeSet</code>. <a href="https://github.com/PyO3/pyo3/pull/842">#842</a></li>
</ul>
<h3 id="fixed-41"><a class="header" href="#fixed-41">Fixed</a></h3>
<ul>
<li>Correctly detect 32bit architecture. <a href="https://github.com/PyO3/pyo3/pull/830">#830</a></li>
</ul>
<h2 id="091---2020-03-23"><a class="header" href="#091---2020-03-23"><a href="https://github.com/pyo3/pyo3/compare/v0.9.0...v0.9.1">0.9.1</a> - 2020-03-23</a></h2>
<h3 id="fixed-42"><a class="header" href="#fixed-42">Fixed</a></h3>
<ul>
<li>Error messages for <code>#[pyclass]</code>. <a href="https://github.com/PyO3/pyo3/pull/826">#826</a></li>
<li><code>FromPyObject</code> implementation for <code>PySequence</code>. <a href="https://github.com/PyO3/pyo3/pull/827">#827</a></li>
</ul>
<h2 id="090---2020-03-19"><a class="header" href="#090---2020-03-19"><a href="https://github.com/pyo3/pyo3/compare/v0.8.5...v0.9.0">0.9.0</a> - 2020-03-19</a></h2>
<h3 id="added-34"><a class="header" href="#added-34">Added</a></h3>
<ul>
<li><code>PyCell</code>, which has RefCell-like features. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>PyClass</code>, <code>PyLayout</code>, <code>PyClassInitializer</code>. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a></li>
<li>Implemented <code>IntoIterator</code> for <code>PySet</code> and <code>PyFrozenSet</code>. <a href="https://github.com/PyO3/pyo3/pull/716">#716</a></li>
<li><code>FromPyObject</code> is now automatically implemented for <code>T: Clone</code> pyclasses. <a href="https://github.com/PyO3/pyo3/pull/730">#730</a></li>
<li><code>#[pyo3(get)]</code> and <code>#[pyo3(set)]</code> will now use the Rust doc-comment from the field for the Python property. <a href="https://github.com/PyO3/pyo3/pull/755">#755</a></li>
<li><code>#[setter]</code> functions may now take an argument of <code>Pyo3::Python</code>. <a href="https://github.com/PyO3/pyo3/pull/760">#760</a></li>
<li><code>PyTypeInfo::BaseLayout</code> and <code>PyClass::BaseNativeType</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>PyDowncastImpl</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li>Implement <code>FromPyObject</code> and <code>IntoPy&lt;PyObject&gt;</code> traits for arrays (up to 32). <a href="https://github.com/PyO3/pyo3/pull/778">#778</a></li>
<li><code>migration.md</code> and <code>types.md</code> in the guide. <a href="https://github.com/PyO3/pyo3/pull/795">#795</a>, #<a href="https://github.com/PyO3/pyo3/pull/802">802</a></li>
<li><code>ffi::{_PyBytes_Resize, _PyDict_Next, _PyDict_Contains, _PyDict_GetDictPtr}</code>. #<a href="https://github.com/PyO3/pyo3/pull/820">820</a></li>
</ul>
<h3 id="changed-26"><a class="header" href="#changed-26">Changed</a></h3>
<ul>
<li><code>#[new]</code> does not take <code>PyRawObject</code> and can return <code>Self</code>. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a></li>
<li>The blanket implementations for <code>FromPyObject</code> for <code>&amp;T</code> and <code>&amp;mut T</code> are no longer specializable. Implement <code>PyTryFrom</code> for your type to control the behavior of <code>FromPyObject::extract</code> for your types. <a href="https://github.com/PyO3/pyo3/pull/713">#713</a></li>
<li>The implementation for <code>IntoPy&lt;U&gt; for T</code> where <code>U: FromPy&lt;T&gt;</code> is no longer specializable. Control the behavior of this via the implementation of <code>FromPy</code>. <a href="https://github.com/PyO3/pyo3/pull/713">#713</a></li>
<li>Use <code>parking_lot::Mutex</code> instead of <code>spin::Mutex</code>. <a href="https://github.com/PyO3/pyo3/pull/734">#734</a></li>
<li>Bumped minimum Rust version to <code>1.42.0-nightly 2020-01-21</code>. <a href="https://github.com/PyO3/pyo3/pull/761">#761</a></li>
<li><code>PyRef</code> and <code>PyRefMut</code> are renewed for <code>PyCell</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li>Some new FFI functions for Python 3.8. <a href="https://github.com/PyO3/pyo3/pull/784">#784</a></li>
<li><code>PyAny</code> is now on the top level module and prelude. <a href="https://github.com/PyO3/pyo3/pull/816">#816</a></li>
</ul>
<h3 id="removed-12"><a class="header" href="#removed-12">Removed</a></h3>
<ul>
<li><code>PyRawObject</code>. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a></li>
<li><code>PyNoArgsFunction</code>. <a href="https://github.com/PyO3/pyo3/pull/741">#741</a></li>
<li><code>initialize_type</code>. To set the module name for a <code>#[pyclass]</code>, use the <code>module</code> argument to the macro. #<a href="https://github.com/PyO3/pyo3/pull/751">751</a></li>
<li><code>AsPyRef::as_mut/with/with_mut/into_py/into_mut_py</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>PyTryFrom::try_from_mut/try_from_mut_exact/try_from_mut_unchecked</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>Python::mut_from_owned_ptr/mut_from_borrowed_ptr</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
<li><code>ObjectProtocol::get_base/get_mut_base</code>. <a href="https://github.com/PyO3/pyo3/pull/770">#770</a></li>
</ul>
<h3 id="fixed-43"><a class="header" href="#fixed-43">Fixed</a></h3>
<ul>
<li>Fixed unsoundness of subclassing. <a href="https://github.com/PyO3/pyo3/pull/683">#683</a>.</li>
<li>Clear error indicator when the exception is handled on the Rust side. <a href="https://github.com/PyO3/pyo3/pull/719">#719</a></li>
<li>Usage of raw identifiers with <code>#[pyo3(set)]</code>. <a href="https://github.com/PyO3/pyo3/pull/745">#745</a></li>
<li>Usage of <code>PyObject</code> with <code>#[pyo3(get)]</code>. <a href="https://github.com/PyO3/pyo3/pull/760">#760</a></li>
<li><code>#[pymethods]</code> used in conjunction with <code>#[cfg]</code>. #<a href="https://github.com/PyO3/pyo3/pull/769">769</a></li>
<li><code>"*"</code> in a <code>#[pyfunction()]</code> argument list incorrectly accepting any number of positional arguments (use <code>args = "*"</code> when this behavior is desired). #<a href="https://github.com/PyO3/pyo3/pull/792">792</a></li>
<li><code>PyModule::dict</code>. #<a href="https://github.com/PyO3/pyo3/pull/809">809</a></li>
<li>Fix the case where <code>DESCRIPTION</code> is not null-terminated. #<a href="https://github.com/PyO3/pyo3/pull/822">822</a></li>
</ul>
<h2 id="085---2020-01-05"><a class="header" href="#085---2020-01-05"><a href="https://github.com/pyo3/pyo3/compare/v0.8.4...v0.8.5">0.8.5</a> - 2020-01-05</a></h2>
<h3 id="added-35"><a class="header" href="#added-35">Added</a></h3>
<ul>
<li>Implemented <code>FromPyObject</code> for <code>HashMap</code> and <code>BTreeMap</code></li>
<li>Support for <code>#[name = "foo"]</code> attribute for <code>#[pyfunction]</code> and in <code>#[pymethods]</code>. <a href="https://github.com/PyO3/pyo3/pull/692">#692</a></li>
</ul>
<h2 id="084---2019-12-14"><a class="header" href="#084---2019-12-14"><a href="https://github.com/pyo3/pyo3/compare/v0.8.3...v0.8.4">0.8.4</a> - 2019-12-14</a></h2>
<h3 id="added-36"><a class="header" href="#added-36">Added</a></h3>
<ul>
<li>Support for <code>#[text_signature]</code> attribute. <a href="https://github.com/PyO3/pyo3/pull/675">#675</a></li>
</ul>
<h2 id="083---2019-11-23"><a class="header" href="#083---2019-11-23"><a href="https://github.com/pyo3/pyo3/compare/v0.8.2...v0.8.3">0.8.3</a> - 2019-11-23</a></h2>
<h3 id="removed-13"><a class="header" href="#removed-13">Removed</a></h3>
<ul>
<li><code>#[init]</code> is removed. <a href="https://github.com/PyO3/pyo3/pull/658">#658</a></li>
</ul>
<h3 id="fixed-44"><a class="header" href="#fixed-44">Fixed</a></h3>
<ul>
<li>Now all <code>&amp;Py~</code> types have <code>!Send</code> bound. <a href="https://github.com/PyO3/pyo3/pull/655">#655</a></li>
<li>Fix a compile error raised by the stabilization of <code>!</code> type. <a href="https://github.com/PyO3/pyo3/issues/672">#672</a>.</li>
</ul>
<h2 id="082---2019-10-27"><a class="header" href="#082---2019-10-27"><a href="https://github.com/pyo3/pyo3/compare/v0.8.1...v0.8.2">0.8.2</a> - 2019-10-27</a></h2>
<h3 id="added-37"><a class="header" href="#added-37">Added</a></h3>
<ul>
<li>FFI compatibility for PEP 590 Vectorcall. <a href="https://github.com/PyO3/pyo3/pull/641">#641</a></li>
</ul>
<h3 id="fixed-45"><a class="header" href="#fixed-45">Fixed</a></h3>
<ul>
<li>Fix PySequenceProtocol::set_item. <a href="https://github.com/PyO3/pyo3/pull/624">#624</a></li>
<li>Fix a corner case of BigInt::FromPyObject. <a href="https://github.com/PyO3/pyo3/pull/630">#630</a></li>
<li>Fix index errors in parameter conversion. <a href="https://github.com/PyO3/pyo3/pull/631">#631</a></li>
<li>Fix handling of invalid utf-8 sequences in <code>PyString::as_bytes</code>. <a href="https://github.com/PyO3/pyo3/pull/639">#639</a>
and <code>PyString::to_string_lossy</code> <a href="https://github.com/PyO3/pyo3/pull/642">#642</a>.</li>
<li>Remove <code>__contains__</code> and <code>__iter__</code> from PyMappingProtocol. <a href="https://github.com/PyO3/pyo3/pull/644">#644</a></li>
<li>Fix proc-macro definition of PySetAttrProtocol. <a href="https://github.com/PyO3/pyo3/pull/645">#645</a></li>
</ul>
<h2 id="081---2019-10-08"><a class="header" href="#081---2019-10-08"><a href="https://github.com/pyo3/pyo3/compare/v0.8.0...v0.8.1">0.8.1</a> - 2019-10-08</a></h2>
<h3 id="added-38"><a class="header" href="#added-38">Added</a></h3>
<ul>
<li>Conversion between <a href="https://github.com/rust-num/num-bigint">num-bigint</a> and Python int. <a href="https://github.com/PyO3/pyo3/pull/608">#608</a></li>
</ul>
<h3 id="fixed-46"><a class="header" href="#fixed-46">Fixed</a></h3>
<ul>
<li>Make sure the right Python interpreter is used in OSX builds. <a href="https://github.com/PyO3/pyo3/pull/604">#604</a></li>
<li>Patch specialization being broken by Rust 1.40. <a href="https://github.com/PyO3/pyo3/issues/614">#614</a></li>
<li>Fix a segfault around PyErr. <a href="https://github.com/PyO3/pyo3/pull/597">#597</a></li>
</ul>
<h2 id="080---2019-09-16"><a class="header" href="#080---2019-09-16"><a href="https://github.com/pyo3/pyo3/compare/v0.7.0...v0.8.0">0.8.0</a> - 2019-09-16</a></h2>
<h3 id="added-39"><a class="header" href="#added-39">Added</a></h3>
<ul>
<li><code>module</code> argument to <code>pyclass</code> macro. <a href="https://github.com/PyO3/pyo3/pull/499">#499</a></li>
<li><code>py_run!</code> macro <a href="https://github.com/PyO3/pyo3/pull/512">#512</a></li>
<li>Use existing fields and methods before calling custom <strong>getattr</strong>. <a href="https://github.com/PyO3/pyo3/pull/505">#505</a></li>
<li><code>PyBytes</code> can now be indexed just like <code>Vec&lt;u8&gt;</code></li>
<li>Implement <code>IntoPy&lt;PyObject&gt;</code> for <code>PyRef</code> and <code>PyRefMut</code>.</li>
</ul>
<h3 id="changed-27"><a class="header" href="#changed-27">Changed</a></h3>
<ul>
<li>Implementing the Using the <code>gc</code> parameter for <code>pyclass</code> (e.g. <code>#[pyclass(gc)]</code>) without implementing the <code>class::PyGCProtocol</code> trait is now a compile-time error. Failing to implement this trait could lead to segfaults. <a href="https://github.com/PyO3/pyo3/pull/532">#532</a></li>
<li><code>PyByteArray::data</code> has been replaced with <code>PyDataArray::to_vec</code> because returning a <code>&amp;[u8]</code> is unsound. (See <a href="https://github.com/PyO3/pyo3/issues/373#issuecomment-512332696">this comment</a> for a great write-up for why that was unsound)</li>
<li>Replace <code>mashup</code> with <code>paste</code>.</li>
<li><code>GILPool</code> gained a <code>Python</code> marker to prevent it from being misused to release Python objects without the GIL held.</li>
</ul>
<h3 id="removed-14"><a class="header" href="#removed-14">Removed</a></h3>
<ul>
<li><code>IntoPyObject</code> was replaced with <code>IntoPy&lt;PyObject&gt;</code></li>
<li><code>#[pyclass(subclass)]</code> is hidden a <code>unsound-subclass</code> feature because it's causing segmentation faults.</li>
</ul>
<h3 id="fixed-47"><a class="header" href="#fixed-47">Fixed</a></h3>
<ul>
<li>More readable error message for generics in pyclass <a href="https://github.com/PyO3/pyo3/pull/503">#503</a></li>
</ul>
<h2 id="070---2019-05-26"><a class="header" href="#070---2019-05-26"><a href="https://github.com/pyo3/pyo3/compare/v0.6.0...v0.7.0">0.7.0</a> - 2019-05-26</a></h2>
<h3 id="added-40"><a class="header" href="#added-40">Added</a></h3>
<ul>
<li>PyPy support by omerbenamram in <a href="https://github.com/PyO3/pyo3/pull/393">#393</a></li>
<li>Have <code>PyModule</code> generate an index of its members (<code>__all__</code> list).</li>
<li>Allow <code>slf: PyRef&lt;T&gt;</code> for pyclass(#419)</li>
<li>Allow to use lifetime specifiers in <code>pymethods</code></li>
<li>Add <code>marshal</code> module. <a href="https://github.com/PyO3/pyo3/pull/460">#460</a></li>
</ul>
<h3 id="changed-28"><a class="header" href="#changed-28">Changed</a></h3>
<ul>
<li><code>Python::run</code> returns <code>PyResult&lt;()&gt;</code> instead of <code>PyResult&lt;&amp;PyAny&gt;</code>.</li>
<li>Methods decorated with <code>#[getter]</code> and <code>#[setter]</code> can now omit wrapping the
result type in <code>PyResult</code> if they don't raise exceptions.</li>
</ul>
<h3 id="fixed-48"><a class="header" href="#fixed-48">Fixed</a></h3>
<ul>
<li><code>type_object::PyTypeObject</code> has been marked unsafe because breaking the contract <code>type_object::PyTypeObject::init_type</code> can lead to UB.</li>
<li>Fixed automatic derive of <code>PySequenceProtocol</code> implementation in <a href="https://github.com/PyO3/pyo3/pull/423">#423</a>.</li>
<li>Capitalization &amp; better wording to README.md.</li>
<li>Docstrings of properties is now properly set using the doc of the <code>#[getter]</code> method.</li>
<li>Fixed issues with <code>pymethods</code> crashing on doc comments containing double quotes.</li>
<li><code>PySet::new</code> and <code>PyFrozenSet::new</code> now return <code>PyResult&lt;&amp;Py[Frozen]Set&gt;</code>; exceptions are raised if
the items are not hashable.</li>
<li>Fixed building using <code>venv</code> on Windows.</li>
<li><code>PyTuple::new</code> now returns <code>&amp;PyTuple</code> instead of <code>Py&lt;PyTuple&gt;</code>.</li>
<li>Fixed several issues with argument parsing; notable, the <code>*args</code> and <code>**kwargs</code>
tuple/dict now doesn't contain arguments that are otherwise assigned to parameters.</li>
</ul>
<h2 id="060---2019-03-28"><a class="header" href="#060---2019-03-28"><a href="https://github.com/pyo3/pyo3/compare/v0.5.3...v0.6.0">0.6.0</a> - 2019-03-28</a></h2>
<h3 id="regressions"><a class="header" href="#regressions">Regressions</a></h3>
<ul>
<li>Currently, <a href="https://github.com/PyO3/pyo3/issues/341">#341</a> causes <code>cargo test</code> to fail with weird linking errors when the <code>extension-module</code> feature is activated. For now you can work around this by making the <code>extension-module</code> feature optional and running the tests with <code>cargo test --no-default-features</code>:</li>
</ul>
<pre><code class="language-toml">[dependencies.pyo3]
version = "0.6.0"

[features]
extension-module = ["pyo3/extension-module"]
default = ["extension-module"]
</code></pre>
<h3 id="added-41"><a class="header" href="#added-41">Added</a></h3>
<ul>
<li>Added a <code>wrap_pymodule!</code> macro similar to the existing <code>wrap_pyfunction!</code> macro. Only available on python 3</li>
<li>Added support for cross compiling (e.g. to arm v7) by mtp401 in <a href="https://github.com/PyO3/pyo3/pull/327">#327</a>. See the "Cross Compiling" section in the "Building and Distribution" chapter of the guide for more details.</li>
<li>The <code>PyRef</code> and <code>PyRefMut</code> types, which allow to differentiate between an instance of a rust struct on the rust heap and an instance that is embedded inside a python object. By kngwyu in <a href="https://github.com/PyO3/pyo3/pull/335">#335</a></li>
<li>Added <code>FromPy&lt;T&gt;</code> and <code>IntoPy&lt;T&gt;</code> which are equivalent to <code>From&lt;T&gt;</code> and <code>Into&lt;T&gt;</code> except that they require a gil token.</li>
<li>Added <code>ManagedPyRef</code>, which should eventually replace <code>ToBorrowedObject</code>.</li>
</ul>
<h3 id="changed-29"><a class="header" href="#changed-29">Changed</a></h3>
<ul>
<li>Renamed <code>PyObjectRef</code> to <code>PyAny</code> in #388</li>
<li>Renamed <code>add_function</code> to <code>add_wrapped</code> as it now also supports modules.</li>
<li>Renamed <code>#[pymodinit]</code> to <code>#[pymodule]</code></li>
<li><code>py.init(|| value)</code> becomes <code>Py::new(value)</code></li>
<li><code>py.init_ref(|| value)</code> becomes <code>PyRef::new(value)</code></li>
<li><code>py.init_mut(|| value)</code> becomes <code>PyRefMut::new(value)</code>.</li>
<li><code>PyRawObject::init</code> is now infallible, e.g. it returns <code>()</code> instead of <code>PyResult&lt;()&gt;</code>.</li>
<li>Renamed <code>py_exception!</code> to <code>create_exception!</code> and refactored the error macros.</li>
<li>Renamed <code>wrap_function!</code> to <code>wrap_pyfunction!</code></li>
<li>Renamed <code>#[prop(get, set)]</code> to <code>#[pyo3(get, set)]</code></li>
<li><code>#[pyfunction]</code> now supports the same arguments as <code>#[pyfn()]</code></li>
<li>Some macros now emit proper spanned errors instead of panics.</li>
<li>Migrated to the 2018 edition</li>
<li><code>crate::types::exceptions</code> moved to <code>crate::exceptions</code></li>
<li>Replace <code>IntoPyTuple</code> with <code>IntoPy&lt;Py&lt;PyTuple&gt;&gt;</code>.</li>
<li><code>IntoPyPointer</code> and <code>ToPyPointer</code> moved into the crate root.</li>
<li><code>class::CompareOp</code> moved into <code>class::basic::CompareOp</code></li>
<li>PyTypeObject is now a direct subtrait PyTypeCreate, removing the old cyclical implementation in <a href="https://github.com/PyO3/pyo3/pull/350">#350</a></li>
<li>Add <code>PyList::{sort, reverse}</code> by chr1sj0nes in <a href="https://github.com/PyO3/pyo3/pull/357">#357</a> and <a href="https://github.com/PyO3/pyo3/pull/358">#358</a></li>
<li>Renamed the <code>typeob</code> module to <code>type_object</code></li>
</ul>
<h3 id="removed-15"><a class="header" href="#removed-15">Removed</a></h3>
<ul>
<li><code>PyToken</code> was removed due to unsoundness (See <a href="https://github.com/PyO3/pyo3/issues/94">#94</a>).</li>
<li>Removed the unnecessary type parameter from <code>PyObjectAlloc</code></li>
<li><code>NoArgs</code>. Just use an empty tuple</li>
<li><code>PyObjectWithGIL</code>. <code>PyNativeType</code> is sufficient now that PyToken is removed.</li>
</ul>
<h3 id="fixed-49"><a class="header" href="#fixed-49">Fixed</a></h3>
<ul>
<li>A soudness hole where every instances of a <code>#[pyclass]</code> struct was considered to be part of a python object, even though you can create instances that are not part of the python heap. This was fixed through <code>PyRef</code> and <code>PyRefMut</code>.</li>
<li>Fix kwargs support in <a href="https://github.com/PyO3/pyo3/pull/328">#328</a>.</li>
<li>Add full support for <code>__dict__</code> in <a href="https://github.com/PyO3/pyo3/pull/403">#403</a>.</li>
</ul>
<h2 id="053---2019-01-04"><a class="header" href="#053---2019-01-04"><a href="https://github.com/pyo3/pyo3/compare/v0.5.2...v0.5.3">0.5.3</a> - 2019-01-04</a></h2>
<h3 id="fixed-50"><a class="header" href="#fixed-50">Fixed</a></h3>
<ul>
<li>Fix memory leak in ArrayList by kngwyu <a href="https://github.com/PyO3/pyo3/pull/316">#316</a></li>
</ul>
<h2 id="052---2018-11-25"><a class="header" href="#052---2018-11-25"><a href="https://github.com/pyo3/pyo3/compare/v0.5.1...v0.5.2">0.5.2</a> - 2018-11-25</a></h2>
<h3 id="fixed-51"><a class="header" href="#fixed-51">Fixed</a></h3>
<ul>
<li>Fix undeterministic segfaults when creating many objects by kngwyu in <a href="https://github.com/PyO3/pyo3/pull/281">#281</a></li>
</ul>
<h2 id="051---2018-11-24"><a class="header" href="#051---2018-11-24"><a href="https://github.com/pyo3/pyo3/compare/v0.5.0...v0.5.1">0.5.1</a> - 2018-11-24</a></h2>
<p>Yanked</p>
<h2 id="050---2018-11-11"><a class="header" href="#050---2018-11-11"><a href="https://github.com/pyo3/pyo3/compare/v0.4.1...v0.5.0">0.5.0</a> - 2018-11-11</a></h2>
<h3 id="added-42"><a class="header" href="#added-42">Added</a></h3>
<ul>
<li><code>#[pyclass]</code> objects can now be returned from rust functions</li>
<li><code>PyComplex</code> by kngwyu in <a href="https://github.com/PyO3/pyo3/pull/226">#226</a></li>
<li><code>PyDict::from_sequence</code>, equivalent to <code>dict([(key, val), ...])</code></li>
<li>Bindings for the <code>datetime</code> standard library types: <code>PyDate</code>, <code>PyTime</code>, <code>PyDateTime</code>, <code>PyTzInfo</code>, <code>PyDelta</code> with associated <code>ffi</code> types, by pganssle <a href="https://github.com/PyO3/pyo3/pull/200">#200</a>.</li>
<li><code>PyString</code>, <code>PyUnicode</code>, and <code>PyBytes</code> now have an <code>as_bytes</code> method that returns <code>&amp;[u8]</code>.</li>
<li><code>PyObjectProtocol::get_type_ptr</code> by ijl in <a href="https://github.com/PyO3/pyo3/pull/242">#242</a></li>
</ul>
<h3 id="changed-30"><a class="header" href="#changed-30">Changed</a></h3>
<ul>
<li>Removes the types from the root module and the prelude. They now live in <code>pyo3::types</code> instead.</li>
<li>All exceptions are constructed with <code>py_err</code> instead of <code>new</code>, as they return <code>PyErr</code> and not <code>Self</code>.</li>
<li><code>as_mut</code> and friends take and <code>&amp;mut self</code> instead of <code>&amp;self</code></li>
<li><code>ObjectProtocol::call</code> now takes an <code>Option&lt;&amp;PyDict&gt;</code> for the kwargs instead of an <code>IntoPyDictPointer</code>.</li>
<li><code>IntoPyDictPointer</code> was replace by <code>IntoPyDict</code> which doesn't convert <code>PyDict</code> itself anymore and returns a <code>PyDict</code> instead of <code>*mut PyObject</code>.</li>
<li><code>PyTuple::new</code> now takes an <code>IntoIterator</code> instead of a slice</li>
<li>Updated to syn 0.15</li>
<li>Splitted <code>PyTypeObject</code> into <code>PyTypeObject</code> without the create method and <code>PyTypeCreate</code> with requires <code>PyObjectAlloc&lt;Self&gt; + PyTypeInfo + Sized</code>.</li>
<li>Ran <code>cargo edition --fix</code> which prefixed path with <code>crate::</code> for rust 2018</li>
<li>Renamed <code>async</code> to <code>pyasync</code> as async will be a keyword in the 2018 edition.</li>
<li>Starting to use <code>NonNull&lt;*mut PyObject&gt;</code> for Py and PyObject by ijl <a href="https://github.com/PyO3/pyo3/pull/260">#260</a></li>
</ul>
<h3 id="removed-16"><a class="header" href="#removed-16">Removed</a></h3>
<ul>
<li>Removed most entries from the prelude. The new prelude is small and clear.</li>
<li>Slowly removing specialization uses</li>
<li><code>PyString</code>, <code>PyUnicode</code>, and <code>PyBytes</code> no longer have a <code>data</code> method
(replaced by <code>as_bytes</code>) and <code>PyStringData</code> has been removed.</li>
<li>The pyobject_extract macro</li>
</ul>
<h3 id="fixed-52"><a class="header" href="#fixed-52">Fixed</a></h3>
<ul>
<li>Added an explanation that the GIL can temporarily be released even while holding a GILGuard.</li>
<li>Lots of clippy errors</li>
<li>Fix segfault on calling an unknown method on a PyObject</li>
<li>Work around a <a href="https://github.com/rust-lang/rust/issues/55380">bug</a> in the rust compiler by kngwyu <a href="https://github.com/PyO3/pyo3/pull/252">#252</a></li>
<li>Fixed a segfault with subclassing pyo3 create classes and using <code>__class__</code> by kngwyu <a href="https://github.com/PyO3/pyo3/pull/263">#263</a></li>
</ul>
<h2 id="041---2018-08-20"><a class="header" href="#041---2018-08-20"><a href="https://github.com/pyo3/pyo3/compare/v0.4.0...v0.4.1">0.4.1</a> - 2018-08-20</a></h2>
<h3 id="changed-31"><a class="header" href="#changed-31">Changed</a></h3>
<ul>
<li>PyTryFrom's error is always to <code>PyDowncastError</code></li>
</ul>
<h3 id="fixed-53"><a class="header" href="#fixed-53">Fixed</a></h3>
<ul>
<li>Fixed compilation on nightly since <code>use_extern_macros</code> was stabilized</li>
</ul>
<h3 id="removed-17"><a class="header" href="#removed-17">Removed</a></h3>
<ul>
<li>The pyobject_downcast macro</li>
</ul>
<h2 id="040---2018-07-30"><a class="header" href="#040---2018-07-30"><a href="https://github.com/pyo3/pyo3/compare/v0.3.2...v0.4.0">0.4.0</a> - 2018-07-30</a></h2>
<h3 id="changed-32"><a class="header" href="#changed-32">Changed</a></h3>
<ul>
<li>Merged both examples into one</li>
<li>Rustfmt all the things :heavy_check_mark:</li>
<li>Switched to <a href="https://keepachangelog.com/en/1.0.0/">Keep a Changelog</a></li>
</ul>
<h3 id="removed-18"><a class="header" href="#removed-18">Removed</a></h3>
<ul>
<li>Conversions from tuples to PyDict due to <a href="https://github.com/rust-lang/rust/issues/52050">rust-lang/rust#52050</a></li>
</ul>
<h2 id="032---2018-07-22"><a class="header" href="#032---2018-07-22"><a href="https://github.com/pyo3/pyo3/compare/v0.3.1...v0.3.2">0.3.2</a> - 2018-07-22</a></h2>
<h3 id="changed-33"><a class="header" href="#changed-33">Changed</a></h3>
<ul>
<li>Replaced <code>concat_idents</code> with mashup</li>
</ul>
<h2 id="031---2018-07-18"><a class="header" href="#031---2018-07-18"><a href="https://github.com/pyo3/pyo3/compare/v0.3.0...v0.3.1">0.3.1</a> - 2018-07-18</a></h2>
<h3 id="fixed-54"><a class="header" href="#fixed-54">Fixed</a></h3>
<ul>
<li>Fixed scoping bug in pyobject_native_type that would break rust-numpy</li>
</ul>
<h2 id="030---2018-07-18"><a class="header" href="#030---2018-07-18"><a href="https://github.com/pyo3/pyo3/compare/v0.2.7...v0.3.0">0.3.0</a> - 2018-07-18</a></h2>
<h3 id="added-43"><a class="header" href="#added-43">Added</a></h3>
<ul>
<li>A few internal macros became part of the public api (<a href="https://github.com/PyO3/pyo3/pull/155">#155</a>, <a href="https://github.com/PyO3/pyo3/pull/186">#186</a>)</li>
<li>Always clone in getters. This allows using the get-annotation on all Clone-Types</li>
</ul>
<h3 id="changed-34"><a class="header" href="#changed-34">Changed</a></h3>
<ul>
<li>Upgraded to syn 0.14 which means much better error messages :tada:</li>
<li>128 bit integer support by <a href="https://github.com/kngwyu">kngwyu</a> (<a href="https://github.com/PyO3/pyo3/pull/173">#137</a>)</li>
<li><code>proc_macro</code> has been stabilized on nightly (<a href="https://github.com/rust-lang/rust/pull/52081">rust-lang/rust#52081</a>). This means that we can remove the <code>proc_macro</code> feature, but now we need the <code>use_extern_macros</code> from the 2018 edition instead.</li>
<li>All proc macro are now prefixed with <code>py</code> and live in the prelude. This means you can use <code>#[pyclass]</code>, <code>#[pymethods]</code>, <code>#[pyproto]</code>, <code>#[pyfunction]</code> and <code>#[pymodinit]</code> directly, at least after a <code>use pyo3::prelude::*</code>. They were also moved into a module called <code>proc_macro</code>. You shouldn't use <code>#[pyo3::proc_macro::pyclass]</code> or other longer paths in attributes because <code>proc_macro_path_invoc</code> isn't going to be stabilized soon.</li>
<li>Renamed the <code>base</code> option in the <code>pyclass</code> macro to <code>extends</code>.</li>
<li><code>#[pymodinit]</code> uses the function name as module name, unless the name is overrriden with <code>#[pymodinit(name)]</code></li>
<li>The guide is now properly versioned.</li>
</ul>
<h2 id="027---2018-05-18"><a class="header" href="#027---2018-05-18"><a href="https://github.com/pyo3/pyo3/compare/v0.2.6...v0.2.7">0.2.7</a> - 2018-05-18</a></h2>
<h3 id="fixed-55"><a class="header" href="#fixed-55">Fixed</a></h3>
<ul>
<li>Fix nightly breakage with proc_macro_path</li>
</ul>
<h2 id="026---2018-04-03"><a class="header" href="#026---2018-04-03"><a href="https://github.com/pyo3/pyo3/compare/v0.2.5...v0.2.6">0.2.6</a> - 2018-04-03</a></h2>
<h3 id="fixed-56"><a class="header" href="#fixed-56">Fixed</a></h3>
<ul>
<li>Fix compatibility with TryFrom trait #137</li>
</ul>
<h2 id="025---2018-02-21"><a class="header" href="#025---2018-02-21"><a href="https://github.com/pyo3/pyo3/compare/v0.2.4...v0.2.5">0.2.5</a> - 2018-02-21</a></h2>
<h3 id="added-44"><a class="header" href="#added-44">Added</a></h3>
<ul>
<li>CPython 3.7 support</li>
</ul>
<h3 id="fixed-57"><a class="header" href="#fixed-57">Fixed</a></h3>
<ul>
<li>Embedded CPython 3.7b1 crashes on initialization #110</li>
<li>Generated extension functions are weakly typed #108</li>
<li>call_method* crashes when the method does not exist #113</li>
<li>Allow importing exceptions from nested modules #116</li>
</ul>
<h2 id="024---2018-01-19"><a class="header" href="#024---2018-01-19"><a href="https://github.com/pyo3/pyo3/compare/v0.2.3...v0.2.4">0.2.4</a> - 2018-01-19</a></h2>
<h3 id="added-45"><a class="header" href="#added-45">Added</a></h3>
<ul>
<li>Allow to get mutable ref from PyObject #106</li>
<li>Drop <code>RefFromPyObject</code> trait</li>
<li>Add Python::register_any method</li>
</ul>
<h3 id="fixed-58"><a class="header" href="#fixed-58">Fixed</a></h3>
<ul>
<li>Fix impl <code>FromPyObject</code> for <code>Py&lt;T&gt;</code></li>
<li>Mark method that work with raw pointers as unsafe #95</li>
</ul>
<h2 id="023---11-27-2017"><a class="header" href="#023---11-27-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.2.2...v0.2.3">0.2.3</a> - 11-27-2017</a></h2>
<h3 id="changed-35"><a class="header" href="#changed-35">Changed</a></h3>
<ul>
<li>Rustup to 1.23.0-nightly 2017-11-07</li>
</ul>
<h3 id="fixed-59"><a class="header" href="#fixed-59">Fixed</a></h3>
<ul>
<li>Proper <code>c_char</code> usage #93</li>
</ul>
<h3 id="removed-19"><a class="header" href="#removed-19">Removed</a></h3>
<ul>
<li>Remove use of now unneeded 'AsciiExt' trait</li>
</ul>
<h2 id="022---09-26-2017"><a class="header" href="#022---09-26-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.2.1...v0.2.2">0.2.2</a> - 09-26-2017</a></h2>
<h3 id="changed-36"><a class="header" href="#changed-36">Changed</a></h3>
<ul>
<li>Rustup to 1.22.0-nightly 2017-09-30</li>
</ul>
<h2 id="021---09-26-2017"><a class="header" href="#021---09-26-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.2.0...v0.2.1">0.2.1</a> - 09-26-2017</a></h2>
<h3 id="fixed-60"><a class="header" href="#fixed-60">Fixed</a></h3>
<ul>
<li>Fix rustc const_fn nightly breakage</li>
</ul>
<h2 id="020---08-12-2017"><a class="header" href="#020---08-12-2017"><a href="https://github.com/pyo3/pyo3/compare/v0.1.0...v0.2.0">0.2.0</a> - 08-12-2017</a></h2>
<h3 id="added-46"><a class="header" href="#added-46">Added</a></h3>
<ul>
<li>Added inheritance support #15</li>
<li>Added weakref support #56</li>
<li>Added subclass support #64</li>
<li>Added <code>self.__dict__</code> supoort #68</li>
<li>Added <code>pyo3::prelude</code> module #70</li>
<li>Better <code>Iterator</code> support for PyTuple, PyList, PyDict #75</li>
<li>Introduce IntoPyDictPointer similar to IntoPyTuple #69</li>
</ul>
<h3 id="changed-37"><a class="header" href="#changed-37">Changed</a></h3>
<ul>
<li>Allow to add gc support without implementing PyGCProtocol #57</li>
<li>Refactor <code>PyErr</code> implementation. Drop <code>py</code> parameter from constructor.</li>
</ul>
<h2 id="010---07-23-2017"><a class="header" href="#010---07-23-2017"><a href="https://github.com/PyO3/pyo3/tree/0.1.0">0.1.0</a> - 07-23-2017</a></h2>
<h3 id="added-47"><a class="header" href="#added-47">Added</a></h3>
<ul>
<li>Initial release</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h1>
<p>Thank you for your interest in contributing to PyO3! All are welcome - please consider reading our <a href="https://github.com/PyO3/pyo3/blob/main/Code-of-Conduct.md">Code of Conduct</a> to keep our community positive and inclusive.</p>
<p>If you are searching for ideas how to contribute, proceed to the <a href="contributing.html#getting-started-contributing">"Getting started contributing"</a> section. If you have found a specific issue to contribute to and need information about the development process, you may find the section <a href="contributing.html#writing-pull-requests">"Writing pull requests"</a> helpful.</p>
<p>If you want to become familiar with the codebase, see
<a href="https://github.com/PyO3/pyo3/blob/main/Architecture.md">Architecture.md</a>.</p>
<h2 id="getting-started-contributing"><a class="header" href="#getting-started-contributing">Getting started contributing</a></h2>
<p>Please join in with any part of PyO3 which interests you. We use GitHub issues to record all bugs and ideas. Feel free to request an issue to be assigned to you if you want to work on it.</p>
<p>You can browse the API of the non-public parts of PyO3 <a href="https://pyo3.netlify.app/internal/doc/pyo3/index.html">here</a>.</p>
<p>The following sections also contain specific ideas on where to start contributing to PyO3.</p>
<h2 id="setting-up-a-development-environment"><a class="header" href="#setting-up-a-development-environment">Setting up a development environment</a></h2>
<p>To work and develop PyO3, you need Python &amp; Rust installed on your system.</p>
<ul>
<li>We encourage the use of <a href="https://rustup.rs/">rustup</a> to be able to select and choose specific toolchains based on the project.</li>
<li><a href="https://github.com/pyenv/pyenv">Pyenv</a> is also highly recommended for being able to choose a specific Python version.</li>
<li><a href="https://virtualenv.pypa.io/en/latest/">virtualenv</a> can also be used with or without Pyenv to use specific installed Python versions.</li>
<li><a href="https://github.com/theacodes/nox"><code>nox</code></a> is used to automate many of our CI tasks.</li>
</ul>
<h3 id="caveats"><a class="header" href="#caveats">Caveats</a></h3>
<ul>
<li>When using pyenv on macOS, installing a Python version using <code>--enable-shared</code> is required to make it work. i.e <code>env PYTHON_CONFIGURE_OPTS="--enable-shared" pyenv install 3.7.12</code></li>
</ul>
<h3 id="help-users-identify-bugs"><a class="header" href="#help-users-identify-bugs">Help users identify bugs</a></h3>
<p>The <a href="https://discord.gg/33kcChzH7f">PyO3 Discord server</a> is very active with users who are new to PyO3, and often completely new to Rust. Helping them debug is a great way to get experience with the PyO3 codebase.</p>
<p>Helping others often reveals bugs, documentation weaknesses, and missing APIs. It's a good idea to open GitHub issues for these immediately so the resolution can be designed and implemented!</p>
<h3 id="implement-issues-ready-for-development"><a class="header" href="#implement-issues-ready-for-development">Implement issues ready for development</a></h3>
<p>Issues where the solution is clear and work is not in progress use the <a href="https://github.com/PyO3/pyo3/issues?q=is%3Aissue+is%3Aopen+label%3Aneeds-implementer">needs-implementer</a> label.</p>
<p>Don't be afraid if the solution is not clear to you! The core PyO3 contributors will be happy to mentor you through any questions you have to help you write the solution.</p>
<h3 id="help-write-great-docs"><a class="header" href="#help-write-great-docs">Help write great docs</a></h3>
<p>PyO3 has a user guide (using mdbook) as well as the usual Rust API docs. The aim is for both of these to be detailed, easy to understand, and up-to-date. Pull requests are always welcome to fix typos, change wording, add examples, etc.</p>
<p>There are some specific areas of focus where help is currently needed for the documentation:</p>
<ul>
<li>Issues requesting documentation improvements are tracked with the <a href="https://github.com/PyO3/pyo3/issues?q=is%3Aissue+is%3Aopen+label%3Adocumentation">documentation</a> label.</li>
<li>Not all APIs had docs or examples when they were made. The goal is to have documentation on all PyO3 APIs (<a href="https://github.com/PyO3/pyo3/issues/306">#306</a>). If you see an API lacking a doc, please write one and open a PR!</li>
</ul>
<p>To build the docs (including all features), install <a href="https://github.com/theacodes/nox"><code>nox</code></a> and then run</p>
<pre><code class="language-shell">nox -s docs -- open
</code></pre>
<h4 id="doctests"><a class="header" href="#doctests">Doctests</a></h4>
<p>We use lots of code blocks in our docs. Run <code>cargo test --doc</code> when making changes to check that
the doctests still work, or <code>cargo test</code> to run all the tests including doctests. See
https://doc.rust-lang.org/rustdoc/documentation-tests.html for a guide on doctests.</p>
<h4 id="building-the-guide"><a class="header" href="#building-the-guide">Building the guide</a></h4>
<p>You can preview the user guide by building it locally with <code>mdbook</code>.</p>
<p>First, install <a href="https://rust-lang.github.io/mdBook/cli/index.html"><code>mdbook</code></a> and <a href="https://github.com/theacodes/nox"><code>nox</code></a>. Then, run</p>
<pre><code class="language-shell">nox -s build-guide -- --open
</code></pre>
<p>To check all links in the guide are valid, also install <a href="https://github.com/lycheeverse/lychee"><code>lychee</code></a> and use the <code>check-guide</code> session instead:</p>
<pre><code class="language-shell">nox -s check-guide
</code></pre>
<h3 id="help-design-the-next-pyo3"><a class="header" href="#help-design-the-next-pyo3">Help design the next PyO3</a></h3>
<p>Issues which don't yet have a clear solution use the <a href="https://github.com/PyO3/pyo3/issues?q=is%3Aissue+is%3Aopen+label%3Aneeds-design">needs-design</a> label.</p>
<p>If any of these issues interest you, please join in with the conversation on the issue! All opinions are valued, and if you're interested in going further with e.g. draft PRs to experiment with API designs, even better!</p>
<h3 id="review-pull-requests"><a class="header" href="#review-pull-requests">Review pull requests</a></h3>
<p>Everybody is welcome to submit comments on open PRs. Please help ensure new PyO3 APIs are safe, performant, tidy, and easy to use!</p>
<h2 id="writing-pull-requests"><a class="header" href="#writing-pull-requests">Writing pull requests</a></h2>
<p>Here are a few things to note when you are writing PRs.</p>
<h3 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h3>
<p>The PyO3 repo uses GitHub Actions. PRs are blocked from merging if CI is not successful.</p>
<p>Formatting, linting and tests are checked for all Rust and Python code. In addition, all warnings in Rust code are disallowed (using <code>RUSTFLAGS="-D warnings"</code>).</p>
<p>Tests run with all supported Python versions with the latest stable Rust compiler, as well as for Python 3.9 with the minimum supported Rust version.</p>
<p>If you are adding a new feature, you should add it to the <code>full</code> feature in our <em>Cargo.toml</em>* so that it is tested in CI.</p>
<p>You can run these tests yourself with
<code>nox</code>. Use  <code>nox -l</code> to list the full set of subcommands you can run.</p>
<h4 id="ui-tests"><a class="header" href="#ui-tests">UI Tests</a></h4>
<p>PyO3 uses [<code>trybuild</code>][trybuild] to develop UI tests to capture error messages from the Rust compiler for some of the macro functionality.</p>
<p>Because there are several feature combinations for these UI tests, when updating them all (e.g. for a new Rust compiler version) it may be helpful to use the <code>update-ui-tests</code> nox session:</p>
<pre><code class="language-bash">nox -s update-ui-tests
</code></pre>
<h3 id="documenting-changes"><a class="header" href="#documenting-changes">Documenting changes</a></h3>
<p>We use <a href="https://towncrier.readthedocs.io/en/stable/index.html">towncrier</a> to generate a CHANGELOG for each release.</p>
<p>To include your changes in the release notes, you should create one (or more) news items in the <code>newsfragments</code> directory. Valid news items should be saved as <code>&lt;PR&gt;.&lt;CATEGORY&gt;.md</code> where <code>&lt;PR&gt;</code> is the pull request number and <code>&lt;CATEGORY&gt;</code> is one of the following:</p>
<ul>
<li><code>packaging</code> - for dependency changes and Python / Rust version compatibility changes</li>
<li><code>added</code> - for new features</li>
<li><code>changed</code> - for features which already existed but have been altered or deprecated</li>
<li><code>removed</code> - for features which have been removed</li>
<li><code>fixed</code> - for "changed" features which were classed as a bugfix</li>
</ul>
<p>Docs-only PRs do not need news items; start your PR title with <code>docs:</code> to skip the check.</p>
<h3 id="style-guide"><a class="header" href="#style-guide">Style guide</a></h3>
<h4 id="generic-code"><a class="header" href="#generic-code">Generic code</a></h4>
<p>PyO3 has a lot of generic APIs to increase usability. These can come at the cost of generic code bloat. Where reasonable, try to implement a concrete sub-portion of generic functions. There are two forms of this:</p>
<ul>
<li>If the concrete sub-portion doesn't benefit from re-use by other functions, name it <code>inner</code> and keep it as a local to the function.</li>
<li>If the concrete sub-portion is re-used by other functions, preferably name it <code>_foo</code> and place it directly below <code>foo</code> in the source code (where <code>foo</code> is the original generic function).</li>
</ul>
<h4 id="ffi-calls"><a class="header" href="#ffi-calls">FFI calls</a></h4>
<p>PyO3 makes a lot of FFI calls to Python's C API using raw pointers. Where possible try to avoid using pointers-to-temporaries in expressions:</p>
<pre><code class="language-rust">// dangerous
pyo3::ffi::Something(name.to_object(py).as_ptr());

// because the following refactoring is a use-after-free error:
let name = name.to_object(py).as_ptr();
pyo3::ffi::Something(name)</code></pre>
<p>Instead, prefer to bind the safe owned <code>PyObject</code> wrapper before passing to ffi functions:</p>
<pre><code class="language-rust">let name: PyObject = name.to_object(py);
pyo3::ffi::Something(name.as_ptr())
// name will automatically be freed when it falls out of scope</code></pre>
<h2 id="python-and-rust-version-support-policy"><a class="header" href="#python-and-rust-version-support-policy">Python and Rust version support policy</a></h2>
<p>PyO3 aims to keep sufficient compatibility to make packaging Python extensions built with PyO3 feasible on most common package managers.</p>
<p>To keep package maintainers' lives simpler, PyO3 will commit, wherever possible, to only adjust minimum supported Rust and Python versions at the same time. This bump will only come in an <code>0.x</code> release, roughly once per year, after the oldest supported Python version reaches its end-of-life. (Check https://endoflife.date/python for a clear timetable on these.)</p>
<p>Below are guidelines on what compatibility all PRs are expected to deliver for each language.</p>
<h3 id="python-1"><a class="header" href="#python-1">Python</a></h3>
<p>PyO3 supports all officially supported Python versions, as well as the latest PyPy3 release. All of these versions are tested in CI.</p>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<p>PyO3 aims to make use of up-to-date Rust language features to keep the implementation as efficient as possible.</p>
<p>The minimum Rust version supported will be decided when the release which bumps Python and Rust versions is made. At the time, the minimum Rust version will be set no higher than the lowest Rust version shipped in the current Debian, RHEL and Alpine Linux distributions.</p>
<p>CI tests both the most recent stable Rust version and the minimum supported Rust version. Because of Rust's stability guarantees this is sufficient to confirm support for all Rust versions in between.</p>
<h2 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h2>
<p>PyO3 has two sets of benchmarks for evaluating some aspects of its performance. The benchmark suite is currently very small - please open PRs with new benchmarks if you're interested in helping to expand it!</p>
<p>First, there are Rust-based benchmarks located in the <code>pyo3-benches</code> subdirectory. You can run these benchmarks with:</p>
<pre><code>nox -s bench
</code></pre>
<p>Second, there is a Python-based benchmark contained in the <code>pytests</code> subdirectory. You can read more about it <a href="https://github.com/PyO3/pyo3/tree/main/pytests">here</a>.</p>
<h2 id="code-coverage"><a class="header" href="#code-coverage">Code coverage</a></h2>
<p>You can view what code is and isn't covered by PyO3's tests. We aim to have 100% coverage - please check coverage and add tests if you notice a lack of coverage!</p>
<ul>
<li>First, ensure the llvm-cov cargo plugin is installed. You may need to run the plugin through cargo once before using it with <code>nox</code>.</li>
</ul>
<pre><code class="language-shell">cargo install cargo-llvm-cov
cargo llvm-cov
</code></pre>
<ul>
<li>Then, generate an <code>lcov.info</code> file with</li>
</ul>
<pre><code class="language-shell">nox -s coverage -- lcov
</code></pre>
<p>You can install an IDE plugin to view the coverage. For example, if you use VSCode:</p>
<ul>
<li>Add the <a href="https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters">coverage-gutters</a> plugin.</li>
<li>Add these settings to VSCode's <code>settings.json</code>:</li>
</ul>
<pre><code class="language-json">{
    "coverage-gutters.coverageFileNames": [
        "lcov.info",
        "cov.xml",
        "coverage.xml",
    ],
    "coverage-gutters.showLineCoverage": true
}
</code></pre>
<ul>
<li>You should now be able to see green highlights for code that is tested, and red highlights for code that is not tested.</li>
</ul>
<h2 id="sponsor-this-project"><a class="header" href="#sponsor-this-project">Sponsor this project</a></h2>
<p>At the moment there is no official organisation that accepts sponsorship on PyO3's behalf. If you're seeking to provide significant funding to the PyO3 ecosystem, please reach out to us on <a href="https://github.com/PyO3/pyo3/issues/new">GitHub</a> or <a href="https://discord.gg/33kcChzH7f">Discord</a> and we can discuss.</p>
<p>In the meanwhile, some of our maintainers have personal GitHub sponsorship pages and would be grateful for your support:</p>
<ul>
<li><a href="https://github.com/sponsors/davidhewitt">davidhewitt</a></li>
<li><a href="https://github.com/sponsors/messense">messense</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
